<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be who you want to be">
<meta property="og:type" content="website">
<meta property="og:title" content="kiro的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="kiro的博客">
<meta property="og:description" content="Be who you want to be">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="kiro-xu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>kiro的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kiro的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/28/redis%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/28/redis%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">redis学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-28 19:59:29" itemprop="dateCreated datePublished" datetime="2021-06-28T19:59:29+08:00">2021-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-30 13:50:47" itemprop="dateModified" datetime="2021-06-30T13:50:47+08:00">2021-06-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="NoSQL前言"><a href="#NoSQL前言" class="headerlink" title="NoSQL前言"></a>NoSQL前言</h3><blockquote>
<p>NoSQL泛指非关系型数据库</p>
</blockquote>
<p>架构设计演变：</p>
<ul>
<li>单机MySQL：访问量不大，用单个数据库完成。APP =&gt;  DAL(数据访问层)  =&gt; MySQL Instance</li>
<li>Memcached(缓存) + MySQL + 垂直拆分</li>
<li>MySQL主从读写分离：由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。</li>
<li>分表分库+水平拆分+mysql集群</li>
<li>Today</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/60dabad95132923bf8d2eb89.jpg"><img src="https://pic.imgdb.cn/item/60dabad95132923bf8d2eb89.jpg"></a></p>
<h4 id="商品信息的存储方案"><a href="#商品信息的存储方案" class="headerlink" title="商品信息的存储方案"></a>商品信息的存储方案</h4><ul>
<li>商品基本信息：包括名称、价格、出厂日期、生产厂商等<ul>
<li>特点：改动不大</li>
<li>使用：关系型数据库MySQL</li>
</ul>
</li>
<li>商品描述、详情、评价信息（多文字类）<ul>
<li>特点：多文字，IO读写性能差</li>
<li>使用：文档数据库MongDB</li>
</ul>
</li>
<li>商品图片<ul>
<li>分布式的文件系统</li>
</ul>
</li>
<li>商品的关键字<ul>
<li>搜索引擎ISearch</li>
</ul>
</li>
<li>商品的波段性的热点高频信息（如，情人节的巧克力）<ul>
<li>内存数据库Redis</li>
</ul>
</li>
<li>商品的交易、价格计算、积分累计<ul>
<li>外部系统，外部第三方支付接口</li>
</ul>
</li>
</ul>
<h3 id="对redis的简单概述"><a href="#对redis的简单概述" class="headerlink" title="对redis的简单概述"></a>对redis的简单概述</h3><p><code>Redis</code>是一个用C语言开发的数据库。不同于传统数据库，<code>Redis</code><strong>存储在内存</strong>中，即<strong>内存数据库</strong>，读写非常快。</p>
<p>常被用于做<strong>缓存</strong>、<strong>分布式锁</strong>、<strong>消息队列</strong>等。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>主要流程</strong></p>
<p><img src="https://seikim.com/i/2021/06/28/x7t744.png"></p>
<p><strong>为什么要用缓存？</strong></p>
<ul>
<li><strong>高性能</strong>：那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</li>
<li><strong>高并发</strong>：一般像 MySQL 这类的数据库的 QPS（服务器每秒可以执行的查询次数） 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</li>
</ul>
<h3 id="Redis-常见数据结构以及使用场景分析"><a href="#Redis-常见数据结构以及使用场景分析" class="headerlink" title="Redis 常见数据结构以及使用场景分析"></a>Redis 常见数据结构以及使用场景分析</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>简单的 key-value 类型。</p>
<p>常用命令：<code>set,get,strlen,exists,decr,incr,setex</code></p>
<p>应用场景：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;基础方法</span><br><span class="line">127.0.0.1:6379&gt; set key value #设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key # 根据 key 获得对应的 value</span><br><span class="line">&quot;value&quot;</span><br><span class="line">127.0.0.1:6379&gt; exists key  # 判断某个 key 是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key # 返回 key 所储存的字符串值的长度。</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; del key # 删除某个 key 对应的值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;批量设置</span><br><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 # 批量设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 # 批量获取多个 key 对应的 value</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计数器应用</span><br><span class="line">127.0.0.1:6379&gt; set number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number # 将 key 中储存的数字值增一</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr number # 将 key 中储存的数字值减一</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过期相关，默认永不过期</span><br><span class="line">127.0.0.1:6379&gt; expire key  60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>链表，Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>常用命令：<code>rpush,lpop,lpush,rpop,lrange,llen</code></p>
<p>应用场景：发布与订阅或者说消息队列、慢查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;简单使用</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value1 # 向 list 的头部（右边）添加元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 # 向list的头部（最右边）添加多个元素</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList # 将 list的尾部(最左边)元素取出</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end</span><br><span class="line">1) &quot;value2&quot;</span><br><span class="line">2) &quot;value3&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一</span><br><span class="line">1) &quot;value2&quot;</span><br><span class="line">2) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>
<p>通过 <code>llen</code> 查看链表长度：<code>llen mylist</code></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<p>常用命令：<code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code></p>
<p>应用场景：系统中对象的存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset userInfoKey name &quot;guide&quot; description &quot;dev&quot; age &quot;24&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name # 获取存储在哈希表中指定字段的值。</span><br><span class="line">&quot;guide&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line">&quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;guide&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;dev&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey # 获取 key 列表</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;description&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey # 获取 value 列表</span><br><span class="line">1) &quot;guide&quot;</span><br><span class="line">2) &quot;dev&quot;</span><br><span class="line">3) &quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name &quot;GuideGeGe&quot; # 修改某个字段对应的值</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line">&quot;GuideGeGe&quot;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序</p>
<p>常用命令：<code>sadd,spop,smembers,sismember,scard,sinterstone,sunion</code></p>
<p>应用场景：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard mySet # 查看 set 的长度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</p>
<p>常用命令：<code>zadd,zcard,zscore,zrange,zrevrange,zrem</code></p>
<p>应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 # 一次添加多个元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 # 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。</p>
<p>常用命令：<code>setbit,getbit,bitcount,bitop</code></p>
<p>应用场景：适合需要保存状态信息（比如是否签到、是否登录…）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 7 0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit mykey 7</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 8 1</span><br><span class="line">(integer) 0</span><br><span class="line"># 通过 bitcount 统计被被设置为 1 的位的数量。</span><br><span class="line">127.0.0.1:6379&gt; bitcount mykey</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h3 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h3><p>基于Reactor模式来设计开发了一套高效的事件处理模型——文件事件处理器。</p>
<p>Redis通过<strong>IO多路复用程序</strong>来监听来自客户端的大量连接。</p>
<p>对IO多路复用的简单理解，基于阻塞IO的优化，可以同时监控多个Conversation。</p>
<blockquote>
<p>文件事件处理器：使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器</p>
</blockquote>
<h4 id="Redis6-0之前为什么不使用多线程？"><a href="#Redis6-0之前为什么不使用多线程？" class="headerlink" title="Redis6.0之前为什么不使用多线程？"></a>Redis6.0之前为什么不使用多线程？</h4><ul>
<li>单线程编程简单且更容易维护</li>
<li>Redis的性能瓶颈不在CPU，主要在内存和网络</li>
<li>多线程会存在死锁、上下文切换等问题，甚至影响性能</li>
</ul>
<h4 id="Redis6-0之后为什么引入了多线程？"><a href="#Redis6-0之后为什么引入了多线程？" class="headerlink" title="Redis6.0之后为什么引入了多线程？"></a>Redis6.0之后为什么引入了多线程？</h4><p>主要是为了提高Redis的网络IO读写性能。</p>
<h3 id="Redis给缓存数据设置过期事件"><a href="#Redis给缓存数据设置过期事件" class="headerlink" title="Redis给缓存数据设置过期事件"></a>Redis给缓存数据设置过期事件</h3><h4 id="为什么要过期？"><a href="#为什么要过期？" class="headerlink" title="为什么要过期？"></a>为什么要过期？</h4><blockquote>
<p>内存有限或业务需求（token），Redis自带了给缓存数据设置过期时间的功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exp key 60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>

<h4 id="如何判断过期？"><a href="#如何判断过期？" class="headerlink" title="如何判断过期？"></a>如何判断过期？</h4><p>通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/60dae8295132923bf8ec0f9c.jpg"><img src="https://pic.imgdb.cn/item/60dae8295132923bf8ec0f9c.jpg"></a></p>
<h4 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h4><ul>
<li><strong>惰性删除</strong>：取出key时对数据进行过期检查。对CPU友好，但内存损耗较多</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ul>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>进一步解决方案：<strong>淘汰机制</strong></p>
<h4 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h4><blockquote>
<p> 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>六种淘汰机制：</p>
<ul>
<li><code>volatile-lru(least recently used)</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>最近最少</strong>使用的数据淘汰</li>
<li><code>volatile-ttl</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><code>volatile-random</code>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><code>allkeys-random</code>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><code>no-eviction</code>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ul>
<p>4.0版本后新增：</p>
<ul>
<li><code>volatile-lfu(least frequently used)</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><code>allkeys-lfu</code>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h3 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<ul>
<li><strong>快照</strong>：<code>snapshotting</code>，RDB</li>
<li><strong>只追加文件</strong>：<code>append-only file</code>，AOF</li>
</ul>
<p><strong>快照</strong></p>
<blockquote>
<p>创建副本，默认的持久化方式</p>
</blockquote>
<p>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<p><strong>AOF</strong></p>
<blockquote>
<p>AOF 持久化的实时性更好，因此已成为主流的持久化方案</p>
</blockquote>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a target="_blank" rel="noopener" href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令将执行所有命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）。</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a target="_blank" rel="noopener" href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>
<p>需要注意的是，<strong>Redis不支持<code>rollback</code>、<code>Durability</code>，因而不满足原子性和持久性</strong></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p>
</blockquote>
<p>举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>参数校验，排除不合法的参数请求</li>
<li>缓存无效key并设置过期时间，解决请求key变化不频繁的情况</li>
<li>布隆过滤器，把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。<strong>空间换时间</strong><ul>
<li>布隆过滤器说某个元素存在，小概率会误判。<strong>不同的字符串可能哈希出来的位置相同</strong></li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/NodeJs%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/16/NodeJs%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" class="post-title-link" itemprop="url">NodeJs学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-16 11:23:06 / 修改时间：11:25:28" itemprop="dateCreated datePublished" datetime="2021-06-16T11:23:06+08:00">2021-06-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><blockquote>
<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎</p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-module-system.htmlhttps://www.runoob.com/nodejs/nodejs-module-system.html">菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Liu_yunzhao/article/details/90734257?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1328740.38110.16169863950293667&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control">事件循环</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">同步与异步、阻塞与非阻塞的理解</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/05/async.html">js的异步编程</a></p>
<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module">模块机制1</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019856995?utm_source=tag-newest">模块机制2</a></p>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><blockquote>
<p>NPM是随同NodeJS一起安装的包管理工具</p>
</blockquote>
<h4 id="使用npm命令安装模块"><a href="#使用npm命令安装模块" class="headerlink" title="使用npm命令安装模块"></a>使用npm命令安装模块</h4><p>npm安装node.js模块语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 <strong>require(‘express’)</strong> 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let express &#x3D; require(&#39;express&#39;);</span><br></pre></td></tr></table></figure>

<p>npm 的包安装分为本地安装（local）、全局安装（global）两种，<code>-g</code>用于区分。</p>
<h4 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a>查看安装信息</h4><p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list -g</span><br></pre></td></tr></table></figure>

<p>查看某个模块的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list grunt</span><br></pre></td></tr></table></figure>

<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>每个模块都有自己的package.json，用于定义包的属性。属性说明：</p>
<ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字</li>
</ul>
<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm ls</span><br></pre></td></tr></table></figure>

<h4 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h4><p>使用以下来搜索模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h3><p>Node.js异步编程的直接体现就是回调。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>对比示例：</p>
<p>创建一个文件input.txt，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的博客地址：www.kiroxu.top</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞式</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;input.txt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行结束&quot;</span>)</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line">我的博客地址：www.kiroxu.top</span><br><span class="line">程序执行结束</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非阻塞式</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;input.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">	<span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行结束&quot;</span>)</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line">程序执行结束</span><br><span class="line">我的博客地址：www.kiroxu.top</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h3><blockquote>
<p>Node.js采用事件驱动+异步I/O的方式，实现了一个单线程、高并发的JavaScript运行时环境。</p>
</blockquote>
<h4 id="高并发策略"><a href="#高并发策略" class="headerlink" title="高并发策略"></a>高并发策略</h4><p>一般来说，如Java，高并发的解决方案是提供多线程模型，服务器为每个客户端请求分配一个线程，使用同步I/O，并用线程切换来弥补同步I/O调用的时间开销。</p>
<p>Node.js对I/O进行了异步处理，避开了创建、销毁以及切换线程所需的开销和复杂性。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>Node.js在主线程里维护了一个<strong>事件队列</strong>。</p>
<ul>
<li>接到请求放入队列，并继续接收其他请求；</li>
<li>若主线程空闲（没有请求接入时），开启循环事件队列：若非I/O任务，主线程直接处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 <strong>线程池</strong> 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</li>
<li>当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到<strong>事件队列</strong>的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。</li>
</ul>
<p>Node.js被分为了四层，分别为<strong>应用层、V8引擎层、Node API层和LIBUV层</strong>。</p>
<p><img src="https://i.loli.net/2021/06/04/zqIOpN5U2ZGXFyw.png" alt="image.png"></p>
<blockquote>
<p>应用层：JavaScript交互层，常见的就是Node.js模块，如http、fs</p>
<p>V8引擎层：即利用V8引擎来解析JavaScript语法，进而和下层交互</p>
<p>NodeAPI层：为上层模块提供系统调用，一般由C语言实现，和操作系统进行交互</p>
<p>LIBUV层：跨平台的底层封装，实现了 事件循环、文件操作等，是实现Node.js异步的核心</p>
</blockquote>
<p><strong>值得注意的是</strong>：</p>
<p>无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 <strong>线程池</strong> 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，<strong>Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。</strong></p>
<h4 id="实现简易的事件循环"><a href="#实现简易的事件循环" class="headerlink" title="实现简易的事件循环"></a>实现简易的事件循环</h4><ol>
<li>定义事件队列</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义事件队列</span></span><br><span class="line"><span class="comment"> * 入队：push(); 出队：shift()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">globalEventQueue: []</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义接收请求入口</li>
</ol>
<p>每一个请求都会被拦截并进入处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">processHttpRequest: <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//定义一个事件对象</span></span><br><span class="line">	<span class="keyword">var</span> event = &#123;</span><br><span class="line">		params: request.params, <span class="comment">//传递请求参数</span></span><br><span class="line">		result: <span class="literal">null</span>, <span class="comment">//存放请求结果</span></span><br><span class="line">		callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//指定回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	globalEventQueue.push(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义Event Loop</li>
</ol>
<p>当主线程处于空闲时就开始循环事件队列，所以我们还要定义一个函数来循环事件队列： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eventLoop: function()&#123;</span><br><span class="line">	&#x2F;&#x2F;如果队列不为空，就继续循环</span><br><span class="line">	while(this.globalEventQueue.length &gt; 0)&#123;</span><br><span class="line">		var event &#x3D; this.globalEventQueue.shift();</span><br><span class="line">		if(isIOTask(event))&#123;</span><br><span class="line">			&#x2F;&#x2F;如果是IO任务</span><br><span class="line">			var thread &#x3D; getThreadFromThreadPool(); &#x2F;&#x2F;拿出线程处理</span><br><span class="line">			thread.handleIOTask(event);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F; 非耗时任务处理后，直接返回结果</span><br><span class="line">            var result &#x3D; handleEvent(event);</span><br><span class="line">            &#x2F;&#x2F; 最终通过回调函数返回给V8，再由V8返回给应用程序</span><br><span class="line">            event.callback.call(null,result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深入理解Node-js事件循环"><a href="#深入理解Node-js事件循环" class="headerlink" title="深入理解Node.js事件循环"></a>深入理解Node.js事件循环</h3><p>实际上异步任务之间并不相同，因此他们之间也有优先级之分，所以任务队列被分成两种类型：<br>microtask queue 微任务队列，macrotask queue 宏任务队列</p>
<p><strong>宏任务</strong>：<code>setTimeout</code>、<code>setInterval</code>、<code>Ajax</code>、<code>DOM事件</code>、<code>I/O</code>、<code>script标签中的整体代码</code></p>
<p><strong>微任务</strong>：<code>new Promise()</code>、<code>new MutaionObserver()</code></p>
<p>一次事件循环流程：<strong>取出一个宏任务开始-&gt;执行栈执行-&gt;执行栈为空-&gt;微任务队列执行-&gt;微任务队列为空-&gt;完成</strong></p>
<p>注意：</p>
<ul>
<li>宏任务或微任务执行过程产生的<strong>宏任务</strong>，在下一次事件循环执行</li>
<li>宏任务或微任务执行过程产生的<strong>微任务</strong>，在本次事件循环执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;start&quot;);</span><br><span class="line"></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&quot;setTimeout1&quot;);</span><br><span class="line">      new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&quot;setTimeout1-Promise-start&quot;);</span><br><span class="line">        resolve(&quot;setTimeout1-Promise&quot;);</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">        console.log(&quot;Promise1-then1&quot;);</span><br><span class="line">        return value;</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line"></span><br><span class="line">      console.log(&quot;Promise1-start&quot;);</span><br><span class="line">      resolve(&quot;Promise1-resolve&quot;);</span><br><span class="line">      console.log(&quot;Promise1-end&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">      console.log(&quot;Promise1-then1&quot;);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">      console.log(&quot;Promise1-then2&quot;);</span><br><span class="line"></span><br><span class="line">      Promise.resolve(&quot;Promise2&quot;)</span><br><span class="line">        .then(value1 &#x3D;&gt; &#123;</span><br><span class="line">          console.log(value1);</span><br><span class="line">          console.log(&quot;Promise2-then1&quot;);</span><br><span class="line">          return value1;</span><br><span class="line">        &#125;).then(value1 &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value1);</span><br><span class="line">        console.log(&quot;Promise2-then2&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&quot;setTimeout2&quot;)</span><br><span class="line">      new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&quot;setTimeout2-Promise-start&quot;);</span><br><span class="line">        resolve(&quot;setTimeout2-Promise&quot;);</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    console.log(&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行结果</span><br><span class="line">start</span><br><span class="line">Promise1-start</span><br><span class="line">Promise2-end</span><br><span class="line">end</span><br><span class="line">&#x2F;&#x2F;执行栈为空，执行微任务</span><br><span class="line">promise1-resolve</span><br><span class="line">promise1-then1</span><br><span class="line">promise1-resolve</span><br><span class="line">promise1-then2</span><br><span class="line">Promise2</span><br><span class="line">Promise2-then1</span><br><span class="line">Promise2</span><br><span class="line">Promise2-then2</span><br><span class="line">&#x2F;&#x2F;第一次事件循环结束</span><br><span class="line">setTimeout1</span><br><span class="line">setTimeout1-Promise-start</span><br><span class="line">setTimeout1-Promise</span><br><span class="line">Promise1-then1</span><br><span class="line">setTimeout1-Promise</span><br><span class="line">&#x2F;&#x2F;第二次事件循环结束</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout2-Promise-start</span><br><span class="line">setTimeout2-Promise</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步 阻塞与非阻塞"></a>同步与异步 阻塞与非阻塞</h4><blockquote>
<p>同步与异步关注的是<strong>消息通知机制</strong>，调用者是主动等待还是被动接收</p>
</blockquote>
<blockquote>
<p>阻塞与非阻塞更关注的是<strong>程序在等待调用结果（消息，返回值）时的状态</strong>，挂起or继续执行</p>
</blockquote>
<p>以Linux环境下的network IO为例，具体说明：</p>
<p>IO Model：<code>blocking IO</code>、<code>nonblocking IO</code>、<code>IO multiplexing</code>、<code>signal driven IO</code>、<code>asynchronous IO</code></p>
<p>需要了解的前置知识：</p>
<p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p><strong>blocking IO</strong></p>
<p><img src="https://i.loli.net/2021/06/10/5xMq4a6Gbv1tYHu.png" alt="image.png"></p>
<p>对于blocking IO，两个阶段均被阻塞</p>
<p><strong>non-blocking IO</strong></p>
<p><img src="https://i.loli.net/2021/06/10/Bn6JpjMIvcDYs2i.png" alt="image.png"></p>
<p>用户进程需要不断的主动询问kernel数据是否准备完成，copy data阶段堵塞。</p>
<p><strong>IO multiplexing</strong></p>
<p><img src="https://i.loli.net/2021/06/10/DpJPWlBziId85Aq.png" alt="image.png"></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>本质任然是堵塞的，只是可以处理多个IO。</p>
<p><strong>Asynchronous I/O</strong></p>
<p><img src="https://www.hualigs.cn/image/60c1d03384402.jpg"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h3 id="ES6异步编程的实现"><a href="#ES6异步编程的实现" class="headerlink" title="ES6异步编程的实现"></a>ES6异步编程的实现</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;&#x2F;etc&#x2F;passwd&#39;, function (err, data) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调函数的缺陷：如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为<strong>回调函数噩梦</strong>(callback hell）。</p>
<p>Promise应运而生，它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载。</p>
<h4 id="Promise基础知识"><a href="#Promise基础知识" class="headerlink" title="Promise基础知识"></a>Promise基础知识</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readFile 承诺在未来的某个时刻完成</span></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">&quot;example.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>readFile()</code>不会立即开始读取文件，而是返回一个表示异步读取操作的Promise对象，未来对这个对象的操作取决于Promise的生命周期。</p>
<h5 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h5><ul>
<li>进行中<code>pending</code></li>
<li>成功完成<code>Fulfilled</code></li>
<li>执行错误<code>Rejected</code></li>
</ul>
<p>Promise.then()接收两个参数：第一，状态变为<code>fulfilled</code>时的状态；第二，状态变为<code>rejected</code>时的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise包装的readFile实例</span><br><span class="line">let fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">function readFile(fileName)&#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		fs.readFile(fileName, &#123;encoding: &quot;utf-8&quot;&#125;, function(err, contents) &#123;</span><br><span class="line">			if (err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			resolve(contents);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;应用</span><br><span class="line">let promise &#x3D; readFile(&quot;example.txt&quot;);</span><br><span class="line">promise.then(function(contents) &#123;</span><br><span class="line">	console.log(contents);</span><br><span class="line">&#125;, function(err) &#123;</span><br><span class="line">	console.error(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>); <span class="comment">//g时一个内部指针（即遍历器）</span></span><br><span class="line">g.next(); <span class="comment">//&#123; value: 3, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">//&#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p>
<h5 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h5><blockquote>
<p>Thunk函数是编译器“传名调用”实现方案</p>
</blockquote>
<p><strong>在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的 Thunk 函数转换器</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arguements);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">		args.push(callback);</span><br><span class="line">		<span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure>

<h5 id="Generator-函数的自动流程管理"><a href="#Generator-函数的自动流程管理" class="headerlink" title="Generator 函数的自动流程管理"></a>Generator 函数的自动流程管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function run(fn)&#123;</span><br><span class="line">	var gen &#x3D; fn();</span><br><span class="line">	function next(err, data)&#123;</span><br><span class="line">		var result &#x3D; gen.next(data);</span><br><span class="line">		if(result.done) return;</span><br><span class="line">		result.value(next); &#x2F;&#x2F;递归函数</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="co函数库"><a href="#co函数库" class="headerlink" title="co函数库"></a>co函数库</h4><blockquote>
<p>co函数库是TJ Holowaychuk发布的一个小工具，用于 Generator 函数的自动执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var gen &#x3D; function* ()&#123;</span><br><span class="line">	var f1 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;fstab&#39;);</span><br><span class="line">	var f2 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;shells&#39;);</span><br><span class="line">	console.log(f1.toString);</span><br><span class="line">	console.log(f2.toString);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var co &#x3D; require(&#39;co&#39;);</span><br><span class="line">co(gen); &#x2F;&#x2F;将Generator函数传入co函数，会自动执行</span><br></pre></td></tr></table></figure>

<p>co函数返回一个Promise对象，用then方法添加回调函数。</p>
<h5 id="基于Promise对象的自动执行"><a href="#基于Promise对象的自动执行" class="headerlink" title="基于Promise对象的自动执行"></a>基于Promise对象的自动执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将readFile包装成 Promise 对象</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">		fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(err) reject(data);</span><br><span class="line">			resolve(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">	<span class="built_in">console</span>.loh(f2.toString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动执行</span></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		g.next(data);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//自动执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> g = gen();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> result = g.next(data);</span><br><span class="line">		<span class="keyword">if</span>(result.done) <span class="keyword">return</span>;</span><br><span class="line">		result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">			next(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h5 id="co支持并发的异步操作"><a href="#co支持并发的异步操作" class="headerlink" title="co支持并发的异步操作"></a>co支持并发的异步操作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="keyword">yield</span>[</span><br><span class="line">		<span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">		<span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">	];</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">		<span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">		<span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>

<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<ul>
<li><strong>内置执行器</strong>。Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>更好的语义</strong>。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</p>
</li>
<li><p><strong>更广的适用性</strong>。co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p>
</li>
</ul>
<h5 id="async函数的实现"><a href="#async函数的实现" class="headerlink" title="async函数的实现"></a>async函数的实现</h5><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args)&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">function fn(args)&#123; </span><br><span class="line">  return spawn(function*() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<h3 id="模块系统-CommonJS-vs-ES6"><a href="#模块系统-CommonJS-vs-ES6" class="headerlink" title="模块系统(CommonJS vs ES6)"></a>模块系统(CommonJS vs ES6)</h3><blockquote>
<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
</blockquote>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的<span style="color:red">静态化</span>，使得<span style="color:red">编译时就能确定模块的依赖关系</span>，以及输入和输出的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;CommonJS模块</span><br><span class="line">let &#123;stat, exist, readfile&#125; &#x3D; require(&#39;fs&#39;);</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">let _fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">let stat &#x3D; _fs.stat;</span><br><span class="line">let exist &#x3D; _fs.exists;</span><br><span class="line">let readfile &#x3D; _fs.readfile;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的<strong>所有方法</strong>），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“<strong>运行时加载</strong>”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES6模块</span><br><span class="line">import &#123; stat, exists, readfile &#125; from &#39;fs&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>CommonJS：require语法，运行时加载，<strong>整体加载</strong></li>
<li>ES6：import语法，静态加载，<strong>部分加载</strong></li>
</ul>
<p><strong>CommonJS模块特点</strong>：</p>
<ul>
<li>所有代码运行在当前模块作用域中，不会污染全局作用域</li>
<li>模块同步加载，根据代码顺序加载</li>
<li>模块可以多次加载，只会在第一次加载时运行一次，然后运行结果缓存，后续再加载，在缓存中读取结果，若需要模块再次运行，必须清除缓存</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的例子,demo-exports.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;saucxs&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	name,</span><br><span class="line">	getName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo-require,js</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">require</span>(<span class="string">&#x27;./demo-export&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person, <span class="string">&#x27;-----------&#x27;</span>); 		<span class="comment">//&#123;name: &#x27;saucxs&#x27;, getName: [Function: getName]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name, <span class="string">&#x27;===========&#x27;</span>);	<span class="comment">//saucxs</span></span><br><span class="line">person.getName(<span class="string">&#x27;kiro&#x27;</span>);						<span class="comment">//kiro</span></span><br><span class="line">person.name = <span class="string">&#x27;updateName&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person, <span class="string">&#x27;22222222&#x27;</span>);			<span class="comment">//&#123;name: &#x27;updateName&#x27;, getName: [Function: getName]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><blockquote>
<p>CommonJS规范，每个人文件就是一个模块，每个模块中都有一个module对象，这个对象指向当前模块。</p>
</blockquote>
<p>module对象的属性：</p>
<ul>
<li>id：当前模块id</li>
<li>exports：表示当前模块暴露给外部的值</li>
<li>parent：是一个对象，表示调用当前模块的模块</li>
<li>children：是一个对象，表示当前模块调用的模块</li>
<li>filename：模块的绝对路径</li>
<li>paths：从当前模块开始查找<code>node_modules</code>目录，然后依次进入到父目录，查找父目录下的<code>node_modules</code>目录；依次迭代，直到根目录下的<code>node_modules</code>目录。</li>
<li>loaded：一个布尔值，表示当前模块是否被完全加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	name: <span class="string">&#x27;saucxs&#x27;</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Module = &#123;</span><br><span class="line">    id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">    <span class="built_in">exports</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;saucxs&#x27;</span>, <span class="attr">getName</span>: [<span class="built_in">Function</span>: getName]&#125;,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    filename: <span class="string">&#x27;&#x27;</span>, 	<span class="comment">//省略</span></span><br><span class="line">    loaded: <span class="literal">false</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: []		<span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>module.exports</strong></p>
<p>我们知道了module对象有一个exports属性，该属性用来对外暴露变量，方法或者整个模块。当其他文件需要require该模块的时候，实际上读取的是module对象中的exports属性。</p>
<p><strong>exports对象</strong></p>
<p>对比分析<code>module.exports</code>和<code>exports</code>：</p>
<ul>
<li>exports对象和module.exports都是引用类型变量，指向同一个内存地址，在node中，两者一开始都是指向一个空对象的。<code>exports = module.exports = &#123;&#125;</code></li>
<li>exports对象是通过形参的方式传入，直接赋值给形参的引用，但是并不能改变作用域外的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">	<span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">exports</span>.name = <span class="string">&#x27;kiro&#x27;</span>;	<span class="comment">//会同步到外部的module.exports对象</span></span><br><span class="line">	<span class="built_in">exports</span> = &#123;</span><br><span class="line">		age: <span class="number">18</span></span><br><span class="line">	&#125;;						<span class="comment">//只是修改引用，不会影响到module.exports</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">exports</span>);	<span class="comment">//&#123;age: 18&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">change(<span class="built_in">exports</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports);<span class="comment">//&#123;name: &#x27;kiro&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>module.exports就是为了解决上述exports直接赋值的问题，会导致抛出不成功的问题而产生的。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些操作都是合法的</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;saucxs&#x27;</span>;</span><br><span class="line"><span class="built_in">exports</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;saucxs&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于下面的方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">&#x27;saucxs&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;saucxs&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者更常规的写法</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;saucxs&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;saucxs&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getName: getName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="require方法"><a href="#require方法" class="headerlink" title="require方法"></a>require方法</h4><h5 id="node中引入模块的机制"><a href="#node中引入模块的机制" class="headerlink" title="node中引入模块的机制"></a>node中引入模块的机制</h5><p>引入模块的步骤：（1）路径分析；（2）文件定位；（3）编译执行</p>
<p>模块分为两种：（1）node提供的模块，如http、fs等；（2）用户自己编写的模块，文件模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requireA.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;requireA start loading...&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;requireA end loading...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init.js</span></span><br><span class="line"><span class="keyword">var</span> mod1 = <span class="built_in">require</span>(<span class="string">&#x27;./requireA&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mod2 = <span class="built_in">require</span>(<span class="string">&#x27;./requireB&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod1 === mod2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line">requireA start loading...</span><br><span class="line">requireB end loading...</span><br><span class="line"><span class="literal">true</span> 		<span class="comment">//虽然两次require，但模块中的代码只执行了一遍，且指向同一个exports</span></span><br></pre></td></tr></table></figure>

<p>Node.js 的 require 方法中的文件查找策略如下：</p>
<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/11/CPVZKr7Xkl5FQMn.png" alt="image.png"></p>
<h3 id="常用库学习"><a href="#常用库学习" class="headerlink" title="常用库学习"></a>常用库学习</h3><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><blockquote>
<p>引入：require(‘http’)</p>
</blockquote>
<p>Node.js 中的 HTTP 接口旨在支持该协议的许多传统上难以使用的功能。 特别是大的，可能是块编码的消息。 接口从不缓冲整个请求或响应，因此用户能够流式传输数据。</p>
<p>HTTP请求头如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x27;content-length&#x27;: &#x27;123&#x27;,</span><br><span class="line">  	&#x27;content-type&#x27;: &#x27;text/plain&#x27;,</span><br><span class="line"> 	&#x27;connection&#x27;: &#x27;keep-alive&#x27;,</span><br><span class="line">  	&#x27;host&#x27;: &#x27;mysite.com&#x27;,</span><br><span class="line">  	&#x27;accept&#x27;: &#x27;*/*&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收到的原始标头保留在 <code>rawHeaders</code> 属性中，其是 <code>[key, value, key2, value2, ...]</code> 数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/07/Node-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/Node-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Node.js异步编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-07 16:39:17" itemprop="dateCreated datePublished" datetime="2021-04-07T16:39:17+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 16:02:27" itemprop="dateModified" datetime="2021-06-04T16:02:27+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JS中的事件循环"><a href="#JS中的事件循环" class="headerlink" title="JS中的事件循环"></a>JS中的事件循环</h2><p>当遇到异步事件时，JS引擎会将这个事件挂起，执行栈继续执行，当这个异步事件返回结果后，会将这个事件加入到与当前执行栈不同的一个队列，我们称之为<strong>事件队列</strong>，被放入的事件不会立即执行其回调，而是要<strong>等到当前执行栈中所有的任务都执行完毕</strong>，JS线程处于闲置状态时，主线程才会去查找事件队列是否有任务，如果有，那么JS线程就会从中取出排在第一位的事件，并把这个事件对应的回调放入到执行栈中，然后执行其中的同步代码，如此反复，这样就形成了一个无限的循环，我们称之为事件循环。</p>
<h3 id="队列任务"><a href="#队列任务" class="headerlink" title="队列任务"></a>队列任务</h3><p>队列任务被分为两种：microtask queue<strong>微队列任务</strong>，macrotask queue<strong>宏队列任务</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/29/promise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/promise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">promise源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-29 14:32:28 / 修改时间：15:34:25" itemprop="dateCreated datePublished" datetime="2021-03-29T14:32:28+08:00">2021-03-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.jianshu.com/p/43de678e918a" target="_blank">参考1</a></p>
<p><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank">参考2</a></p>
<h2 id="Promise基本结构"><a href="#Promise基本结构" class="headerlink" title="Promise基本结构"></a>Promise基本结构</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		resolve(<span class="string">&#x27;FULFILLED&#x27;</span>);</span><br><span class="line">	&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先，我们定义一个名为 <code>MyPromise</code> 的 <code>Class</code>，它接受一个函数 <code>handle</code> 作为参数，且定义一个判断一个变量是否为函数的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span> (<span class="params">handle</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise状态和值"><a href="#Promise状态和值" class="headerlink" title="Promise状态和值"></a>Promise状态和值</h2><p>两个属性值：<code>_status </code>、<code>_value</code></p>
<p>三种状态：<code>Pending</code>、<code>Fulfilled</code>、<code>Rejected</code></p>
<blockquote>
<p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或由 <code>Pending</code> 变为 <code>Rejected</code> ，且状态改变之后不会在发生变化，会一直保持这个状态。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上文中<code>handle</code>函数包含 <code>resolve</code> 和 <code>reject</code> 两个参数，它们是两个函数，可以用于<strong>改变 <code>Promise</code> 的状态</strong>和<strong>传入 <code>Promise</code> 的值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;FULFILLED&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，为 <code>MyPromise</code> 添加状态和值，并添加状态改变的执行逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="built_in">this</span>._status = PENDING</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 执行handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>)) </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">this</span>._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">  _resolve (val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>._status = FULFILLED</span><br><span class="line">    <span class="built_in">this</span>._value = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">  _reject (err) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">    <span class="built_in">this</span>._value = err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise的then方法"><a href="#Promise的then方法" class="headerlink" title="Promise的then方法"></a>Promise的then方法</h2><p><code>Promise</code> 对象的 <code>then</code> 方法接受两个参数：</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p>
<ul>
<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 不是函数，其必须被忽略</li>
</ul>
<p>特性：</p>
<ul>
<li>当 <code>promise</code> 状态变为成功时必须被调用，其第一个参数为 <code>promise</code> 成功\失败状态传入的值（ <code>resolve</code> 执行时传入的值）</li>
<li>在 <code>promise</code> 状态改变前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<p><strong>多次调用</strong></p>
<p><code>then</code> 方法必须返回一个<strong>新的 <code>promise</code> 对象</strong>，因此 <code>promise</code> 支持链式调用</p>
<h3 id="Promise的一些执行规则"><a href="#Promise的一些执行规则" class="headerlink" title="Promise的一些执行规则"></a>Promise的一些执行规则</h3><p><strong>如何实现then方法返回一个新的<code>promise</code>对象？</strong></p>
<ul>
<li><p>若 <code>x</code> 不为 <code>Promise</code> ，则使 <code>x</code> 直接作为新返回的 <code>Promise</code> 对象的值， 即新的<code>onFulfilled</code> 或者 <code>onRejected</code> 函数的参数.</p>
</li>
<li><p>若 <code>x</code> 为 <code>Promise</code> ，这时后一个回调函数，就会等待该 <code>Promise</code> 对象(即 <code>x</code> )的状态发生变化，才会被调用，并且新的 <code>Promise</code> 状态和 <code>x</code> 的状态相同。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个普通值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;这里返回一个普通值&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//1秒后打印出：这里返回一个普通值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     resolve(<span class="string">&#x27;这里返回一个Promise&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//3秒后打印出：这里返回一个Promise</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>抛出一个异常 <code>e</code></strong></p>
<p>如果 <code>onFulfilled</code> 或者<code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须变为失败<code>（Rejected）</code>，并返回失败的值 <code>e</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这里抛出一个异常e&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">//1秒后打印出：这里抛出一个异常e</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>如果<code>onFulfilled</code> 不是函数且 <code>promise1</code> 状态为成功<code>（Fulfilled）</code></strong></p>
<p><code>promise2</code> 必须变为成功<code>（Fulfilled）</code>并返回 <code>promise1</code> 成功的值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="string">&#x27;这里的onFulfilled本来是一个函数，但现在不是&#x27;</span>)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 1秒后打印出：success</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 状态为失败<code>（Rejected）</code></strong></p>
<p><code>promise2</code>必须变为失败<code>（Rejected）</code> 并返回 <code>promise1</code> 失败的值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> res, <span class="string">&#x27;这里的onRejected本来是一个函数，但现在不是&#x27;</span>)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)  <span class="comment">// 1秒后打印出：fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>据此，完善<code>then()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line">then (onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">          onFulfilledNext(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res =  onFulfilled(value);</span><br><span class="line">          <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">            res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">            onFulfilledNext(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">        onRejectedNext(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">          onRejectedNext(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">        onRejectedNext(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">      <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">      <span class="keyword">case</span> PENDING:</span><br><span class="line">        <span class="built_in">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class="line">        <span class="built_in">this</span>._rejectedQueues.push(rejected)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        fulfilled(_value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        rejected(_value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整的promise源码"><a href="#完整的promise源码" class="headerlink" title="完整的promise源码"></a>完整的promise源码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  <span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line">  <span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">handle</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加状态</span></span><br><span class="line">      <span class="built_in">this</span>._status = PENDING</span><br><span class="line">      <span class="comment">// 添加状态</span></span><br><span class="line">      <span class="built_in">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">      <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">      <span class="built_in">this</span>._fulfilledQueues = []</span><br><span class="line">      <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">      <span class="built_in">this</span>._rejectedQueues = []</span><br><span class="line">      <span class="comment">// 执行handle</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handle(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>)) </span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">this</span>._reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">    _resolve (val) &#123;</span><br><span class="line">      <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">this</span>._status = FULFILLED</span><br><span class="line">        <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">const</span> runFulfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> cb;</span><br><span class="line">          <span class="keyword">while</span> (cb = <span class="built_in">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class="line">            cb(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">const</span> runRejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> cb;</span><br><span class="line">          <span class="keyword">while</span> (cb = <span class="built_in">this</span>._rejectedQueues.shift()) &#123;</span><br><span class="line">            cb(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span></span><br><span class="line"><span class="comment">          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          val.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = value</span><br><span class="line">            runFulfilled(value)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = err</span><br><span class="line">            runRejected(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>._value = val</span><br><span class="line">          runFulfilled(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(run, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">    _reject (err) &#123; </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">        <span class="built_in">this</span>._value = err</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> (cb = <span class="built_in">this</span>._rejectedQueues.shift()) &#123;</span><br><span class="line">          cb(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(run, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加then方法</span></span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">        <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">              onFulfilledNext(value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> res =  onFulfilled(value);</span><br><span class="line">              <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">                res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">                onFulfilledNext(res)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">            onRejectedNext(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">        <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">              onRejectedNext(error)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">                <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                  <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">                  res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">                  onFulfilledNext(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">            onRejectedNext(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">          <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">          <span class="keyword">case</span> PENDING:</span><br><span class="line">            <span class="built_in">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class="line">            <span class="built_in">this</span>._rejectedQueues.push(rejected)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">          <span class="keyword">case</span> FULFILLED:</span><br><span class="line">            fulfilled(_value)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> REJECTED:</span><br><span class="line">            rejected(_value)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加catch方法</span></span><br><span class="line">    <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">      <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态reject方法</span></span><br><span class="line">    <span class="keyword">static</span> reject (value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve ,reject</span>) =&gt;</span> reject(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态all方法</span></span><br><span class="line">    <span class="keyword">static</span> all (list) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回值的集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">let</span> values = []</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> [i, p] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">          <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">          <span class="built_in">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            values[i] = res</span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态race方法</span></span><br><span class="line">    <span class="keyword">static</span> race (list) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">          <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">          <span class="built_in">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">        value  =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">        reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/Nodejs%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/Nodejs%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Nodejs学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 19:34:23" itemprop="dateCreated datePublished" datetime="2021-03-22T19:34:23+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 10:31:41" itemprop="dateModified" datetime="2021-03-23T10:31:41+08:00">2021-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命令行窗口（cmd-终端-shell）"><a href="#命令行窗口（cmd-终端-shell）" class="headerlink" title="命令行窗口（cmd\终端\shell）"></a>命令行窗口（cmd\终端\shell）</h2><p>常用指令：</p>
<p>dir\cd\md(创建文件夹)\rd(删除文件夹)</p>
<p>环境变量：在任何位置都可以使用指令</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>在Node中，每一个js文件就是一个模块，每一个js文件中的js代码都是独立运行在一个函数中。<strong>所以一个模块中的变量和函数在其他模块中无法访问</strong>。</p>
<p>require语法：</p>
<p>核心模块：由node引擎提供的模块<code>const _ = require(&#39;lodash&#39;)</code>;</p>
<p>文件模块：用户自定义模块：<code>const Err = require(&#39;../utils/err&#39;);</code></p>
<h3 id="模块的深度理解"><a href="#模块的深度理解" class="headerlink" title="模块的深度理解"></a>模块的深度理解</h3><p>在node中有一个全局变量global，作用和网页中的windows类似，在全局中创建的变量、函数都会作为global的属性、方法保存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">global</span>.a); <span class="comment">//undefined=&gt;因此a不是全局变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">[Arguments] &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: [<span class="built_in">Function</span>: <span class="built_in">require</span>] &#123;</span><br><span class="line">    resolve: [<span class="built_in">Function</span>: resolve] &#123; <span class="attr">paths</span>: [<span class="built_in">Function</span>: paths] &#125;,</span><br><span class="line">    main: Module &#123;</span><br><span class="line">      id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试&#x27;</span>,</span><br><span class="line">      <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">      parent: <span class="literal">null</span>,</span><br><span class="line">      filename: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>,</span><br><span class="line">      loaded: <span class="literal">false</span>,</span><br><span class="line">      children: [],</span><br><span class="line">      paths: [<span class="built_in">Array</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">      <span class="string">&#x27;.js&#x27;</span>: [<span class="built_in">Function</span> (anonymous)],</span><br><span class="line">      <span class="string">&#x27;.json&#x27;</span>: [<span class="built_in">Function</span> (anonymous)],</span><br><span class="line">      <span class="string">&#x27;.node&#x27;</span>: [<span class="built_in">Function</span> (anonymous)]</span><br><span class="line">    &#125;,</span><br><span class="line">    cache: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>: [Module]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: Module &#123;</span><br><span class="line">    id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">    path: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试&#x27;</span>,</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    filename: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>,</span><br><span class="line">    loaded: <span class="literal">false</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: [</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\node_modules&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\学习笔记\\node_modules&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\node_modules&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;D:\\node_modules&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示：</p>
<p>在node执行模块中的代码时，它会首先在代码的最顶部，添加如下代码：</p>
<p><code>function (exports, require, module, __filename, __dirname) &#123;</code></p>
<p>在代码的最底部，添加如下代码</p>
<p><code>&#125;</code></p>
<p><strong>模块函数中的参数</strong>：</p>
<ul>
<li>exports：用于将变量或函数暴露到外部</li>
<li>require：函数，引入外部模块</li>
<li>module：代表当前模块本身，则exports就是module的属性</li>
<li>_filename：当前模块的完整文件路径</li>
<li>_dirname：当前模块所在文件夹的完整路径</li>
</ul>
<h3 id="exports和module-exports"><a href="#exports和module-exports" class="headerlink" title="exports和module.exports"></a>exports和module.exports</h3><ul>
<li>exports只能通过.的方式向外暴露内部对象</li>
<li>而module.exports可以通过.的形式，也可以直接赋值</li>
</ul>
<p><code>module.exports.xxx = xxxx</code>或</p>
<p><code>module.exports = &#123;&#125;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ES6学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 15:59:28" itemprop="dateCreated datePublished" datetime="2021-03-20T15:59:28+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 20:12:12" itemprop="dateModified" datetime="2021-03-23T20:12:12+08:00">2021-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-块级作用域绑定"><a href="#1-块级作用域绑定" class="headerlink" title="1 块级作用域绑定"></a>1 块级作用域绑定</h2><p>JavaScript中的作用域：</p>
<p>变量在函数内声明，变量为局部作用域；</p>
<p>变量在函数外定义，即为全局变量。全局变量有 <strong>全局作用域</strong>: 网页中所有脚本和函数均可使用。 </p>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</p>
<h3 id="var声明及变量提升（Hoisting）机制"><a href="#var声明及变量提升（Hoisting）机制" class="headerlink" title="var声明及变量提升（Hoisting）机制"></a>var声明及变量提升（Hoisting）机制</h3><p>在JavaScript中，通过var声明的变量无论在哪里声明，都会被当成当前作用域顶部声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVaule</span>(<span class="params">condition</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">        <span class="comment">//其它代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在预编译阶段，JavaScript引擎会将上面的getValue函数修改成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVaule</span>(<span class="params">condition</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> value;</span><br><span class="line">	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">        <span class="comment">//其它代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ES6引入块级作用域来强化对变量生命周期的控制</strong></p>
<h3 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h3><p>块级声明用于声明在指定块的作用域之外无法访问的变量，存在于：</p>
<ul>
<li>函数内部</li>
<li>块中（字符{和}之间的区域）</li>
</ul>
<h4 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h4><p>let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明后，不会再被提升至函数顶部。执行流离开if块，value立刻销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVaule</span>(<span class="params">condition</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">        <span class="comment">//其它代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//变量value此处不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量value此处不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>禁止重声明</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>; <span class="comment">//抛出语法错误</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">	<span class="keyword">let</span> count = <span class="number">40</span>; <span class="comment">//不会抛出错误，内部块中的count会屏蔽全局作用域中的count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>声明常量，其值一旦被设定不能被更改。类似Java中的static final，也是<strong>块级标识符</strong>，只在当前代码块有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> maxItems; <span class="comment">//错误，没有初始化</span></span><br></pre></td></tr></table></figure>

<p>同java一样，如果const声明的是变量如果是对象，则对象中的值可以修改，绑定不允许修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person&#123;</span><br><span class="line">	name:<span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>; <span class="comment">//可以修改值</span></span><br><span class="line">person=&#123;</span><br><span class="line">	name:<span class="string">&quot;Greg&quot;</span></span><br><span class="line">&#125;;	<span class="comment">//抛出语法错误</span></span><br></pre></td></tr></table></figure>

<h4 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h4><p>与var不同，let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问变量，会触发错误，即使是相对安全的typeof也是。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);  <span class="comment">//引用错误</span></span><br><span class="line">	<span class="keyword">let</span> value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript引擎在扫描代码发现变量时，要么将它们提升至作用域顶部（var），要么将声明放到”临时死区“TDZ中（let，const）</strong>。只有执行过变量声明语句后，变量才会从TDZ中移出，然后才能正常访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//不能访问！</span></span><br></pre></td></tr></table></figure>

<h4 id="循环中的声明"><a href="#循环中的声明" class="headerlink" title="循环中的声明"></a>循环中的声明</h4><p>补充：</p>
<p><strong>Array数组的forEach()函数的用法</strong></p>
<p>语法：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(currentValue, index, arr), thisValue)</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>function(currentValue, index, arr)</em></td>
<td align="left">必需。 数组中每个元素需要调用的函数。 函数参数:参数描述<em>currentValue</em>必需。当前元素<em>index</em>可选。当前元素的索引值。<em>arr</em>可选。当前元素所属的数组对象。</td>
</tr>
<tr>
<td align="left"><em>thisValue</em></td>
<td align="left">可选。传递给函数的值一般用 “this” 值。 如果这个参数为空， “undefined” 会传递给 “this” 值</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	func(); <span class="comment">//输出10次数字10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>循环每次迭代同时共享变量i</strong>，因此循环结束时变量i的值为10，所以输出10次数字10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	func(); <span class="comment">//输出0-9</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>let声明，<strong>每次迭代循环都会创建一个新变量</strong>，并以之前迭代中同名变量的值将其初始化。</p>
<p><strong>循环中的const声明</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	<span class="comment">//完成一次迭代后报错,i++报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">	object = &#123;</span><br><span class="line">		a:<span class="literal">true</span>,</span><br><span class="line">		b:<span class="literal">true</span>,</span><br><span class="line">		c:<span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line">	<span class="comment">//不会报错，每次均创建一个新的绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="全局块作用域绑定"><a href="#全局块作用域绑定" class="headerlink" title="全局块作用域绑定"></a>全局块作用域绑定</h4><p>当var被用于全局对象时，它会创建一个新的全局变量作为全局对象（windows）的属性，这意味着可能会无意中覆盖一个已经存在的全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在浏览器中</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(windows.RegExp); <span class="comment">//”Hello“</span></span><br></pre></td></tr></table></figure>

<p>在全局作用域中使用let或const，会在全局域下创建一个新绑定，但不会添加为全局对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在浏览器中</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(windows.RegExp == <span class="built_in">RegExp</span>); <span class="comment">//false;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-字符串和正则表达式"><a href="#2-字符串和正则表达式" class="headerlink" title="2 字符串和正则表达式"></a>2 字符串和正则表达式</h2><p>没看</p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当传入更少数量的参数时，默认参数值的特性可以有效简化函数声明的代码。</p>
<p><strong>形参默认值</strong></p>
<p><em>ES5中的形参默认值设置方法</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一</span><br><span class="line">function makeRequest(url, timeout, callback)&#123;</span><br><span class="line">	timeout &#x3D; timeout || 2000;</span><br><span class="line">	callback &#x3D; callback || function()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;此时若传入timeout&#x3D;0，仍然赋值2000，不符合要求</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法二：相比方法一更安全，但很繁琐</span><br><span class="line">function makeRequest(url, timeout, callback)&#123;</span><br><span class="line">	timeout &#x3D; (typeof timeout!&#x3D;&#x3D;&quot;undefined&quot;)?timeout:2000;</span><br><span class="line">	callback &#x3D; (typeof callback !&#x3D;&#x3D; &quot;undefined&quot;)?callback:function()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ES6的形参默认值设置方法</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout&#x3D;2000, callback&#x3D;function()&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;此时</span><br><span class="line">makeRequest(&quot;&#x2F;foo&quot;); &#x2F;&#x2F;使用参数timeout和callback的默认值</span><br><span class="line">makeRequest(&quot;&#x2F;foo&quot;，500); &#x2F;&#x2F;使用参数callback的默认值</span><br><span class="line">makeRequest(&quot;&#x2F;foo&quot;，500，function(body)&#123;</span><br><span class="line">	doSomething(body);</span><br><span class="line">&#125;);  &#x2F;&#x2F;不使用默认值</span><br></pre></td></tr></table></figure>

<p><strong>默认参数值对arguement对象的影响</strong></p>
<p><em>ES5</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first,second</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//true</span></span><br><span class="line">	first=<span class="string">&quot;c&quot;</span>;</span><br><span class="line">	second=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在非严格模式下，命名参数的变化会同步更新到arguement对象中。严格模式下不会。</p>
<p><em>ES6</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first,second=”<span class="number">6</span>“</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">//1</span></span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//false</span></span><br><span class="line">	first=<span class="string">&quot;c&quot;</span>;</span><br><span class="line">	second=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//false</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是否显示定义严格模式，arguement的行为都会与命名参数分离。</p>
<p><strong>默认参数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second=getValue()</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>先定义的参数也可以作为后定义的参数的默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second=first</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first+second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>但不允许先定义的参数引用后定义参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first=second, second</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first+second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>,<span class="number">1</span>));   <span class="comment">//抛出错误</span></span><br></pre></td></tr></table></figure>

<p><strong>默认参数的临时死区</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于上一段代码</span></span><br><span class="line"><span class="comment">//调用add(1,1)相当于</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用add(undefined,1)</span></span><br><span class="line"><span class="keyword">let</span> first = second;  <span class="comment">//let不会变量提升，报错</span></span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="处理无命名参数"><a href="#处理无命名参数" class="headerlink" title="处理无命名参数"></a>处理无命名参数</h3><p>处理传入更多数量的参数。</p>
<p><em>ES5中的无命名参数</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>, len=<span class="built_in">arguments</span>.length; i&lt;len; i++)&#123;</span><br><span class="line">		result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> book=&#123;</span><br><span class="line">	title:<span class="string">&quot;Understanding ECMAScript 5&quot;</span>,</span><br><span class="line">	author:<span class="string">&quot;rose&quot;</span>,</span><br><span class="line">	year:<span class="number">1997</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bookData = pick(book,<span class="string">&quot;author&quot;</span>,<span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bookData.author); <span class="comment">//&quot;rose&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.year); <span class="comment">//1997</span></span><br></pre></td></tr></table></figure>

<p><em>ES6中的不定参数</em> 类似jva</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;keys.length; i++)&#123;</span><br><span class="line">		results[keys[i]] = object[keys[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不定参数的加入不会影响函数length属性的值，本例中pick函数的length为1.</p>
</blockquote>
<p>每个函数最多只有一个不定参数，且一定在所有参数的末尾。</p>
<p><strong>不定参数对arguments对象的影响</strong></p>
<p>arguments对象包含所有传入函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(args.length);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">	<span class="built_in">console</span>.log(args[<span class="number">0</span>],<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">console</span>.log(args[<span class="number">1</span>],<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">a a</span><br><span class="line">b b</span><br></pre></td></tr></table></figure>

<p><strong>增强的Function构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;first&quot;</span>,<span class="string">&quot;second&quot;</span>,<span class="string">&quot;return first+second&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p><em>ES6中允许在增强构造函数中加默认值与不定参数</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;first&quot;</span>,<span class="string">&quot;second=first&quot;</span>,<span class="string">&quot;return first+second&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));   <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;...args&quot;</span>,<span class="string">&quot;return args[0]&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>展开运算符</strong></p>
<p>JavaScript内建的Math.max()方法可以接受任意数量的参数并返回值最大的那一个，但只适用于两个值，不允许传入数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5的解决办法</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的解决办法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将展开运算符与其他正常值混合使用</span></span><br><span class="line"><span class="keyword">let</span> values = [-<span class="number">100</span>,-<span class="number">75</span>,-<span class="number">50</span>,-<span class="number">25</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...values,<span class="number">0</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="函数的name属性"><a href="#函数的name属性" class="headerlink" title="函数的name属性"></a>函数的name属性</h3><p>ES6新增了name属性，主要解决问题：<br>JavaScript有多种定义函数的方式，特别是匿名函数表达式的广泛使用更加大了调试的难度，name属性可以更好的辨别函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">//doSomething</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name); <span class="comment">//doAnotherThing</span></span><br></pre></td></tr></table></figure>

<p><strong>ES6也做了许多工作来确保所有函数都有合适的名称</strong>，具体省略。</p>
<h3 id="函数的多重用途"><a href="#函数的多重用途" class="headerlink" title="函数的多重用途"></a>函数的多重用途</h3><p>没看懂</p>
<h3 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h3><p>ES5及以前不支持块级函数的声明，ES5严格模式下引入了一个错误提示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//ES5抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6中会将其视作一个块级声明，从而在定义该函数的代码块内访问和调用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//&quot;function&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//块级函数会被提升至顶部</span></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">doSomething(); <span class="comment">//undefined，if外不存在</span></span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//抛出错误</span></span><br><span class="line">	<span class="keyword">let</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//块级函数会被提升至顶部</span></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">doSomething(); <span class="comment">//undefined，if外不存在</span></span><br></pre></td></tr></table></figure>

<p><strong>非严格模式下的块级函数</strong></p>
<p>ES6非严格模式下，不在被提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//&quot;function&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//&quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6引入的一种全新的方式来声明函数</p>
<p><strong>箭头函数与传统的JavaScript函数有些许不同</strong>：</p>
<ul>
<li>没有this\super\arguments\new.target绑定，箭头函数的这些值由外围最近一层非箭头函数决定；</li>
<li>不能通过new关键字调用，没有[[Construct]]方法；</li>
<li>没有原型;</li>
<li>不可以改变this的绑定；</li>
<li>不支持arguments对象</li>
<li>不支持重复的命名参数</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个参数</span></span><br><span class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">let</span> reflet = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入两个及以上的参数</span></span><br><span class="line"><span class="keyword">let</span> reflect  = <span class="function">(<span class="params">num1,num2</span>)=&gt;</span>num1+num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有传入参数</span></span><br><span class="line"><span class="keyword">let</span> getName = <span class="function">()=&gt;</span><span class="string">&quot;rose&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由多个表达式组成的更传统的函数体，用&#123;&#125;包围</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1,num2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空函数</span></span><br><span class="line"><span class="keyword">let</span> doNothing = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象字面量</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;<span class="attr">id</span>:id,<span class="attr">name</span>:<span class="string">&quot;Temp&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>创建立即执行函数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">//rose</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将箭头函数包裹在小括号内即可</span></span><br><span class="line"><span class="keyword">let</span> person = (<span class="function">(<span class="params">name</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName); <span class="comment">//rose</span></span><br></pre></td></tr></table></figure>

<p><strong>箭头函数没有this绑定</strong></p>
<p><em>ES5</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PageHandler = &#123;</span><br><span class="line">	id:<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.doSomething(event.type);<span class="comment">//抛出错误</span></span><br><span class="line">		&#125;,<span class="literal">false</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	doSomething:<span class="function"><span class="title">fuction</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span>+type+<span class="string">&quot; for &quot;</span>+<span class="built_in">this</span>.id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中的this为方法对象，因此此时this为document对象而不PageHandler</p>
<p><em>ES5中的解决办法</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.doSomething(event.type);<span class="comment">//抛出错误</span></span><br><span class="line">		&#125;).bind(<span class="built_in">this</span>) ,<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><em>ES6中用箭头解决办法</em></p>
<p>箭头函数被非箭头函数包含，this绑定的时最近一层非箭头函数的this，否则，this值为undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,</span><br><span class="line">			event=&gt;<span class="built_in">this</span>.doSomething(event.type),<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript中箭头函数的初衷时“即用即弃”，因此不能new。</p>
<p><strong>箭头数字非常适用于数组处理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数没有arguments绑定</strong></p>
<p>箭头函数没有自己的arguments对象，且始终可以访问外围函数的arguments对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">()=&gt;</span><span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction()); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doSomethingElse(); <span class="comment">//尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES5引擎中，尾调的实现与其他函数调用的实现类似：创建一个新=帧，将其堆入调用栈来表示函数调用。即，在循环调用中，每一个未用完的帧都被保存在内存里，当调用栈过大会造成程序问题。</p>
<p><strong>ES6中的尾调优化</strong>：缩减了严格模式下尾调用栈的大小（非严格模式下不受影响），若满足以下条件，尾调不再创建新帧，而是清除并重用当前栈帧：</p>
<ul>
<li>尾调不访问当前栈帧的变量</li>
<li>在函数内部，时最后一条语句</li>
<li>尾调用的结果作为函数返回值</li>
</ul>
<p><strong>如何利用尾调优化</strong></p>
<p>常用于递归函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n*factotial(n-<span class="number">1</span>); <span class="comment">//尾调无法优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾调优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n,p=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>*p;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> result = n*p;</span><br><span class="line">		<span class="keyword">return</span> factorial(n-<span class="number">1</span>,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果递归函数量足够大，则尾调递归优化可以大幅提升程序的性能</strong></p>
<h2 id="4-扩展对象的功能性"><a href="#4-扩展对象的功能性" class="headerlink" title="4 扩展对象的功能性"></a>4 扩展对象的功能性</h2><h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><ul>
<li>普通对象：具有JavaScript对象所有的默认内部行为</li>
<li>特异对象：具有某些与默认行为不符的内部行为</li>
<li>标准对象：ES6规范中定义的对象，如Array，Date等，既可以是普通对象，也可以是特异对象</li>
<li>内建对象：脚本开始执行时存在于JavaScript执行环境中的对象，所有标准对象都是内建对象。</li>
</ul>
<h4 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h4><p><strong>属性的简洁表示法</strong></p>
<p>当一个对象的属性与本地变量同名时，不必再写冒号和值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当对象字面量只有一个属性名称时，引擎会在可访问的作用域查找其同名变量并赋值。</p>
</blockquote>
<p><strong>对象方法的简写</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHi();  <span class="comment">//&quot;Hi&quot;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHi();<span class="comment">//&quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>可计算属性名</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5访问对象属性的一种方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;,</span><br><span class="line">	lastName = <span class="string">&quot;last name&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;first name&quot;</span>]=<span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person[lastName] = <span class="string">&quot;Zakas&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6中，可在对象字面量中使用可计算属性名称</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&quot;last name&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="string">&quot;first name&quot;</span>:<span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	[lastName]:<span class="string">&quot;Zakas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或是</span></span><br><span class="line"><span class="keyword">let</span> suffix = <span class="string">&quot; name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	[<span class="string">&quot;first&quot;</span>+suffix]:<span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	[<span class="string">&quot;last&quot;</span>+suffix]=<span class="string">&quot;Zakas&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许用表达式作为属性名</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h4><p><strong>Object.is()</strong></p>
<p>作用：弥补全等运算符的不足</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一是+0不等于-0</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,-<span class="number">0</span>);  <span class="comment">//false</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//二是NaN等于本身</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>); <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.assign()</strong></p>
<p>作用：将源对象的所有可枚举属性复制到目标对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="number">3</span>);         <span class="comment">// Number &#123;3&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">3</span>);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>);       <span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>);  <span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line">当参数不止一个时，<span class="literal">null</span> 和 <span class="literal">undefined</span> 不放第一个，即不为目标对象时，会跳过 <span class="literal">null</span> 和 <span class="literal">undefined</span> ，不报错</span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="number">1</span>,<span class="literal">undefined</span>);  <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,<span class="literal">null</span>);  <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>,&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);  <span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure>

<p><strong>此拷贝为浅拷贝</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sourceObj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> targetObj = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, sourceObj);</span><br><span class="line">targetObj.a.b = <span class="number">2</span>;</span><br><span class="line">sourceObj.a.b;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的处理</span></span><br><span class="line"><span class="built_in">Object</span>.assign([<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>]);  <span class="comment">// [5,3]</span></span><br></pre></td></tr></table></figure>

<h4 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h4><p><em>ES5严格模式下，对象中不允许出现同名属性</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	name : <span class="string">&quot;Greg&quot;</span>  <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ES6移除检查，直接取最后一个取值</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	name : <span class="string">&quot;Greg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>

<h4 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h4><p>ES5中未定义对象属性的枚举顺序。ES6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到<code>Object.getOwnPropertyNames()</code>方法以及<code>Reflect.ownKeys()</code>，<code>Object.assign()</code>方法处理属性的顺序也将随之改变。</p>
<p>自有属性枚举顺序的基本规则：</p>
<ul>
<li>所有数字键按升序</li>
<li>所有字符键按被加入对象的顺序</li>
<li>所有symnol键按照它们被加入对象的顺序</li>
</ul>
<h2 id="5-解构"><a href="#5-解构" class="headerlink" title="5 解构"></a>5 解构</h2><h2 id="6-JavaScript中的类"><a href="#6-JavaScript中的类" class="headerlink" title="6 JavaScript中的类"></a>6 JavaScript中的类</h2><p><strong>类的基本语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5中构造类对象方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.brand = brand;</span><br><span class="line">	<span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Phone.propotype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> huawei = <span class="keyword">new</span> Phone(<span class="string">&quot;huawei&quot;</span>,<span class="number">5999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(huawei);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.brand = brand;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//必须写以下语法</span></span><br><span class="line">	<span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> onePlus = <span class="keyword">new</span> Phone(<span class="string">&quot;1+&quot;</span>,<span class="number">4999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(onePlus);</span><br></pre></td></tr></table></figure>

<p><strong>类的静态属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> name = <span class="string">&#x27;手机&#x27;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cosole.log(<span class="string">&quot;我可以改变世界&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nokia = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(nokia.name);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Phone.name);<span class="comment">//&#x27;手机&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>类的继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.brand = brand;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">brand,price,color,size</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(brand,price);</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">		<span class="built_in">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get和set方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="keyword">get</span> <span class="title">price</span>()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;价格属性被读取了&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;iloveyou&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">price</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;价格属性被修改了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(s.price); <span class="comment">//价格属性被读取了   price=iloveyou</span></span><br><span class="line">s.price = <span class="string">&#x27;free&#x27;</span>;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/JavaScript%E5%A4%8D%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/JavaScript%E5%A4%8D%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">JavaScript复习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 15:38:30" itemprop="dateCreated datePublished" datetime="2021-03-19T15:38:30+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 21:13:47" itemprop="dateModified" datetime="2021-03-26T21:13:47+08:00">2021-03-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.runoob.com/js/js-output.html" target="_blank">参考</a></p>
<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><p>JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p>
<p>主要作用：</p>
<ul>
<li>直接写入HTML输出流</li>
<li>对事件进行反应</li>
<li>改变HTML内容、图像、样式</li>
<li>验证输入</li>
</ul>
<h2 id="JavaScript用法"><a href="#JavaScript用法" class="headerlink" title="JavaScript用法"></a>JavaScript用法</h2><p>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。</p>
<ul>
<li>脚本可被放置在 HTML 页面的 <body> 和 <head> 部分中。</li>
<li>外部文件，请在 <script> 标签的 "src" 属性中设置该 .js 文件</li>
</ul>
<h2 id="JavaScript输出"><a href="#JavaScript输出" class="headerlink" title="JavaScript输出"></a>JavaScript输出</h2><ul>
<li>使用 <strong>window.alert()</strong> 弹出警告框。</li>
<li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li>
<li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li>
<li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li>
</ul>
<h2 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h2><p><strong>JavaScript字面量</strong></p>
<p>Number(3.14、1001、123e05)、表达式、数组([40,100,1,15,20])、对象({firstName:”John”,lastName:”Doe”, age:50, eyeColor:”blue”})、函数(function myFunction(a, b) { return a * b;})</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 JavaScript 中有 6 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<p><strong>创建数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">cars[<span class="number">0</span>]=<span class="string">&quot;Saab&quot;</span>;</span><br><span class="line">cars[<span class="number">1</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">cars[<span class="number">2</span>]=<span class="string">&quot;BMW&quot;</span>; <span class="comment">//方式一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);<span class="comment">//方式二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cars=[<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>]; <span class="comment">//方式三</span></span><br></pre></td></tr></table></figure>

<p><strong>创建对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">firstname</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastname</span>:<span class="string">&quot;Doe&quot;</span>, <span class="attr">id</span>:<span class="number">5566</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">firstname : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">lastname  : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">id        :  <span class="number">5566</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//两种寻址方式</span></span><br><span class="line">name=person.lastname;</span><br><span class="line">name=person[<span class="string">&quot;lastname&quot;</span>];</span><br><span class="line"><span class="comment">//对象方法</span></span><br><span class="line">methodName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象方法调用</span></span><br><span class="line">objectName.methodName()</span><br><span class="line"></span><br><span class="line">objectName.methodName  <span class="comment">//返回方法定义的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>调用带参数的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;点击这个按钮，来调用带参数的函数。&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;myFunction(&#x27;Harry Potter&#x27;,&#x27;Wizard&#x27;)&quot;</span>&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">name,job</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Welcome &quot;</span> + name + <span class="string">&quot;, the &quot;</span> + job);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>带返回值的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=myFunction(<span class="number">4</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>局部变量与全局变量</strong></p>
<p>局部变量：在 JavaScript 函数内部声明的变量（使用 var）是<em>局部</em>变量，所以只能在函数内部访问它；</p>
<p>全局变量：在函数外声明的变量是<em>全局</em>变量，网页上的<strong>所有脚本和函数</strong>都能访问它。</p>
<p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>HTML 事件可以是浏览器行为，也可以是用户行为。</p>
<p>以下是 HTML 事件的实例：</p>
<ul>
<li>HTML 页面完成加载</li>
<li>HTML input 字段改变时</li>
<li>HTML 按钮被点击</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;getElementById(&#x27;demo&#x27;).innerHTML=Date()&quot;</span>&gt;现在的时间是?&lt;/button&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;点击按钮执行 &lt;em&gt;displayDate()&lt;<span class="regexp">/em&gt; 函数.&lt;/</span>p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;displayDate()&quot;</span>&gt;点这里&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayDate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>常见的HTML事件</strong></p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">浏览器已完成页面的加载</td>
</tr>
</tbody></table>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以是插入到引号中的任何字符。你可以使用单引号或双引号，可以使用索引位置来访问字符串中的每个字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carname = <span class="string">&quot;Volvo XC60&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> carname = <span class="string">&#x27;Volvo XC60&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> character = carname[<span class="number">7</span>]; <span class="comment">//索引从0开始</span></span><br></pre></td></tr></table></figure>

<p>你可以在字符串中使用引号，字符串中的引号不要与字符串的引号相同:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="string">&quot;It&#x27;s alright&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">&quot;He is called &#x27;Johnny&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">&#x27;He is called &quot;Johnny&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用内置属性 <strong>length</strong> 来计算字符串的长度：<code>var x = txt.length</code></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>基本与Java相同</p>
<p><strong>对于字符串和数字进行加法运算</strong>：两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串，如下实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span>+<span class="number">5</span>; <span class="comment">//x=10</span></span><br><span class="line">y=<span class="string">&quot;5&quot;</span>+<span class="number">5</span>; <span class="comment">//y=55</span></span><br><span class="line">z=<span class="string">&quot;Hello&quot;</span>+<span class="number">5</span>; z=Hello5</span><br></pre></td></tr></table></figure>

<p><strong>比较运算</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">===</td>
<td align="left">绝对等于（值和类型均相等）</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">!==</td>
<td align="left">不绝对等于（值和类型有一个不相等，或两个都不相等）</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于或等于</td>
</tr>
</tbody></table>
<p><strong>逻辑运算</strong></p>
<table>
<thead>
<tr>
<th align="left">算符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">and</td>
<td align="left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">or</td>
<td align="left">(x==5 || y==5) 为 false</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">not</td>
<td align="left">!(x==y) 为 true</td>
</tr>
</tbody></table>
<p><strong>条件运算</strong></p>
<p><code>variablename = (condition) ? value1 : value2 </code></p>
<h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><p>基本与Java相同</p>
<p><strong>for/in循环</strong>类似于foreach</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> person)  <span class="comment">// x 为属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeof-null和undefined"><a href="#typeof-null和undefined" class="headerlink" title="typeof,null和undefined"></a>typeof,null和undefined</h3><p><strong>typeof</strong>：检测变量的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;John&quot;</span>                <span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>                  <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>                 <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]             <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125; <span class="comment">// 返回 object</span></span><br></pre></td></tr></table></figure>

<p><strong>null</strong></p>
<p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p>
<p><strong>undefined</strong></p>
<p>在 JavaScript 中, <strong>undefined</strong> 是一个没有设置值的变量。</p>
<p><strong>undefined和null的区别</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//null 和 undefined 的值相等，但类型不等</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>             <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                  <span class="comment">// object</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h4 id="数字转为字符串"><a href="#数字转为字符串" class="headerlink" title="数字转为字符串"></a>数字转为字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>)       <span class="comment">// 将数字 123 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">100</span> + <span class="number">23</span>)  <span class="comment">// 将数字表达式转换为字符串并返回</span></span><br></pre></td></tr></table></figure>

<p>Number 方法 <strong>toString()</strong> 也是有同样的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.toString()</span><br><span class="line">(<span class="number">123</span>).toString()</span><br><span class="line">(<span class="number">100</span> + <span class="number">23</span>).toString()</span><br></pre></td></tr></table></figure>

<p>更多数字转换为字符串的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">toExponential()</td>
<td align="left">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="left">toFixed()</td>
<td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。</td>
</tr>
<tr>
<td align="left">toPrecision()</td>
<td align="left">把数字格式化为指定的长度。</td>
</tr>
</tbody></table>
<h4 id="将布尔值转换为字符串"><a href="#将布尔值转换为字符串" class="headerlink" title="将布尔值转换为字符串"></a>将布尔值转换为字符串</h4><p>同上。</p>
<h4 id="将日期转为字符串"><a href="#将日期转为字符串" class="headerlink" title="将日期转为字符串"></a>将日期转为字符串</h4><p>同上。</p>
<p>更多关于日期转换为字符串的函数：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getDate()</td>
<td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">getDay()</td>
<td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left">getFullYear()</td>
<td align="left">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">getMilliseconds()</td>
<td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getMonth()</td>
<td align="left">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getTime()</td>
<td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<h4 id="字符串转为数字"><a href="#字符串转为数字" class="headerlink" title="字符串转为数字"></a>字符串转为数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;3.14&quot;</span>)    <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot; &quot;</span>)       <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;99 88&quot;</span>)   <span class="comment">// 返回 NaN</span></span><br></pre></td></tr></table></figure>

<p>更多关于字符串转为数字的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">parseFloat()</td>
<td align="left">解析一个字符串，并返回一个浮点数。</td>
</tr>
<tr>
<td align="left">parseInt()</td>
<td align="left">解析一个字符串，并返回一个整数。</td>
</tr>
</tbody></table>
<p>…</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;正则表达式主体&#x2F;修饰符(可选)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>主要方法</strong></p>
<p>正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p><strong>search() 方法</strong> 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并<strong>返回子串的起始位置</strong>。</p>
<p><strong>replace() 方法</strong> 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Visit Runoob!&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> n = str.search(<span class="regexp">/Runoob/i</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;myFunction()&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;Visit Microsoft!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML; </span><br><span class="line">    <span class="keyword">var</span> txt = str.replace(<span class="regexp">/microsoft/i</span>,<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = txt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修饰符</strong> 可以在全局搜索中不区分大小写:</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">执行多行匹配。</td>
</tr>
</tbody></table>
<p><strong>使用RegExp对象</strong></p>
<p>RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p>
<p><em>test()方法</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/e/</span>;</span><br><span class="line">patt.test(<span class="string">&quot;The best things in life are free!&quot;</span>);</span><br><span class="line">/e/.test(<span class="string">&quot;The best things in life are free!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><em>exec()方法</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/e/.exec(<span class="string">&quot;The best things in life are free!&quot;</span>); <span class="comment">//e</span></span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>try\catch\finally、throw</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;demo&quot;</span> type=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;myFunction()&quot;</span>&gt;测试输入&lt;/button&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;message&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message, x;</span><br><span class="line">    message = <span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    message.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    x = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).value;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&quot;&quot;</span>)  <span class="keyword">throw</span> <span class="string">&quot;值为空&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">&quot;不是数字&quot;</span>;</span><br><span class="line">        x = <span class="built_in">Number</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">5</span>)    <span class="keyword">throw</span> <span class="string">&quot;太小&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">10</span>)   <span class="keyword">throw</span> <span class="string">&quot;太大&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        message.innerHTML = <span class="string">&quot;错误: &quot;</span> + err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。**”hoisting(变量提升)”**</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span>; <span class="comment">// 变量 x 设置为 5</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x;                     <span class="comment">// 在元素中显示 x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x; <span class="comment">// 声明 x</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 初始化不会提升</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x + <span class="string">&quot; &quot;</span> + y;           <span class="comment">// 显示 x 和 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br></pre></td></tr></table></figure>

<p>实例 2 的 y 输出了 <strong>undefined</strong>，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。</p>
<p><strong>严格模式</strong></p>
<p><code>&quot;use strict&quot; </code>，即在严格的条件下运行，不允许使用未声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">x = &#123;<span class="attr">p1</span>:<span class="number">10</span>, <span class="attr">p2</span>:<span class="number">20</span>&#125;;      <span class="comment">// 不允许使用未声明的变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">delete</span> x;                <span class="comment">// 不允许删除变量或对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p2</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> x;                <span class="comment">// 不允许删除函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p1</span>) </span>&#123;&#125;;   <span class="comment">// 不允许变量重名</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">010</span>;             <span class="comment">// 不允许使用八进制</span></span><br></pre></td></tr></table></figure>

<p>…</p>
<p><strong>在 JavaScript 中，分号是可选的 分号是可选的,在缺少了分号就无法正确解析代码的时候，JavaScript 才会填补分号，也可以使用多行来结束一个语句。</strong></p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h2 id="JavaScript的异步编程"><a href="#JavaScript的异步编程" class="headerlink" title="JavaScript的异步编程"></a>JavaScript的异步编程</h2><p><a href="https://www.runoob.com/js/js-async.html" target="_blank">参考</a></p>
<h3 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h3><p>avascript语言的执行环境是”单线程”（single thread）。</p>
<p>所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任。</p>
<p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<p>为了解决这个问题，JavaScript 中的异步操作函数往往通过<strong>回调函数来实现异步任务的结果处理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function print() &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;RUNOOB!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(print, 3000);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&quot;./a.txt&quot;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a.txt data is : &quot;</span> + data);</span><br><span class="line">    fs.readFile(<span class="string">&quot;./b.txt&quot;</span>,<span class="function">(<span class="params">err1,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err1) <span class="keyword">throw</span> err1;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;b.txt data is : &quot;</span> + data);</span><br><span class="line">        fs.readFile(<span class="string">&quot;./c.txt&quot;</span>,<span class="function">(<span class="params">err2,data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err2) <span class="keyword">throw</span> err2;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;b.txt data is : &quot;</span> + data);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">test1</span><br><span class="line">a.txt data is : 我是a.txt</span><br><span class="line">test2</span><br><span class="line">b.txt data is : 我是b.txt</span><br><span class="line">test3</span><br><span class="line">b.txt data is : 我是c.txt</span><br><span class="line">test4</span><br></pre></td></tr></table></figure>



<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line"></span><br><span class="line">　　　　　　f1.trigger(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line"></span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line">　　f1.on(<span class="string">&#x27;done&#x27;</span>,f2);</span><br></pre></td></tr></table></figure>

<p><code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发done事件，从而开始执行f2。</p>
<h3 id="Promises对象"><a href="#Promises对象" class="headerlink" title="Promises对象"></a>Promises对象</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。</p>
<p><strong>Promise就是为了解决回调问题而提出来的，它可以把函数嵌套，改为链式调用</strong></p>
<p>假定读取A文件之后，再读取B文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, function (err, data) &#123;</span><br><span class="line">  fs.readFile(fileB, function (err, data) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName,<span class="string">&quot;utf-8&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">readFile(<span class="string">&quot;./a.txt&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="string">&quot;./b.txt&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="string">&quot;./c.txt&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>第一步，协程A开始执行。</p>
<p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p>
<p>第三步，（一段时间后）协程B交还执行权。</p>
<p>第四步，协程A恢复执行。</p>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/iterator">遍历器</a> ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。</p>
<p>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<p><strong>Generator函数的数据交换和错误处理</strong></p>
<p>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello_wolrd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;over...&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = hello_wolrd();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> hw); <span class="comment">//object</span></span><br><span class="line"><span class="keyword">let</span> hello = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line"><span class="keyword">let</span> world = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(world);</span><br><span class="line"><span class="keyword">let</span> over = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(over);</span><br><span class="line"><span class="keyword">let</span> done = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(done);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">object</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125; </span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">&#x27;world&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125; </span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">&#x27;over...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thunk函数的自动执行"><a href="#Thunk函数的自动执行" class="headerlink" title="Thunk函数的自动执行"></a>Thunk函数的自动执行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="function">(<span class="params">fileName</span>)=&gt;</span>(<span class="function">(<span class="params">callback</span>)=&gt;</span>fs.readFile(fileName,callback));</span><br><span class="line"><span class="keyword">var</span> fileA = readFileThunk(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">fileA(<span class="function">(<span class="params">err,data</span>)=&gt;</span><span class="built_in">console</span>.log(data+<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> readFileGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> AResult = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(AResult+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> BResult = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;./b.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(BResult+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> CResult = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;./c.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(CResult+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span>(result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(readFileGenerator);</span><br></pre></td></tr></table></figure>

<h3 id="Promise回调"><a href="#Promise回调" class="headerlink" title="Promise回调"></a>Promise回调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">return</span> reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFileGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&quot;./b.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f2+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> f3 = <span class="keyword">yield</span> readFile(<span class="string">&quot;./c.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f3+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> g = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">        <span class="keyword">if</span>(result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(readFileGenerator);</span><br></pre></td></tr></table></figure>

<h3 id="await和async"><a href="#await和async" class="headerlink" title="await和async"></a>await和async</h3><p>最后但是也是最重要执行异步调用的方式就是最新的async和await关键字，它们其实是Generator生成器的语法优化，区别在于：</p>
<ul>
<li>使用await和async返回的函数可以<strong>自动执行</strong></li>
<li>使用async替换原来的*，await替换原来的yield</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/18/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 22:23:54" itemprop="dateCreated datePublished" datetime="2021-03-18T22:23:54+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-19 15:30:57" itemprop="dateModified" datetime="2021-03-19T15:30:57+08:00">2021-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.runoob.com/git/git-workflow.html" target="_blank">参考</a></p>
<h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p>Git 是一个开源的<strong>分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目，是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的<strong>版本控制软件</strong>。</p>
<h2 id="Git流程"><a href="#Git流程" class="headerlink" title="Git流程"></a>Git流程</h2><p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p>下图展示了 Git 的工作流程：</p>
<p><img src="https://i.loli.net/2021/03/18/Qr1oIHlTiSg6fzB.png" alt="image.png"></p>
<h2 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h2><ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<p><img src="https://i.loli.net/2021/03/18/T13NPufdt9IxLUJ.png" alt="image.png"></p>
<h2 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h2><h3 id="方法一：创建本地仓库"><a href="#方法一：创建本地仓库" class="headerlink" title="方法一：创建本地仓库"></a>方法一：创建本地仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git init newrepo &#x2F;&#x2F;使用我们指定目录作为Git仓库</span><br></pre></td></tr></table></figure>

<p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录（<strong>隐藏目录</strong>），该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<h3 id="方法二：远程克隆"><a href="#方法二：远程克隆" class="headerlink" title="方法二：远程克隆"></a>方法二：远程克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br><span class="line">$ git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git</span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt; &#x2F;&#x2F;克隆到指定的目录</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --list  &#x2F;&#x2F;显示当前的git配置信息</span><br><span class="line">&#x2F;&#x2F;编辑git配置文件</span><br><span class="line">git config --e     #针对当前仓库</span><br><span class="line">git config --e --global  #针对系统上所有仓库</span><br><span class="line">&#x2F;&#x2F;设置提交代码时的用户信息</span><br><span class="line">$ git config --global user.name &quot;runoob&quot;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br><span class="line">&#x2F;&#x2F;去掉 --global 参数只对当前仓库有效。</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p><strong>签名的设置</strong>：</p>
<blockquote>
<p>用户名：xxx</p>
<p>邮箱：<a href="mailto:&#x78;&#120;&#120;&#64;&#x78;&#x78;&#x78;&#46;&#99;&#x6f;&#x6d;">&#x78;&#120;&#120;&#64;&#x78;&#x78;&#x78;&#46;&#99;&#x6f;&#x6d;</a></p>
</blockquote>
<p>作用：区分不同开发人员的身份</p>
<p>辨析：这里设置的签名和登录远程库的账号、密码没有任何关系</p>
<p>命令：</p>
<ul>
<li>项目级别\仓库级别：仅在当前本地库范围内有效，在<code>.git/config</code>目录下，命令为<code>git config user.name kiro</code></li>
<li>系统用户级别：登录当前操作系统的用户范围，在<code>C:Users/kiro/.gitconfig</code>，命令为<code>git config --global user.name kiro</code></li>
</ul>
<p><strong>优先级</strong>：就近原则</p>
<h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p><img src="https://i.loli.net/2021/03/18/GJsNAHwt2fqLcIn.png" alt="image.png"></p>
<p>创建仓库命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git init</code></td>
<td align="left">初始化仓库</td>
</tr>
<tr>
<td align="left"><code>git clone</code></td>
<td align="left">拷贝一份远程仓库，也就是下载一个项目。</td>
</tr>
</tbody></table>
<p>提交与修改：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git add </code></td>
<td align="left">添加文件到仓库</td>
</tr>
<tr>
<td align="left"><code>git status</code></td>
<td align="left">查看仓库当前的状态（工作区、暂存区），显示有变更的文件。</td>
</tr>
<tr>
<td align="left"><code>git diff</code>（不加文件名表示比较所有文件的不同）</td>
<td align="left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td align="left"><code>git diff [本地库中历史版本][文件名]</code></td>
<td align="left">比较与某版本的文件的不同</td>
</tr>
<tr>
<td align="left"><code>git commit -m &quot;commit message&quot; [file name]</code></td>
<td align="left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td align="left"><code>git reset</code></td>
<td align="left">回退版本。</td>
</tr>
<tr>
<td align="left"><code>git rm</code></td>
<td align="left">删除工作区文件。</td>
</tr>
<tr>
<td align="left"><code>git mv</code></td>
<td align="left">移动或重命名工作区文件。</td>
</tr>
</tbody></table>
<p>日志：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code>`git log –pretty=oneline<code>\</code>git log –oneline<code>（只显示过去）\</code>git reflog`（过去未来均显示）</td>
<td align="left">查看历史提交记录</td>
</tr>
<tr>
<td align="left"><code>git reset --hard [index]</code></td>
<td align="left">根据索引值前进后退</td>
</tr>
<tr>
<td align="left"><code>git reset --hard Head^^</code>`git reset –hard HEAD~2`</td>
<td align="left">有几个^就后退几步，只能后退</td>
</tr>
<tr>
<td align="left"><code>git blame &lt;file&gt;</code></td>
<td align="left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody></table>
<p>多屏显示控制方式：</p>
<p>空格向下翻页、b向上翻页、q退出</p>
<p><strong>reset命令的三个参数对比</strong></p>
<ul>
<li><p>–soft参数</p>
<ul>
<li>仅仅在本地库移动HEAD指针</li>
</ul>
</li>
<li><p>–mixed参数</p>
<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
</ul>
</li>
<li><p>–hard</p>
<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
<li>重置工作区</li>
</ul>
</li>
</ul>
<p>远程操作：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote</code></td>
<td align="left">远程仓库操作</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">从远程获取代码库</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">下载远程代码并合并</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">上传远程代码并合并</td>
</tr>
</tbody></table>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p><strong>什么是分支？</strong></p>
<p>在版本控制过程中，使用多条线同时推进多个任务。</p>
<p><strong>分支的好处</strong></p>
<ul>
<li>同时并行推进多个功能开发，提高开发效率</li>
<li>各个分支在开发过程中，若某个分支开发失败，对其他分支不产生影响</li>
</ul>
<p><strong>Git分支的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>git branch -v</code></td>
<td>查看当前分支状态</td>
</tr>
<tr>
<td><code>git branch [分支名]</code></td>
<td>常见分支</td>
</tr>
<tr>
<td><code>git branch checkout [分支名]</code></td>
<td>切换分支</td>
</tr>
<tr>
<td><code>git merge [分支名]</code></td>
<td>合并分支（<strong>需切换到被合并的分支上</strong>）</td>
</tr>
<tr>
<td><code>git branch -d [分支名]</code></td>
<td>删除分支</td>
</tr>
</tbody></table>
<h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p><img src="https://i.loli.net/2021/03/19/pPZdXRhBcvj4KI7.png" alt="image.png"></p>
<p><strong>冲突解决过程</strong>：</p>
<ul>
<li>第一步：编辑文件，删除特殊符号</li>
<li>第二步：把文件修改到满意的程度，保存退出</li>
<li>第三步：<code>git add [文件名]</code>,<code>git commit -m &quot;修改信息&quot;</code>（不能带文件名）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Java并发编程（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-15 16:08:28 / 修改时间：18:47:51" itemprop="dateCreated datePublished" datetime="2021-03-15T16:08:28+08:00">2021-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>进程与线程</strong></p>
<p><em>进程</em>：视为程序的一个实例，进程是资源分配的最小单元，一个进程对应一块独立的内存、资源。</p>
<p><em>线程</em>：一个进程中可以有多个线程，最小调度单元。</p>
<p><em>对比</em>：</p>
<ul>
<li>进程相互独立，线程存在于进程中，是进程的一个子集；</li>
<li>进程是资源分配的最小单元，同一个进程内的线程资源共享；</li>
<li>进程间通信复杂（IPC、HTTP），线程通信相对简单，因为内存共享；</li>
<li>线程更轻量，其上下文切换成本一般比进程低。</li>
</ul>
<p><strong>并行与并发</strong></p>
<p><em>并发</em>：同一时间应对多件事件的能力，单核CPU在任务调度器的管理下使线程轮流使用CPU，实现“微观串行，宏观并行”的效果。</p>
<p><em>并行</em>：同一时间动手做多件事情的能力，多核CPU同时调度运行线程。</p>
<p><strong>线程的优势</strong></p>
<ul>
<li>发挥多核处理器的强大能力；</li>
<li>建模简单，每个线程只执行一种任务，不需要考虑不同任务的管理与切换；</li>
<li>异步事件的简化处理</li>
<li>友好的用户体验</li>
</ul>
<p><strong>线程的风险</strong></p>
<ul>
<li>安全问题：由于多线程共享存储空间，并发运行时，某线程可能会访问或修改其他线程正在使用的变量；</li>
<li>活跃性问题：死锁、饥饿等</li>
<li>性能问题</li>
</ul>
<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="线程的创建和运行"><a href="#线程的创建和运行" class="headerlink" title="线程的创建和运行"></a>线程的创建和运行</h2><p><strong>方法一：继承Thread</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p><strong>方法二：实现Runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精简版： Runnable runnable = ()-&gt;log.debug(&quot;hello&quot;);</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p><strong>方法三：FutureTask配合Thread</strong></p>
<p>FutureTask 能够接收 Callable 类型的参数，用来处理有<strong>返回值</strong>的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Thread(task3,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">Integer result = task.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,result);</span><br></pre></td></tr></table></figure>

<h2 id="线程运行的原理"><a href="#线程运行的原理" class="headerlink" title="线程运行的原理"></a>线程运行的原理</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">计算机网络基本知识整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-07 18:53:00" itemprop="dateCreated datePublished" datetime="2021-03-07T18:53:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-11 20:39:46" itemprop="dateModified" datetime="2021-03-11T20:39:46+08:00">2021-03-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md" target="_blank">参考1</a></p>
<p><a href="https://www.bilibili.com/video/BV1c4411d7jb" target="_blank">参考2</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>网络</strong>是由若干<strong>结点</strong>（电脑、交换机）和连接这些结点的<strong>链路</strong>组成的；</li>
<li>多个网络可以通过路由器来互联，就构成了一个更大的网络——互联网</li>
<li>因特网是世界上最大的互连网络。</li>
</ul>
<h3 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h3><ol>
<li><p>电路交换</p>
<p>电路交换用于电话通信系统。两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
</li>
<li><p>分组交换</p>
<p>每个分组都有<strong>首部和尾部</strong>，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
</li>
</ol>
<h2 id="OSI与TCP-IP各层的结构、功能、协议？"><a href="#OSI与TCP-IP各层的结构、功能、协议？" class="headerlink" title="OSI与TCP/IP各层的结构、功能、协议？"></a>OSI与TCP/IP各层的结构、功能、协议？</h2><p><img src="https://i.loli.net/2021/03/07/5npwPXiqv68ojy4.png" alt="image.png"></p>
<p>OSI理论模型：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层；</p>
<p>TCP/IP协议体系：应用层、运输层、网络层、网络接口层；</p>
<p>常用五层体系：应用层、运输层、网络层、数据链路层、物理层。</p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>计算机网络是一个非常复杂的系统，分层可以将庞大的问题转化为若干较小的问题。</p>
<p><strong>物理层</strong>：解决使用何种信号来传输比特的问题</p>
<p><strong>链路层</strong>：解决分组在一个网络（或一段链路）上的传输问题（主机标识Mac地址、比特信号分解——地址和数据、交换机）</p>
<p><strong>网络层</strong>：解决分组在多个网络上传输（路由）的问题（网络及网络中的各主机标识IP、路由器转发分组及路由选择）</p>
<p><strong>运输层</strong>：进程之间基于网络通讯的问题（进程之间进行基于网络的通信问题、传输错误的处理）</p>
<p><strong>应用层</strong>：通过应用进程间的交互来完成特定网络应用的问题（交互的格式）</p>
<p><img src="https://i.loli.net/2021/03/09/ZzKbNy7T9lkMvqn.png" alt="IOS.jpg"></p>
<hr>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>重点：</p>
<p><strong>考虑如何在连接各计算机的传输媒体上传输数据比特流</strong></p>
<p><strong>物理层为数据链路层屏蔽了各种传输媒体的差异</strong>，使数据链路层只需要考虑如何完成本层的协议和服务，而忽略具体的传输媒体是什么。</p>
<p>传输媒介：光纤、电力线、微波、红外等</p>
<p>传输方式：串行传输和并行传输、同步传输和异步传输、单向通讯、双向交替通讯和双向同时通信。</p>
<p><strong>主要设备</strong>：集线器HUB、中继器</p>
<hr>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>主要作用：帧头帧尾包含重要的控制信息（目的地址、源地址），帧定界。</p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>指数据链路层对上层交付的传输数据没有任何限制，好像链路层不存在一样。（由于链路层需要将上层交付的数据封装成帧，如何准确判断帧头帧尾就是实现透明传输的关键问题）<strong>转义字符</strong></p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><ul>
<li>奇偶校验：在待发送数据后添加1位奇偶校验码。此时若奇数个位发生错误可以检查出误码；</li>
<li>循环冗余校验CRC：约定好一个多项式，基于数据与多项式计算出差错检测码，将其添加到带传输数据末尾；<strong>广泛应用</strong></li>
</ul>
<h4 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h4><p><strong>停止-等待协议</strong></p>
<p>确认ACK与否认NAK、超时重发、分组序号</p>
<p><img src="https://i.loli.net/2021/03/08/OQXBRAfLDcWTV4x.png" alt="image.png"></p>
<p>停止等待协议的通道利用率低。</p>
<p><strong>回退帧协议</strong>（一种ARQ连续协议）</p>
<table>
<thead>
<tr>
<th>发送方</th>
<th>接收方</th>
</tr>
</thead>
<tbody><tr>
<td>发送窗口尺寸范围：1~2^n-1，n位构成分组序号的比特数量</td>
<td>接收窗口尺寸为1，只能<strong>按序</strong>接收数据分组</td>
</tr>
<tr>
<td>发送方可以在未收到确认信号的情况下，将在发送窗口的多个分组全部发送</td>
<td>只接受序号落在接收窗口内且无误码的数据分组</td>
</tr>
<tr>
<td>只有在收到确认信号后，窗口才能滑动</td>
<td>可以在连续收到好几个按序到达且无误码的数据分组后，才对最后一个数据分组发送确认分组，即累积确认</td>
</tr>
<tr>
<td>收到多个重复确认时，可在计时器超时前提前重传</td>
<td>或者在自己有数据分组要发送时才进行捎带确认</td>
</tr>
<tr>
<td>发送窗口内某个已发送数据分组超时重发时，其后续在发送窗口内且已发送的分组也必须重传</td>
<td>收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据进行确认</td>
</tr>
</tbody></table>
<p><strong>当通信线路质量不好时，其通道利用率并不比停止-等待协议高</strong></p>
<p><strong>选择重传</strong></p>
<p>与回退N帧协议的区别：</p>
<ul>
<li>发送窗口尺寸范围为1~2^(n-1)，接收窗口尺寸与发送窗口相同；</li>
<li>不能进行累积确认，必须逐一确认</li>
<li>只有按序收到已发送分组的确认时窗口才能滑动，否则是对未按序到达的分组进行记录，防止超时重发。</li>
</ul>
<p><strong>PPP协议</strong></p>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<p><strong>CSMA/CD协议</strong></p>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p><strong>MAC地址</strong></p>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<h4 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h4><table>
<thead>
<tr>
<th>集线器HUB</th>
<th>交换机SWITCH</th>
</tr>
</thead>
<tbody><tr>
<td>早期的以太网的互联设备</td>
<td>目前以太网使用最广泛的互联设备</td>
</tr>
<tr>
<td>工作在物理层，没有容错检测等功能</td>
<td>工作在数据链路层</td>
</tr>
<tr>
<td>对接收到的信号进行放大、转发</td>
<td>根据MAC地址对帧进行转发，且可以根据MAC地址过滤帧，即隔离碰撞</td>
</tr>
<tr>
<td>使用集线器作为互连设备仍属于共享总线式以太网，所有主机属于同一个碰撞域和广播域</td>
<td>交换机的每个接口是一个独立的碰撞域</td>
</tr>
</tbody></table>
<h4 id="局域网、以太网、虚拟局域网"><a href="#局域网、以太网、虚拟局域网" class="headerlink" title="局域网、以太网、虚拟局域网"></a>局域网、以太网、虚拟局域网</h4><p><strong>局域网</strong></p>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。<strong>一个广播域</strong></p>
<p><strong>以太网</strong></p>
<p>以太网是一种星型拓扑结构局域网。早期用集线器连接，现广泛使用<strong>用交换机连接</strong>。</p>
<p><strong>虚拟局域网VLAN</strong></p>
<p>巨大的广播域会导致许多弊端：广播风暴、难以管理和维护、潜在的安全问题 ==&gt; 利用802.1Q帧格式建立虚拟局域网：将局域网内的设备划分成与物理位置无关的逻辑组的技术。</p>
<hr>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>主要任务：实现网络互联，进而实现数据包在各网络之间的传输。</p>
<p>主要解决以下问题：</p>
<ul>
<li>网络层向运输层提供什么服务？可靠传输还是不可靠传输</li>
<li>网络层寻址问题</li>
<li>网络层路由选择问题</li>
</ul>
<h4 id="地址解析ARP"><a href="#地址解析ARP" class="headerlink" title="地址解析ARP"></a>地址解析ARP</h4><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<p>ARP工作原理：</p>
<ul>
<li>每个主机都有一个 ARP <strong>高速缓存</strong>，里面有<strong>本局域网</strong>上的各主机和路由器的 IP 地址到 MAC 地址的<strong>映射表</strong>。</li>
<li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过<strong>广播</strong>的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li>
</ul>
<h4 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h4><p><strong>主机发送IP数据报</strong></p>
<p>判断目的主机是否与自己在同一个网络（目的地址与子网掩码相与）：</p>
<ul>
<li>若在同一个网络，直接交付，通过交换机；</li>
<li>若不在同一个网络，间接交付，传输给主机所在的默认网关，由默认网关帮忙转发</li>
</ul>
<p><strong>路由器转发IP数据报</strong></p>
<ul>
<li>检查IP数据报首部是否出错，出错则丢弃并通告源主机，否则转发</li>
<li>检查IP数据报的目的地址，在路由器中查找匹配的条目</li>
</ul>
<h4 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h4><ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<hr>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。</p>
<p>运输层的主要协议：</p>
<ul>
<li>传输控制协议TCP（Transmission Control Protocol）–<strong>面向连接、可靠的数据传输</strong></li>
<li>用户数据协议UDP（User Datagram Protocol）–<strong>提供无连接的，尽最大努力的数据传输服务，不保证数据传输的可靠性</strong> </li>
</ul>
<h4 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h4><p>三次握手：</p>
<img src="https://i.loli.net/2021/03/07/TlzeNp6kCQK59At.png" alt="image.png" style="zoom:67%;" />

<p>第一次握手：服务器确定对方发送正常、自己接受正常；</p>
<p>第二次握手：客户端确定自己发送、接收正常，对方发送接收正常；服务器确定对方发送正常、自己接收正常；</p>
<p>第三次握手：客户端确定自己发送、接收正常，对方发送、接收正常；服务器确定自己发送、接收正常，对方发送、接收正常。</p>
<p><strong>第2次握手传回了ACK，为什么还要传回SYN？</strong></p>
<p>ACK标识只表明服务端接收到了请求信号，通信是正常的，并不能完全保证数据传输可以实现完整可靠传输，传回第一次握手的SYN可以由客户端确认数据传输可靠。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="https://i.loli.net/2021/03/07/eVmJrkl56F3Txi9.png" alt="image.png" style="zoom: 67%;" />

<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p><strong>四次可以确保数据传输完成、完整</strong></p>
<h4 id="TCP和UDP协议的区别"><a href="#TCP和UDP协议的区别" class="headerlink" title="TCP和UDP协议的区别"></a>TCP和UDP协议的区别</h4><p><img src="https://i.loli.net/2021/03/07/g8aeL9yrc1l5phz.png" alt="image.png"></p>
<h4 id="TCP如何保证传输的可靠性？"><a href="#TCP如何保证传输的可靠性？" class="headerlink" title="TCP如何保证传输的可靠性？"></a>TCP如何保证传输的可靠性？</h4><ol>
<li>应用数据会被分割成TCP认为最合适发送的数据块；</li>
<li>TCP会给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传给应用层。</li>
<li><strong>校验和</strong>：</li>
</ol>
<hr>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是<strong>应用进程</strong>（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<h4 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h4><p>它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p><strong>请求报文结构</strong></p>
<ul>
<li>请求行，包含请求方法、URL、协议版本；</li>
<li>请求头，每个首部都有一个首部名称，以及对应的值；</li>
<li>空行</li>
<li>数据包，请求内容的主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.example.com&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br></pre></td></tr></table></figure>

<p><strong>响应报文结构</strong></p>
<ul>
<li>协议版本、状态码及描述；</li>
<li>首部内容；</li>
<li>空行；</li>
<li>数据包，响应内容主体。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age&#x3D;604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc&#x2F;16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;&#x2F;title&gt;</span><br><span class="line">	&#x2F;&#x2F; 省略... </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>HTTP方法</strong></p>
<p>GET、HEAD（和 GET 方法类似，但是不返回报文实体主体部分）、POST、PUT（上传文件）、PATCH（对资源进行部分修改）、DELETE（删除文件）、OPTIONS（查询指定URL支持的方法）、CONNECT（要求在与代理服务器通信时建立隧道）、TRACE。</p>
<p><strong>HTTP状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息性状态码</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kiro-xu"
      src="/images/avater.jpg">
  <p class="site-author-name" itemprop="name">kiro-xu</p>
  <div class="site-description" itemprop="description">Be who you want to be</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-2 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kiro-xu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
