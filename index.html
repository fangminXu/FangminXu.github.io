<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be who you want to be">
<meta property="og:type" content="website">
<meta property="og:title" content="kiro的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="kiro的博客">
<meta property="og:description" content="Be who you want to be">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="kiro-xu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>kiro的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kiro的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">消息队列学习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-16 17:28:56 / 修改时间：22:28:00" itemprop="dateCreated datePublished" datetime="2021-09-16T17:28:56+08:00">2021-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><blockquote>
<p>存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/61434a0b2ab3f51d919d0903.jpg" alt="队列模型"></p>
<p>队列模型：一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者， 但是消费者之间是竞争关系，即每条消息只能被一个消费者消费。</p>
<p><img src="https://pic.imgdb.cn/item/61434a502ab3f51d919d9497.jpg" alt="发布订阅模型"></p>
<p>发布订阅模型：<strong>解决一条消息能被多个消费者消费的问题</strong></p>
<h3 id="消息队列的使用场景或好处"><a href="#消息队列的使用场景或好处" class="headerlink" title="消息队列的使用场景或好处"></a>消息队列的使用场景或好处</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p><strong>通过异步处理提高系统性能，减少响应所需时间</strong></p>
<p><img src="https://pic.imgdb.cn/item/61433c5e2ab3f51d9182dbfd.jpg" alt="举例-单条链路过长"></p>
<p>复杂业务下，请求链路过长，进而使得响应时间过长。=&gt; <strong>异步</strong></p>
<p><img src="https://pic.imgdb.cn/item/61433d092ab3f51d91840ea4.jpg" alt="异步处理"></p>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p><strong>异步，为什么不用线程？而用消息队列？</strong> =&gt; <strong>解耦</strong></p>
<ul>
<li>业务耦合度过高：一个流程过多接口，每次修改还需要重新发布系统</li>
<li>维护、排查成本高</li>
</ul>
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。</p>
<h4 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰/限流"></a>削峰/限流</h4><p>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</p>
<h3 id="消息队列的问题"><a href="#消息队列的问题" class="headerlink" title="消息队列的问题"></a>消息队列的问题</h3><ul>
<li>系统复杂度提高： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题</li>
<li>系统可用性降低：消息队列中间件挂了怎么办？</li>
<li>一致性问题：我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h3 id="常见消息队列的对比"><a href="#常见消息队列的对比" class="headerlink" title="常见消息队列的对比"></a>常见消息队列的对比</h3><table>
<thead>
<tr>
<th>对比方向</th>
<th>概要</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody></table>
<h3 id="消息队列问题的解决"><a href="#消息队列问题的解决" class="headerlink" title="消息队列问题的解决"></a>消息队列问题的解决</h3><h4 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h4><p>前提：一般消息队列的使用，我们都是有<strong>重试机制</strong>的，当下游的业务发生异常了，会抛出异常并且要求重新发一次。</p>
<p>如图，当某一模块的消息处理失败，要求重试，但其他模块处理成功，消息队列会再次发送消息，产生重复消费问题。（由于网络抖动、开发人员bug、数据问题等造成处理失败要求重发）。</p>
<p>解决方法：<strong>接口幂等</strong>，同一个请求无论发送多少遍，结果都相同。</p>
<p><img src="https://pic.imgdb.cn/item/6143436f2ab3f51d91902289.jpg" alt="幂等的实现思想"></p>
<p>具体的实现方式：<strong>强校验</strong>和<strong>弱校验</strong>。分场景考虑。</p>
<p>强校验：<strong>流水表</strong>。在执行实际业务逻辑前，调用验证接口，查流水表中是否已经处理过。并用事务包裹。</p>
<p>弱校验：把这个id+场景唯一标识作为<strong>Redis</strong>的key，放到缓存里面失效时间看你场景，<strong>一定时间内</strong>的这个消息就去Redis判断。</p>
<h4 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h4><p>一般都是<strong>同个业务场景下不同几个操作的消息同时过去</strong>，本身顺序是对的，但是你发出去的时候同时发出去了，消费的时候却乱掉了，这样就有问题了。</p>
<p><img src="https://pic.imgdb.cn/item/614345162ab3f51d9192a5b9.jpg" alt="消息顺序问题"></p>
<p>解决方案：</p>
<p>以RocketMQ为例，<strong>一个topic下有多个队列</strong>，为了保证发送有序，</p>
<p>可使用<strong>Hash取模法</strong>，让同一个订单发送到<strong>同一个队列</strong>中，再使用<strong>同步</strong>发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。</p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><blockquote>
<p>一个流程可能涉及到不同服务器的处理，基于分布式事务保证不同服务均成功、或均失败</p>
</blockquote>
<p><strong>两阶段提交</strong></p>
<p><img src="https://pic.imgdb.cn/item/614346d62ab3f51d91958d54.jpg" alt="两阶段提交"></p>
<p>通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。</p>
<p><strong>但是</strong>：如果A系统事务提交成功了，但是B系统在提交的时候网络波动或者各种原因提交失败了，其实还是会失败的。</p>
<p><strong>最终一致性</strong></p>
<p><img src="https://pic.imgdb.cn/item/614348cf2ab3f51d919a5a18.jpg" alt="最终一致性"></p>
<p><strong>消息队列持久化</strong></p>
<p>整个流程中，我们能保证是：</p>
<ul>
<li>业务主动方本地事务提交失败，业务被动方不会收到消息的投递。</li>
<li>只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息（消费成功或失败，即最终一定会有一个最终态）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/16/dubbo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/16/dubbo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">dubbo学习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-16 15:30:14 / 修改时间：16:59:08" itemprop="dateCreated datePublished" datetime="2021-09-16T15:30:14+08:00">2021-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关于RPC：</p>
<ul>
<li><p>服务消费者：</p>
</li>
<li><ul>
<li>消费者<strong>面向接口</strong>编程，通过<strong>代理类</strong>实现远程调用。</li>
<li>通过<strong>注册中心</strong>获得服务提供方信息</li>
</ul>
</li>
<li><ul>
<li>基于<strong>负载均衡</strong>策略协调服务调用</li>
<li>针对网络不可靠问题的<strong>容错机制</strong></li>
</ul>
</li>
<li><ul>
<li>通信协议、序列化与反序列化</li>
<li>Filter，作统一的处理，如调用计数等。</li>
</ul>
</li>
<li><p>服务提供者：</p>
</li>
<li><ul>
<li>对应接口的实现类</li>
<li>注册中心注册服务</li>
</ul>
</li>
<li><ul>
<li>通信协议、序列化与反序列化</li>
<li>线程池处理请求</li>
</ul>
</li>
<li><p>注册中心：平台，可作配置中心，将配置集中化处理</p>
</li>
</ul>
<p>关于Dubbo：</p>
<blockquote>
<p>阿里巴巴2011年开源的基于Java的RPC框架，实现了面向接口的代理RPC调用，可以配合ZooKeeper等组件实现服务注册和发现功能，且具有负载均衡、容错机制。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/6142f3262ab3f51d9111ccbf.jpg" alt="Dubbo架构图"></p>
<p><strong>源码解析基于Dubbo2.6.5版本</strong></p>
<h3 id="Dubbo配置与解析"><a href="#Dubbo配置与解析" class="headerlink" title="Dubbo配置与解析"></a>Dubbo配置与解析</h3><p><img src="https://pic.imgdb.cn/item/6143031c2ab3f51d912872fb.jpg" alt="Dubbo原理架构图"></p>
<ul>
<li><code>config</code> 配置层：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><code>proxy</code> 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code></li>
<li><code>registry</code>注册中心层：封装服务地址的注册与发现，以服务 <strong>URL</strong> 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></li>
<li><code>cluster</code> 路由层：<strong>封装多个提供者的路由及负载均衡</strong>，并桥接注册中心，以 Invoker 为中心，扩展接口为 <code>Cluster, Directory, Router, LoadBalance</code></li>
<li><code>monitor</code> 监控层：RPC <strong>调用次数和调用时间监控</strong>，以 Statistics 为中心，扩展接口为 <code>MonitorFactory, Monitor, MonitorService</code></li>
<li><code>protocol</code> 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li><code>exchange</code> 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 <code>Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</code></li>
<li><code>transport</code> 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 <code>Channel, Transporter, Client, Server, Codec</code></li>
<li><code>serialize</code> 数据序列化层：可复用的一些工具，扩展接口为 <code>Serialization, ObjectInput, ObjectOutput, ThreadPool</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/28/redis%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/28/redis%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">redis学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-28 19:59:29" itemprop="dateCreated datePublished" datetime="2021-06-28T19:59:29+08:00">2021-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-30 13:50:47" itemprop="dateModified" datetime="2021-06-30T13:50:47+08:00">2021-06-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="NoSQL前言"><a href="#NoSQL前言" class="headerlink" title="NoSQL前言"></a>NoSQL前言</h3><blockquote>
<p>NoSQL泛指非关系型数据库</p>
</blockquote>
<p>架构设计演变：</p>
<ul>
<li>单机MySQL：访问量不大，用单个数据库完成。APP =&gt;  DAL(数据访问层)  =&gt; MySQL Instance</li>
<li>Memcached(缓存) + MySQL + 垂直拆分</li>
<li>MySQL主从读写分离：由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。</li>
<li>分表分库+水平拆分+mysql集群</li>
<li>Today</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/60dabad95132923bf8d2eb89.jpg"><img src="https://pic.imgdb.cn/item/60dabad95132923bf8d2eb89.jpg"></a></p>
<h4 id="商品信息的存储方案"><a href="#商品信息的存储方案" class="headerlink" title="商品信息的存储方案"></a>商品信息的存储方案</h4><ul>
<li>商品基本信息：包括名称、价格、出厂日期、生产厂商等<ul>
<li>特点：改动不大</li>
<li>使用：关系型数据库MySQL</li>
</ul>
</li>
<li>商品描述、详情、评价信息（多文字类）<ul>
<li>特点：多文字，IO读写性能差</li>
<li>使用：文档数据库MongDB</li>
</ul>
</li>
<li>商品图片<ul>
<li>分布式的文件系统</li>
</ul>
</li>
<li>商品的关键字<ul>
<li>搜索引擎ISearch</li>
</ul>
</li>
<li>商品的波段性的热点高频信息（如，情人节的巧克力）<ul>
<li>内存数据库Redis</li>
</ul>
</li>
<li>商品的交易、价格计算、积分累计<ul>
<li>外部系统，外部第三方支付接口</li>
</ul>
</li>
</ul>
<h3 id="对redis的简单概述"><a href="#对redis的简单概述" class="headerlink" title="对redis的简单概述"></a>对redis的简单概述</h3><p><code>Redis</code>是一个用C语言开发的数据库。不同于传统数据库，<code>Redis</code><strong>存储在内存</strong>中，即<strong>内存数据库</strong>，读写非常快。</p>
<p>常被用于做<strong>缓存</strong>、<strong>分布式锁</strong>、<strong>消息队列</strong>等。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>主要流程</strong></p>
<p><img src="https://seikim.com/i/2021/06/28/x7t744.png"></p>
<p><strong>为什么要用缓存？</strong></p>
<ul>
<li><strong>高性能</strong>：那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</li>
<li><strong>高并发</strong>：一般像 MySQL 这类的数据库的 QPS（服务器每秒可以执行的查询次数） 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</li>
</ul>
<h3 id="Redis-常见数据结构以及使用场景分析"><a href="#Redis-常见数据结构以及使用场景分析" class="headerlink" title="Redis 常见数据结构以及使用场景分析"></a>Redis 常见数据结构以及使用场景分析</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>简单的 key-value 类型。</p>
<p>常用命令：<code>set,get,strlen,exists,decr,incr,setex</code></p>
<p>应用场景：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;基础方法</span><br><span class="line">127.0.0.1:6379&gt; set key value #设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key # 根据 key 获得对应的 value</span><br><span class="line">&quot;value&quot;</span><br><span class="line">127.0.0.1:6379&gt; exists key  # 判断某个 key 是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key # 返回 key 所储存的字符串值的长度。</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; del key # 删除某个 key 对应的值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;批量设置</span><br><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 # 批量设置 key-value 类型的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 # 批量获取多个 key 对应的 value</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计数器应用</span><br><span class="line">127.0.0.1:6379&gt; set number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number # 将 key 中储存的数字值增一</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr number # 将 key 中储存的数字值减一</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过期相关，默认永不过期</span><br><span class="line">127.0.0.1:6379&gt; expire key  60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>链表，Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>常用命令：<code>rpush,lpop,lpush,rpop,lrange,llen</code></p>
<p>应用场景：发布与订阅或者说消息队列、慢查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;简单使用</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value1 # 向 list 的头部（右边）添加元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 # 向list的头部（最右边）添加多个元素</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList # 将 list的尾部(最左边)元素取出</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end</span><br><span class="line">1) &quot;value2&quot;</span><br><span class="line">2) &quot;value3&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一</span><br><span class="line">1) &quot;value2&quot;</span><br><span class="line">2) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>
<p>通过 <code>llen</code> 查看链表长度：<code>llen mylist</code></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<p>常用命令：<code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code></p>
<p>应用场景：系统中对象的存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset userInfoKey name &quot;guide&quot; description &quot;dev&quot; age &quot;24&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name # 获取存储在哈希表中指定字段的值。</span><br><span class="line">&quot;guide&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line">&quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;guide&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;dev&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey # 获取 key 列表</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;description&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey # 获取 value 列表</span><br><span class="line">1) &quot;guide&quot;</span><br><span class="line">2) &quot;dev&quot;</span><br><span class="line">3) &quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name &quot;GuideGeGe&quot; # 修改某个字段对应的值</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line">&quot;GuideGeGe&quot;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序</p>
<p>常用命令：<code>sadd,spop,smembers,sismember,scard,sinterstone,sunion</code></p>
<p>应用场景：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard mySet # 查看 set 的长度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</p>
<p>常用命令：<code>zadd,zcard,zscore,zrange,zrevrange,zrem</code></p>
<p>应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 # 一次添加多个元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 # 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。</p>
<p>常用命令：<code>setbit,getbit,bitcount,bitop</code></p>
<p>应用场景：适合需要保存状态信息（比如是否签到、是否登录…）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 7 0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit mykey 7</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit mykey 8 1</span><br><span class="line">(integer) 0</span><br><span class="line"># 通过 bitcount 统计被被设置为 1 的位的数量。</span><br><span class="line">127.0.0.1:6379&gt; bitcount mykey</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h3 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h3><p>基于Reactor模式来设计开发了一套高效的事件处理模型——文件事件处理器。</p>
<p>Redis通过<strong>IO多路复用程序</strong>来监听来自客户端的大量连接。</p>
<p>对IO多路复用的简单理解，基于阻塞IO的优化，可以同时监控多个Conversation。</p>
<blockquote>
<p>文件事件处理器：使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器</p>
</blockquote>
<h4 id="Redis6-0之前为什么不使用多线程？"><a href="#Redis6-0之前为什么不使用多线程？" class="headerlink" title="Redis6.0之前为什么不使用多线程？"></a>Redis6.0之前为什么不使用多线程？</h4><ul>
<li>单线程编程简单且更容易维护</li>
<li>Redis的性能瓶颈不在CPU，主要在内存和网络</li>
<li>多线程会存在死锁、上下文切换等问题，甚至影响性能</li>
</ul>
<h4 id="Redis6-0之后为什么引入了多线程？"><a href="#Redis6-0之后为什么引入了多线程？" class="headerlink" title="Redis6.0之后为什么引入了多线程？"></a>Redis6.0之后为什么引入了多线程？</h4><p>主要是为了提高Redis的网络IO读写性能。</p>
<h3 id="Redis给缓存数据设置过期事件"><a href="#Redis给缓存数据设置过期事件" class="headerlink" title="Redis给缓存数据设置过期事件"></a>Redis给缓存数据设置过期事件</h3><h4 id="为什么要过期？"><a href="#为什么要过期？" class="headerlink" title="为什么要过期？"></a>为什么要过期？</h4><blockquote>
<p>内存有限或业务需求（token），Redis自带了给缓存数据设置过期时间的功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exp key 60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>

<h4 id="如何判断过期？"><a href="#如何判断过期？" class="headerlink" title="如何判断过期？"></a>如何判断过期？</h4><p>通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/60dae8295132923bf8ec0f9c.jpg"><img src="https://pic.imgdb.cn/item/60dae8295132923bf8ec0f9c.jpg"></a></p>
<h4 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h4><ul>
<li><strong>惰性删除</strong>：取出key时对数据进行过期检查。对CPU友好，但内存损耗较多</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ul>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>进一步解决方案：<strong>淘汰机制</strong></p>
<h4 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h4><blockquote>
<p> 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>六种淘汰机制：</p>
<ul>
<li><code>volatile-lru(least recently used)</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>最近最少</strong>使用的数据淘汰</li>
<li><code>volatile-ttl</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><code>volatile-random</code>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><code>allkeys-random</code>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><code>no-eviction</code>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ul>
<p>4.0版本后新增：</p>
<ul>
<li><code>volatile-lfu(least frequently used)</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><code>allkeys-lfu</code>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h3 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<ul>
<li><strong>快照</strong>：<code>snapshotting</code>，RDB</li>
<li><strong>只追加文件</strong>：<code>append-only file</code>，AOF</li>
</ul>
<p><strong>快照</strong></p>
<blockquote>
<p>创建副本，默认的持久化方式</p>
</blockquote>
<p>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<p><strong>AOF</strong></p>
<blockquote>
<p>AOF 持久化的实时性更好，因此已成为主流的持久化方案</p>
</blockquote>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a target="_blank" rel="noopener" href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令将执行所有命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）。</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a target="_blank" rel="noopener" href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>
<p>需要注意的是，<strong>Redis不支持<code>rollback</code>、<code>Durability</code>，因而不满足原子性和持久性</strong></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p>
</blockquote>
<p>举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>参数校验，排除不合法的参数请求</li>
<li>缓存无效key并设置过期时间，解决请求key变化不频繁的情况</li>
<li>布隆过滤器，把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。<strong>空间换时间</strong><ul>
<li>布隆过滤器说某个元素存在，小概率会误判。<strong>不同的字符串可能哈希出来的位置相同</strong></li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/16/NodeJs%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/16/NodeJs%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" class="post-title-link" itemprop="url">NodeJs学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-16 11:23:06 / 修改时间：11:25:28" itemprop="dateCreated datePublished" datetime="2021-06-16T11:23:06+08:00">2021-06-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><blockquote>
<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎</p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-module-system.htmlhttps://www.runoob.com/nodejs/nodejs-module-system.html">菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Liu_yunzhao/article/details/90734257?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1328740.38110.16169863950293667&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control">事件循环</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">同步与异步、阻塞与非阻塞的理解</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/05/async.html">js的异步编程</a></p>
<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module">模块机制1</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019856995?utm_source=tag-newest">模块机制2</a></p>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><blockquote>
<p>NPM是随同NodeJS一起安装的包管理工具</p>
</blockquote>
<h4 id="使用npm命令安装模块"><a href="#使用npm命令安装模块" class="headerlink" title="使用npm命令安装模块"></a>使用npm命令安装模块</h4><p>npm安装node.js模块语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 <strong>require(‘express’)</strong> 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let express &#x3D; require(&#39;express&#39;);</span><br></pre></td></tr></table></figure>

<p>npm 的包安装分为本地安装（local）、全局安装（global）两种，<code>-g</code>用于区分。</p>
<h4 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a>查看安装信息</h4><p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list -g</span><br></pre></td></tr></table></figure>

<p>查看某个模块的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list grunt</span><br></pre></td></tr></table></figure>

<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>每个模块都有自己的package.json，用于定义包的属性。属性说明：</p>
<ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字</li>
</ul>
<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm ls</span><br></pre></td></tr></table></figure>

<h4 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h4><p>使用以下来搜索模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h3><p>Node.js异步编程的直接体现就是回调。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>对比示例：</p>
<p>创建一个文件input.txt，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的博客地址：www.kiroxu.top</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞式</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;input.txt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行结束&quot;</span>)</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line">我的博客地址：www.kiroxu.top</span><br><span class="line">程序执行结束</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非阻塞式</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;input.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">	<span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行结束&quot;</span>)</span><br><span class="line"><span class="comment">//代码结果</span></span><br><span class="line">程序执行结束</span><br><span class="line">我的博客地址：www.kiroxu.top</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h3><blockquote>
<p>Node.js采用事件驱动+异步I/O的方式，实现了一个单线程、高并发的JavaScript运行时环境。</p>
</blockquote>
<h4 id="高并发策略"><a href="#高并发策略" class="headerlink" title="高并发策略"></a>高并发策略</h4><p>一般来说，如Java，高并发的解决方案是提供多线程模型，服务器为每个客户端请求分配一个线程，使用同步I/O，并用线程切换来弥补同步I/O调用的时间开销。</p>
<p>Node.js对I/O进行了异步处理，避开了创建、销毁以及切换线程所需的开销和复杂性。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>Node.js在主线程里维护了一个<strong>事件队列</strong>。</p>
<ul>
<li>接到请求放入队列，并继续接收其他请求；</li>
<li>若主线程空闲（没有请求接入时），开启循环事件队列：若非I/O任务，主线程直接处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 <strong>线程池</strong> 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</li>
<li>当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到<strong>事件队列</strong>的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。</li>
</ul>
<p>Node.js被分为了四层，分别为<strong>应用层、V8引擎层、Node API层和LIBUV层</strong>。</p>
<p><img src="https://i.loli.net/2021/06/04/zqIOpN5U2ZGXFyw.png" alt="image.png"></p>
<blockquote>
<p>应用层：JavaScript交互层，常见的就是Node.js模块，如http、fs</p>
<p>V8引擎层：即利用V8引擎来解析JavaScript语法，进而和下层交互</p>
<p>NodeAPI层：为上层模块提供系统调用，一般由C语言实现，和操作系统进行交互</p>
<p>LIBUV层：跨平台的底层封装，实现了 事件循环、文件操作等，是实现Node.js异步的核心</p>
</blockquote>
<p><strong>值得注意的是</strong>：</p>
<p>无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 <strong>线程池</strong> 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，<strong>Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。</strong></p>
<h4 id="实现简易的事件循环"><a href="#实现简易的事件循环" class="headerlink" title="实现简易的事件循环"></a>实现简易的事件循环</h4><ol>
<li>定义事件队列</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义事件队列</span></span><br><span class="line"><span class="comment"> * 入队：push(); 出队：shift()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">globalEventQueue: []</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义接收请求入口</li>
</ol>
<p>每一个请求都会被拦截并进入处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">processHttpRequest: <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//定义一个事件对象</span></span><br><span class="line">	<span class="keyword">var</span> event = &#123;</span><br><span class="line">		params: request.params, <span class="comment">//传递请求参数</span></span><br><span class="line">		result: <span class="literal">null</span>, <span class="comment">//存放请求结果</span></span><br><span class="line">		callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//指定回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	globalEventQueue.push(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义Event Loop</li>
</ol>
<p>当主线程处于空闲时就开始循环事件队列，所以我们还要定义一个函数来循环事件队列： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eventLoop: function()&#123;</span><br><span class="line">	&#x2F;&#x2F;如果队列不为空，就继续循环</span><br><span class="line">	while(this.globalEventQueue.length &gt; 0)&#123;</span><br><span class="line">		var event &#x3D; this.globalEventQueue.shift();</span><br><span class="line">		if(isIOTask(event))&#123;</span><br><span class="line">			&#x2F;&#x2F;如果是IO任务</span><br><span class="line">			var thread &#x3D; getThreadFromThreadPool(); &#x2F;&#x2F;拿出线程处理</span><br><span class="line">			thread.handleIOTask(event);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F; 非耗时任务处理后，直接返回结果</span><br><span class="line">            var result &#x3D; handleEvent(event);</span><br><span class="line">            &#x2F;&#x2F; 最终通过回调函数返回给V8，再由V8返回给应用程序</span><br><span class="line">            event.callback.call(null,result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深入理解Node-js事件循环"><a href="#深入理解Node-js事件循环" class="headerlink" title="深入理解Node.js事件循环"></a>深入理解Node.js事件循环</h3><p>实际上异步任务之间并不相同，因此他们之间也有优先级之分，所以任务队列被分成两种类型：<br>microtask queue 微任务队列，macrotask queue 宏任务队列</p>
<p><strong>宏任务</strong>：<code>setTimeout</code>、<code>setInterval</code>、<code>Ajax</code>、<code>DOM事件</code>、<code>I/O</code>、<code>script标签中的整体代码</code></p>
<p><strong>微任务</strong>：<code>new Promise()</code>、<code>new MutaionObserver()</code></p>
<p>一次事件循环流程：<strong>取出一个宏任务开始-&gt;执行栈执行-&gt;执行栈为空-&gt;微任务队列执行-&gt;微任务队列为空-&gt;完成</strong></p>
<p>注意：</p>
<ul>
<li>宏任务或微任务执行过程产生的<strong>宏任务</strong>，在下一次事件循环执行</li>
<li>宏任务或微任务执行过程产生的<strong>微任务</strong>，在本次事件循环执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;start&quot;);</span><br><span class="line"></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&quot;setTimeout1&quot;);</span><br><span class="line">      new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&quot;setTimeout1-Promise-start&quot;);</span><br><span class="line">        resolve(&quot;setTimeout1-Promise&quot;);</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">        console.log(&quot;Promise1-then1&quot;);</span><br><span class="line">        return value;</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line"></span><br><span class="line">      console.log(&quot;Promise1-start&quot;);</span><br><span class="line">      resolve(&quot;Promise1-resolve&quot;);</span><br><span class="line">      console.log(&quot;Promise1-end&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">      console.log(&quot;Promise1-then1&quot;);</span><br><span class="line">      return value;</span><br><span class="line">    &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">      console.log(&quot;Promise1-then2&quot;);</span><br><span class="line"></span><br><span class="line">      Promise.resolve(&quot;Promise2&quot;)</span><br><span class="line">        .then(value1 &#x3D;&gt; &#123;</span><br><span class="line">          console.log(value1);</span><br><span class="line">          console.log(&quot;Promise2-then1&quot;);</span><br><span class="line">          return value1;</span><br><span class="line">        &#125;).then(value1 &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value1);</span><br><span class="line">        console.log(&quot;Promise2-then2&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&quot;setTimeout2&quot;)</span><br><span class="line">      new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&quot;setTimeout2-Promise-start&quot;);</span><br><span class="line">        resolve(&quot;setTimeout2-Promise&quot;);</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">      &#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    console.log(&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行结果</span><br><span class="line">start</span><br><span class="line">Promise1-start</span><br><span class="line">Promise2-end</span><br><span class="line">end</span><br><span class="line">&#x2F;&#x2F;执行栈为空，执行微任务</span><br><span class="line">promise1-resolve</span><br><span class="line">promise1-then1</span><br><span class="line">promise1-resolve</span><br><span class="line">promise1-then2</span><br><span class="line">Promise2</span><br><span class="line">Promise2-then1</span><br><span class="line">Promise2</span><br><span class="line">Promise2-then2</span><br><span class="line">&#x2F;&#x2F;第一次事件循环结束</span><br><span class="line">setTimeout1</span><br><span class="line">setTimeout1-Promise-start</span><br><span class="line">setTimeout1-Promise</span><br><span class="line">Promise1-then1</span><br><span class="line">setTimeout1-Promise</span><br><span class="line">&#x2F;&#x2F;第二次事件循环结束</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout2-Promise-start</span><br><span class="line">setTimeout2-Promise</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步 阻塞与非阻塞"></a>同步与异步 阻塞与非阻塞</h4><blockquote>
<p>同步与异步关注的是<strong>消息通知机制</strong>，调用者是主动等待还是被动接收</p>
</blockquote>
<blockquote>
<p>阻塞与非阻塞更关注的是<strong>程序在等待调用结果（消息，返回值）时的状态</strong>，挂起or继续执行</p>
</blockquote>
<p>以Linux环境下的network IO为例，具体说明：</p>
<p>IO Model：<code>blocking IO</code>、<code>nonblocking IO</code>、<code>IO multiplexing</code>、<code>signal driven IO</code>、<code>asynchronous IO</code></p>
<p>需要了解的前置知识：</p>
<p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p><strong>blocking IO</strong></p>
<p><img src="https://i.loli.net/2021/06/10/5xMq4a6Gbv1tYHu.png" alt="image.png"></p>
<p>对于blocking IO，两个阶段均被阻塞</p>
<p><strong>non-blocking IO</strong></p>
<p><img src="https://i.loli.net/2021/06/10/Bn6JpjMIvcDYs2i.png" alt="image.png"></p>
<p>用户进程需要不断的主动询问kernel数据是否准备完成，copy data阶段堵塞。</p>
<p><strong>IO multiplexing</strong></p>
<p><img src="https://i.loli.net/2021/06/10/DpJPWlBziId85Aq.png" alt="image.png"></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>本质任然是堵塞的，只是可以处理多个IO。</p>
<p><strong>Asynchronous I/O</strong></p>
<p><img src="https://www.hualigs.cn/image/60c1d03384402.jpg"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h3 id="ES6异步编程的实现"><a href="#ES6异步编程的实现" class="headerlink" title="ES6异步编程的实现"></a>ES6异步编程的实现</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;&#x2F;etc&#x2F;passwd&#39;, function (err, data) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调函数的缺陷：如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为<strong>回调函数噩梦</strong>(callback hell）。</p>
<p>Promise应运而生，它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载。</p>
<h4 id="Promise基础知识"><a href="#Promise基础知识" class="headerlink" title="Promise基础知识"></a>Promise基础知识</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readFile 承诺在未来的某个时刻完成</span></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">&quot;example.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>readFile()</code>不会立即开始读取文件，而是返回一个表示异步读取操作的Promise对象，未来对这个对象的操作取决于Promise的生命周期。</p>
<h5 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h5><ul>
<li>进行中<code>pending</code></li>
<li>成功完成<code>Fulfilled</code></li>
<li>执行错误<code>Rejected</code></li>
</ul>
<p>Promise.then()接收两个参数：第一，状态变为<code>fulfilled</code>时的状态；第二，状态变为<code>rejected</code>时的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise包装的readFile实例</span><br><span class="line">let fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">function readFile(fileName)&#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		fs.readFile(fileName, &#123;encoding: &quot;utf-8&quot;&#125;, function(err, contents) &#123;</span><br><span class="line">			if (err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			resolve(contents);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;应用</span><br><span class="line">let promise &#x3D; readFile(&quot;example.txt&quot;);</span><br><span class="line">promise.then(function(contents) &#123;</span><br><span class="line">	console.log(contents);</span><br><span class="line">&#125;, function(err) &#123;</span><br><span class="line">	console.error(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>); <span class="comment">//g时一个内部指针（即遍历器）</span></span><br><span class="line">g.next(); <span class="comment">//&#123; value: 3, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">//&#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p>
<h5 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h5><blockquote>
<p>Thunk函数是编译器“传名调用”实现方案</p>
</blockquote>
<p><strong>在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的 Thunk 函数转换器</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arguements);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">		args.push(callback);</span><br><span class="line">		<span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure>

<h5 id="Generator-函数的自动流程管理"><a href="#Generator-函数的自动流程管理" class="headerlink" title="Generator 函数的自动流程管理"></a>Generator 函数的自动流程管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function run(fn)&#123;</span><br><span class="line">	var gen &#x3D; fn();</span><br><span class="line">	function next(err, data)&#123;</span><br><span class="line">		var result &#x3D; gen.next(data);</span><br><span class="line">		if(result.done) return;</span><br><span class="line">		result.value(next); &#x2F;&#x2F;递归函数</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="co函数库"><a href="#co函数库" class="headerlink" title="co函数库"></a>co函数库</h4><blockquote>
<p>co函数库是TJ Holowaychuk发布的一个小工具，用于 Generator 函数的自动执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var gen &#x3D; function* ()&#123;</span><br><span class="line">	var f1 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;fstab&#39;);</span><br><span class="line">	var f2 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;shells&#39;);</span><br><span class="line">	console.log(f1.toString);</span><br><span class="line">	console.log(f2.toString);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var co &#x3D; require(&#39;co&#39;);</span><br><span class="line">co(gen); &#x2F;&#x2F;将Generator函数传入co函数，会自动执行</span><br></pre></td></tr></table></figure>

<p>co函数返回一个Promise对象，用then方法添加回调函数。</p>
<h5 id="基于Promise对象的自动执行"><a href="#基于Promise对象的自动执行" class="headerlink" title="基于Promise对象的自动执行"></a>基于Promise对象的自动执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将readFile包装成 Promise 对象</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">		fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(err) reject(data);</span><br><span class="line">			resolve(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">	<span class="built_in">console</span>.loh(f2.toString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动执行</span></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		g.next(data);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//自动执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> g = gen();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> result = g.next(data);</span><br><span class="line">		<span class="keyword">if</span>(result.done) <span class="keyword">return</span>;</span><br><span class="line">		result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">			next(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h5 id="co支持并发的异步操作"><a href="#co支持并发的异步操作" class="headerlink" title="co支持并发的异步操作"></a>co支持并发的异步操作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="keyword">yield</span>[</span><br><span class="line">		<span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">		<span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">	];</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">		<span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">		<span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>

<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<ul>
<li><strong>内置执行器</strong>。Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>更好的语义</strong>。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</p>
</li>
<li><p><strong>更广的适用性</strong>。co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p>
</li>
</ul>
<h5 id="async函数的实现"><a href="#async函数的实现" class="headerlink" title="async函数的实现"></a>async函数的实现</h5><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args)&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">function fn(args)&#123; </span><br><span class="line">  return spawn(function*() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<h3 id="模块系统-CommonJS-vs-ES6"><a href="#模块系统-CommonJS-vs-ES6" class="headerlink" title="模块系统(CommonJS vs ES6)"></a>模块系统(CommonJS vs ES6)</h3><blockquote>
<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
</blockquote>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的<span style="color:red">静态化</span>，使得<span style="color:red">编译时就能确定模块的依赖关系</span>，以及输入和输出的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;CommonJS模块</span><br><span class="line">let &#123;stat, exist, readfile&#125; &#x3D; require(&#39;fs&#39;);</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">let _fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">let stat &#x3D; _fs.stat;</span><br><span class="line">let exist &#x3D; _fs.exists;</span><br><span class="line">let readfile &#x3D; _fs.readfile;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的<strong>所有方法</strong>），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“<strong>运行时加载</strong>”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES6模块</span><br><span class="line">import &#123; stat, exists, readfile &#125; from &#39;fs&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>CommonJS：require语法，运行时加载，<strong>整体加载</strong></li>
<li>ES6：import语法，静态加载，<strong>部分加载</strong></li>
</ul>
<p><strong>CommonJS模块特点</strong>：</p>
<ul>
<li>所有代码运行在当前模块作用域中，不会污染全局作用域</li>
<li>模块同步加载，根据代码顺序加载</li>
<li>模块可以多次加载，只会在第一次加载时运行一次，然后运行结果缓存，后续再加载，在缓存中读取结果，若需要模块再次运行，必须清除缓存</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的例子,demo-exports.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;saucxs&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	name,</span><br><span class="line">	getName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo-require,js</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">require</span>(<span class="string">&#x27;./demo-export&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person, <span class="string">&#x27;-----------&#x27;</span>); 		<span class="comment">//&#123;name: &#x27;saucxs&#x27;, getName: [Function: getName]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name, <span class="string">&#x27;===========&#x27;</span>);	<span class="comment">//saucxs</span></span><br><span class="line">person.getName(<span class="string">&#x27;kiro&#x27;</span>);						<span class="comment">//kiro</span></span><br><span class="line">person.name = <span class="string">&#x27;updateName&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person, <span class="string">&#x27;22222222&#x27;</span>);			<span class="comment">//&#123;name: &#x27;updateName&#x27;, getName: [Function: getName]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><blockquote>
<p>CommonJS规范，每个人文件就是一个模块，每个模块中都有一个module对象，这个对象指向当前模块。</p>
</blockquote>
<p>module对象的属性：</p>
<ul>
<li>id：当前模块id</li>
<li>exports：表示当前模块暴露给外部的值</li>
<li>parent：是一个对象，表示调用当前模块的模块</li>
<li>children：是一个对象，表示当前模块调用的模块</li>
<li>filename：模块的绝对路径</li>
<li>paths：从当前模块开始查找<code>node_modules</code>目录，然后依次进入到父目录，查找父目录下的<code>node_modules</code>目录；依次迭代，直到根目录下的<code>node_modules</code>目录。</li>
<li>loaded：一个布尔值，表示当前模块是否被完全加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	name: <span class="string">&#x27;saucxs&#x27;</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Module = &#123;</span><br><span class="line">    id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">    <span class="built_in">exports</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;saucxs&#x27;</span>, <span class="attr">getName</span>: [<span class="built_in">Function</span>: getName]&#125;,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    filename: <span class="string">&#x27;&#x27;</span>, 	<span class="comment">//省略</span></span><br><span class="line">    loaded: <span class="literal">false</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: []		<span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>module.exports</strong></p>
<p>我们知道了module对象有一个exports属性，该属性用来对外暴露变量，方法或者整个模块。当其他文件需要require该模块的时候，实际上读取的是module对象中的exports属性。</p>
<p><strong>exports对象</strong></p>
<p>对比分析<code>module.exports</code>和<code>exports</code>：</p>
<ul>
<li>exports对象和module.exports都是引用类型变量，指向同一个内存地址，在node中，两者一开始都是指向一个空对象的。<code>exports = module.exports = &#123;&#125;</code></li>
<li>exports对象是通过形参的方式传入，直接赋值给形参的引用，但是并不能改变作用域外的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">	<span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">exports</span>.name = <span class="string">&#x27;kiro&#x27;</span>;	<span class="comment">//会同步到外部的module.exports对象</span></span><br><span class="line">	<span class="built_in">exports</span> = &#123;</span><br><span class="line">		age: <span class="number">18</span></span><br><span class="line">	&#125;;						<span class="comment">//只是修改引用，不会影响到module.exports</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">exports</span>);	<span class="comment">//&#123;age: 18&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">change(<span class="built_in">exports</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports);<span class="comment">//&#123;name: &#x27;kiro&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>module.exports就是为了解决上述exports直接赋值的问题，会导致抛出不成功的问题而产生的。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些操作都是合法的</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;saucxs&#x27;</span>;</span><br><span class="line"><span class="built_in">exports</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;saucxs&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于下面的方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">&#x27;saucxs&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;saucxs&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者更常规的写法</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;saucxs&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;saucxs&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getName: getName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="require方法"><a href="#require方法" class="headerlink" title="require方法"></a>require方法</h4><h5 id="node中引入模块的机制"><a href="#node中引入模块的机制" class="headerlink" title="node中引入模块的机制"></a>node中引入模块的机制</h5><p>引入模块的步骤：（1）路径分析；（2）文件定位；（3）编译执行</p>
<p>模块分为两种：（1）node提供的模块，如http、fs等；（2）用户自己编写的模块，文件模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requireA.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;requireA start loading...&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;requireA end loading...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//init.js</span></span><br><span class="line"><span class="keyword">var</span> mod1 = <span class="built_in">require</span>(<span class="string">&#x27;./requireA&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mod2 = <span class="built_in">require</span>(<span class="string">&#x27;./requireB&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod1 === mod2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line">requireA start loading...</span><br><span class="line">requireB end loading...</span><br><span class="line"><span class="literal">true</span> 		<span class="comment">//虽然两次require，但模块中的代码只执行了一遍，且指向同一个exports</span></span><br></pre></td></tr></table></figure>

<p>Node.js 的 require 方法中的文件查找策略如下：</p>
<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/11/CPVZKr7Xkl5FQMn.png" alt="image.png"></p>
<h3 id="常用库学习"><a href="#常用库学习" class="headerlink" title="常用库学习"></a>常用库学习</h3><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><blockquote>
<p>引入：require(‘http’)</p>
</blockquote>
<p>Node.js 中的 HTTP 接口旨在支持该协议的许多传统上难以使用的功能。 特别是大的，可能是块编码的消息。 接口从不缓冲整个请求或响应，因此用户能够流式传输数据。</p>
<p>HTTP请求头如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x27;content-length&#x27;: &#x27;123&#x27;,</span><br><span class="line">  	&#x27;content-type&#x27;: &#x27;text/plain&#x27;,</span><br><span class="line"> 	&#x27;connection&#x27;: &#x27;keep-alive&#x27;,</span><br><span class="line">  	&#x27;host&#x27;: &#x27;mysite.com&#x27;,</span><br><span class="line">  	&#x27;accept&#x27;: &#x27;*/*&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收到的原始标头保留在 <code>rawHeaders</code> 属性中，其是 <code>[key, value, key2, value2, ...]</code> 数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/07/Node-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/Node-js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Node.js异步编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-07 16:39:17" itemprop="dateCreated datePublished" datetime="2021-04-07T16:39:17+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 16:02:27" itemprop="dateModified" datetime="2021-06-04T16:02:27+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JS中的事件循环"><a href="#JS中的事件循环" class="headerlink" title="JS中的事件循环"></a>JS中的事件循环</h2><p>当遇到异步事件时，JS引擎会将这个事件挂起，执行栈继续执行，当这个异步事件返回结果后，会将这个事件加入到与当前执行栈不同的一个队列，我们称之为<strong>事件队列</strong>，被放入的事件不会立即执行其回调，而是要<strong>等到当前执行栈中所有的任务都执行完毕</strong>，JS线程处于闲置状态时，主线程才会去查找事件队列是否有任务，如果有，那么JS线程就会从中取出排在第一位的事件，并把这个事件对应的回调放入到执行栈中，然后执行其中的同步代码，如此反复，这样就形成了一个无限的循环，我们称之为事件循环。</p>
<h3 id="队列任务"><a href="#队列任务" class="headerlink" title="队列任务"></a>队列任务</h3><p>队列任务被分为两种：microtask queue<strong>微队列任务</strong>，macrotask queue<strong>宏队列任务</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/29/promise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/promise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">promise源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-29 14:32:28 / 修改时间：15:34:25" itemprop="dateCreated datePublished" datetime="2021-03-29T14:32:28+08:00">2021-03-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.jianshu.com/p/43de678e918a" target="_blank">参考1</a></p>
<p><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank">参考2</a></p>
<h2 id="Promise基本结构"><a href="#Promise基本结构" class="headerlink" title="Promise基本结构"></a>Promise基本结构</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		resolve(<span class="string">&#x27;FULFILLED&#x27;</span>);</span><br><span class="line">	&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先，我们定义一个名为 <code>MyPromise</code> 的 <code>Class</code>，它接受一个函数 <code>handle</code> 作为参数，且定义一个判断一个变量是否为函数的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span> (<span class="params">handle</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise状态和值"><a href="#Promise状态和值" class="headerlink" title="Promise状态和值"></a>Promise状态和值</h2><p>两个属性值：<code>_status </code>、<code>_value</code></p>
<p>三种状态：<code>Pending</code>、<code>Fulfilled</code>、<code>Rejected</code></p>
<blockquote>
<p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或由 <code>Pending</code> 变为 <code>Rejected</code> ，且状态改变之后不会在发生变化，会一直保持这个状态。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上文中<code>handle</code>函数包含 <code>resolve</code> 和 <code>reject</code> 两个参数，它们是两个函数，可以用于<strong>改变 <code>Promise</code> 的状态</strong>和<strong>传入 <code>Promise</code> 的值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;FULFILLED&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，为 <code>MyPromise</code> 添加状态和值，并添加状态改变的执行逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="built_in">this</span>._status = PENDING</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 执行handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>)) </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">this</span>._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">  _resolve (val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>._status = FULFILLED</span><br><span class="line">    <span class="built_in">this</span>._value = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">  _reject (err) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">    <span class="built_in">this</span>._value = err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise的then方法"><a href="#Promise的then方法" class="headerlink" title="Promise的then方法"></a>Promise的then方法</h2><p><code>Promise</code> 对象的 <code>then</code> 方法接受两个参数：</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p>
<ul>
<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 不是函数，其必须被忽略</li>
</ul>
<p>特性：</p>
<ul>
<li>当 <code>promise</code> 状态变为成功时必须被调用，其第一个参数为 <code>promise</code> 成功\失败状态传入的值（ <code>resolve</code> 执行时传入的值）</li>
<li>在 <code>promise</code> 状态改变前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<p><strong>多次调用</strong></p>
<p><code>then</code> 方法必须返回一个<strong>新的 <code>promise</code> 对象</strong>，因此 <code>promise</code> 支持链式调用</p>
<h3 id="Promise的一些执行规则"><a href="#Promise的一些执行规则" class="headerlink" title="Promise的一些执行规则"></a>Promise的一些执行规则</h3><p><strong>如何实现then方法返回一个新的<code>promise</code>对象？</strong></p>
<ul>
<li><p>若 <code>x</code> 不为 <code>Promise</code> ，则使 <code>x</code> 直接作为新返回的 <code>Promise</code> 对象的值， 即新的<code>onFulfilled</code> 或者 <code>onRejected</code> 函数的参数.</p>
</li>
<li><p>若 <code>x</code> 为 <code>Promise</code> ，这时后一个回调函数，就会等待该 <code>Promise</code> 对象(即 <code>x</code> )的状态发生变化，才会被调用，并且新的 <code>Promise</code> 状态和 <code>x</code> 的状态相同。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个普通值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;这里返回一个普通值&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//1秒后打印出：这里返回一个普通值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     resolve(<span class="string">&#x27;这里返回一个Promise&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//3秒后打印出：这里返回一个Promise</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>抛出一个异常 <code>e</code></strong></p>
<p>如果 <code>onFulfilled</code> 或者<code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须变为失败<code>（Rejected）</code>，并返回失败的值 <code>e</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这里抛出一个异常e&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">//1秒后打印出：这里抛出一个异常e</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>如果<code>onFulfilled</code> 不是函数且 <code>promise1</code> 状态为成功<code>（Fulfilled）</code></strong></p>
<p><code>promise2</code> 必须变为成功<code>（Fulfilled）</code>并返回 <code>promise1</code> 成功的值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="string">&#x27;这里的onFulfilled本来是一个函数，但现在不是&#x27;</span>)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 1秒后打印出：success</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 状态为失败<code>（Rejected）</code></strong></p>
<p><code>promise2</code>必须变为失败<code>（Rejected）</code> 并返回 <code>promise1</code> 失败的值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> res, <span class="string">&#x27;这里的onRejected本来是一个函数，但现在不是&#x27;</span>)</span><br><span class="line">promise2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)  <span class="comment">// 1秒后打印出：fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>据此，完善<code>then()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line">then (onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">          onFulfilledNext(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res =  onFulfilled(value);</span><br><span class="line">          <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">            res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">            onFulfilledNext(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">        onRejectedNext(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">          onRejectedNext(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">        onRejectedNext(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">      <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">      <span class="keyword">case</span> PENDING:</span><br><span class="line">        <span class="built_in">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class="line">        <span class="built_in">this</span>._rejectedQueues.push(rejected)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        fulfilled(_value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        rejected(_value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整的promise源码"><a href="#完整的promise源码" class="headerlink" title="完整的promise源码"></a>完整的promise源码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  <span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line">  <span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> FULFILLED = <span class="string">&#x27;FULFILLED&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">handle</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加状态</span></span><br><span class="line">      <span class="built_in">this</span>._status = PENDING</span><br><span class="line">      <span class="comment">// 添加状态</span></span><br><span class="line">      <span class="built_in">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">      <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">      <span class="built_in">this</span>._fulfilledQueues = []</span><br><span class="line">      <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">      <span class="built_in">this</span>._rejectedQueues = []</span><br><span class="line">      <span class="comment">// 执行handle</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handle(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>)) </span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">this</span>._reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">    _resolve (val) &#123;</span><br><span class="line">      <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">this</span>._status = FULFILLED</span><br><span class="line">        <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">const</span> runFulfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> cb;</span><br><span class="line">          <span class="keyword">while</span> (cb = <span class="built_in">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class="line">            cb(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">const</span> runRejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> cb;</span><br><span class="line">          <span class="keyword">while</span> (cb = <span class="built_in">this</span>._rejectedQueues.shift()) &#123;</span><br><span class="line">            cb(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span></span><br><span class="line"><span class="comment">          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          val.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = value</span><br><span class="line">            runFulfilled(value)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._value = err</span><br><span class="line">            runRejected(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>._value = val</span><br><span class="line">          runFulfilled(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(run, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">    _reject (err) &#123; </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">        <span class="built_in">this</span>._value = err</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> (cb = <span class="built_in">this</span>._rejectedQueues.shift()) &#123;</span><br><span class="line">          cb(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(run, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加then方法</span></span><br><span class="line">    then (onFulfilled, onRejected) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">        <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">              onFulfilledNext(value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> res =  onFulfilled(value);</span><br><span class="line">              <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">                res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">                onFulfilledNext(res)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">            onRejectedNext(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">        <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">              onRejectedNext(error)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">                <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                  <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">                  res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">                  onFulfilledNext(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">            onRejectedNext(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">          <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">          <span class="keyword">case</span> PENDING:</span><br><span class="line">            <span class="built_in">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class="line">            <span class="built_in">this</span>._rejectedQueues.push(rejected)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">          <span class="keyword">case</span> FULFILLED:</span><br><span class="line">            fulfilled(_value)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="keyword">case</span> REJECTED:</span><br><span class="line">            rejected(_value)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加catch方法</span></span><br><span class="line">    <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">      <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态reject方法</span></span><br><span class="line">    <span class="keyword">static</span> reject (value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve ,reject</span>) =&gt;</span> reject(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态all方法</span></span><br><span class="line">    <span class="keyword">static</span> all (list) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回值的集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">let</span> values = []</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> [i, p] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">          <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">          <span class="built_in">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            values[i] = res</span><br><span class="line">            count++</span><br><span class="line">            <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加静态race方法</span></span><br><span class="line">    <span class="keyword">static</span> race (list) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">          <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">          <span class="built_in">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">        value  =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">        reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/Nodejs%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/Nodejs%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Nodejs学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 19:34:23" itemprop="dateCreated datePublished" datetime="2021-03-22T19:34:23+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 10:31:41" itemprop="dateModified" datetime="2021-03-23T10:31:41+08:00">2021-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命令行窗口（cmd-终端-shell）"><a href="#命令行窗口（cmd-终端-shell）" class="headerlink" title="命令行窗口（cmd\终端\shell）"></a>命令行窗口（cmd\终端\shell）</h2><p>常用指令：</p>
<p>dir\cd\md(创建文件夹)\rd(删除文件夹)</p>
<p>环境变量：在任何位置都可以使用指令</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>在Node中，每一个js文件就是一个模块，每一个js文件中的js代码都是独立运行在一个函数中。<strong>所以一个模块中的变量和函数在其他模块中无法访问</strong>。</p>
<p>require语法：</p>
<p>核心模块：由node引擎提供的模块<code>const _ = require(&#39;lodash&#39;)</code>;</p>
<p>文件模块：用户自定义模块：<code>const Err = require(&#39;../utils/err&#39;);</code></p>
<h3 id="模块的深度理解"><a href="#模块的深度理解" class="headerlink" title="模块的深度理解"></a>模块的深度理解</h3><p>在node中有一个全局变量global，作用和网页中的windows类似，在全局中创建的变量、函数都会作为global的属性、方法保存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">global</span>.a); <span class="comment">//undefined=&gt;因此a不是全局变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">[Arguments] &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: [<span class="built_in">Function</span>: <span class="built_in">require</span>] &#123;</span><br><span class="line">    resolve: [<span class="built_in">Function</span>: resolve] &#123; <span class="attr">paths</span>: [<span class="built_in">Function</span>: paths] &#125;,</span><br><span class="line">    main: Module &#123;</span><br><span class="line">      id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试&#x27;</span>,</span><br><span class="line">      <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">      parent: <span class="literal">null</span>,</span><br><span class="line">      filename: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>,</span><br><span class="line">      loaded: <span class="literal">false</span>,</span><br><span class="line">      children: [],</span><br><span class="line">      paths: [<span class="built_in">Array</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">      <span class="string">&#x27;.js&#x27;</span>: [<span class="built_in">Function</span> (anonymous)],</span><br><span class="line">      <span class="string">&#x27;.json&#x27;</span>: [<span class="built_in">Function</span> (anonymous)],</span><br><span class="line">      <span class="string">&#x27;.node&#x27;</span>: [<span class="built_in">Function</span> (anonymous)]</span><br><span class="line">    &#125;,</span><br><span class="line">    cache: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123;</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>: [Module]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: Module &#123;</span><br><span class="line">    id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">    path: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试&#x27;</span>,</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    filename: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>,</span><br><span class="line">    loaded: <span class="literal">false</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: [</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\node_modules&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\学习笔记\\node_modules&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;D:\\YouData\\node_modules&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;D:\\node_modules&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试\\test1.js&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;D:\\YouData\\学习笔记\\代码测试&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示：</p>
<p>在node执行模块中的代码时，它会首先在代码的最顶部，添加如下代码：</p>
<p><code>function (exports, require, module, __filename, __dirname) &#123;</code></p>
<p>在代码的最底部，添加如下代码</p>
<p><code>&#125;</code></p>
<p><strong>模块函数中的参数</strong>：</p>
<ul>
<li>exports：用于将变量或函数暴露到外部</li>
<li>require：函数，引入外部模块</li>
<li>module：代表当前模块本身，则exports就是module的属性</li>
<li>_filename：当前模块的完整文件路径</li>
<li>_dirname：当前模块所在文件夹的完整路径</li>
</ul>
<h3 id="exports和module-exports"><a href="#exports和module-exports" class="headerlink" title="exports和module.exports"></a>exports和module.exports</h3><ul>
<li>exports只能通过.的方式向外暴露内部对象</li>
<li>而module.exports可以通过.的形式，也可以直接赋值</li>
</ul>
<p><code>module.exports.xxx = xxxx</code>或</p>
<p><code>module.exports = &#123;&#125;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ES6学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 15:59:28" itemprop="dateCreated datePublished" datetime="2021-03-20T15:59:28+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 20:12:12" itemprop="dateModified" datetime="2021-03-23T20:12:12+08:00">2021-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-块级作用域绑定"><a href="#1-块级作用域绑定" class="headerlink" title="1 块级作用域绑定"></a>1 块级作用域绑定</h2><p>JavaScript中的作用域：</p>
<p>变量在函数内声明，变量为局部作用域；</p>
<p>变量在函数外定义，即为全局变量。全局变量有 <strong>全局作用域</strong>: 网页中所有脚本和函数均可使用。 </p>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</p>
<h3 id="var声明及变量提升（Hoisting）机制"><a href="#var声明及变量提升（Hoisting）机制" class="headerlink" title="var声明及变量提升（Hoisting）机制"></a>var声明及变量提升（Hoisting）机制</h3><p>在JavaScript中，通过var声明的变量无论在哪里声明，都会被当成当前作用域顶部声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVaule</span>(<span class="params">condition</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">        <span class="comment">//其它代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在预编译阶段，JavaScript引擎会将上面的getValue函数修改成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVaule</span>(<span class="params">condition</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> value;</span><br><span class="line">	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">        <span class="comment">//其它代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处可访问变量value，其值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ES6引入块级作用域来强化对变量生命周期的控制</strong></p>
<h3 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h3><p>块级声明用于声明在指定块的作用域之外无法访问的变量，存在于：</p>
<ul>
<li>函数内部</li>
<li>块中（字符{和}之间的区域）</li>
</ul>
<h4 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h4><p>let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明后，不会再被提升至函数顶部。执行流离开if块，value立刻销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVaule</span>(<span class="params">condition</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">        <span class="comment">//其它代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//变量value此处不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量value此处不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>禁止重声明</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>; <span class="comment">//抛出语法错误</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">	<span class="keyword">let</span> count = <span class="number">40</span>; <span class="comment">//不会抛出错误，内部块中的count会屏蔽全局作用域中的count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>声明常量，其值一旦被设定不能被更改。类似Java中的static final，也是<strong>块级标识符</strong>，只在当前代码块有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> maxItems; <span class="comment">//错误，没有初始化</span></span><br></pre></td></tr></table></figure>

<p>同java一样，如果const声明的是变量如果是对象，则对象中的值可以修改，绑定不允许修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person&#123;</span><br><span class="line">	name:<span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>; <span class="comment">//可以修改值</span></span><br><span class="line">person=&#123;</span><br><span class="line">	name:<span class="string">&quot;Greg&quot;</span></span><br><span class="line">&#125;;	<span class="comment">//抛出语法错误</span></span><br></pre></td></tr></table></figure>

<h4 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h4><p>与var不同，let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问变量，会触发错误，即使是相对安全的typeof也是。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);  <span class="comment">//引用错误</span></span><br><span class="line">	<span class="keyword">let</span> value = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript引擎在扫描代码发现变量时，要么将它们提升至作用域顶部（var），要么将声明放到”临时死区“TDZ中（let，const）</strong>。只有执行过变量声明语句后，变量才会从TDZ中移出，然后才能正常访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//不能访问！</span></span><br></pre></td></tr></table></figure>

<h4 id="循环中的声明"><a href="#循环中的声明" class="headerlink" title="循环中的声明"></a>循环中的声明</h4><p>补充：</p>
<p><strong>Array数组的forEach()函数的用法</strong></p>
<p>语法：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(currentValue, index, arr), thisValue)</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>function(currentValue, index, arr)</em></td>
<td align="left">必需。 数组中每个元素需要调用的函数。 函数参数:参数描述<em>currentValue</em>必需。当前元素<em>index</em>可选。当前元素的索引值。<em>arr</em>可选。当前元素所属的数组对象。</td>
</tr>
<tr>
<td align="left"><em>thisValue</em></td>
<td align="left">可选。传递给函数的值一般用 “this” 值。 如果这个参数为空， “undefined” 会传递给 “this” 值</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	func(); <span class="comment">//输出10次数字10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>循环每次迭代同时共享变量i</strong>，因此循环结束时变量i的值为10，所以输出10次数字10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	func(); <span class="comment">//输出0-9</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>let声明，<strong>每次迭代循环都会创建一个新变量</strong>，并以之前迭代中同名变量的值将其初始化。</p>
<p><strong>循环中的const声明</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	<span class="comment">//完成一次迭代后报错,i++报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">	object = &#123;</span><br><span class="line">		a:<span class="literal">true</span>,</span><br><span class="line">		b:<span class="literal">true</span>,</span><br><span class="line">		c:<span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line">	<span class="comment">//不会报错，每次均创建一个新的绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="全局块作用域绑定"><a href="#全局块作用域绑定" class="headerlink" title="全局块作用域绑定"></a>全局块作用域绑定</h4><p>当var被用于全局对象时，它会创建一个新的全局变量作为全局对象（windows）的属性，这意味着可能会无意中覆盖一个已经存在的全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在浏览器中</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(windows.RegExp); <span class="comment">//”Hello“</span></span><br></pre></td></tr></table></figure>

<p>在全局作用域中使用let或const，会在全局域下创建一个新绑定，但不会添加为全局对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在浏览器中</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(windows.RegExp == <span class="built_in">RegExp</span>); <span class="comment">//false;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-字符串和正则表达式"><a href="#2-字符串和正则表达式" class="headerlink" title="2 字符串和正则表达式"></a>2 字符串和正则表达式</h2><p>没看</p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当传入更少数量的参数时，默认参数值的特性可以有效简化函数声明的代码。</p>
<p><strong>形参默认值</strong></p>
<p><em>ES5中的形参默认值设置方法</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一</span><br><span class="line">function makeRequest(url, timeout, callback)&#123;</span><br><span class="line">	timeout &#x3D; timeout || 2000;</span><br><span class="line">	callback &#x3D; callback || function()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;此时若传入timeout&#x3D;0，仍然赋值2000，不符合要求</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法二：相比方法一更安全，但很繁琐</span><br><span class="line">function makeRequest(url, timeout, callback)&#123;</span><br><span class="line">	timeout &#x3D; (typeof timeout!&#x3D;&#x3D;&quot;undefined&quot;)?timeout:2000;</span><br><span class="line">	callback &#x3D; (typeof callback !&#x3D;&#x3D; &quot;undefined&quot;)?callback:function()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ES6的形参默认值设置方法</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout&#x3D;2000, callback&#x3D;function()&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;此时</span><br><span class="line">makeRequest(&quot;&#x2F;foo&quot;); &#x2F;&#x2F;使用参数timeout和callback的默认值</span><br><span class="line">makeRequest(&quot;&#x2F;foo&quot;，500); &#x2F;&#x2F;使用参数callback的默认值</span><br><span class="line">makeRequest(&quot;&#x2F;foo&quot;，500，function(body)&#123;</span><br><span class="line">	doSomething(body);</span><br><span class="line">&#125;);  &#x2F;&#x2F;不使用默认值</span><br></pre></td></tr></table></figure>

<p><strong>默认参数值对arguement对象的影响</strong></p>
<p><em>ES5</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first,second</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//true</span></span><br><span class="line">	first=<span class="string">&quot;c&quot;</span>;</span><br><span class="line">	second=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在非严格模式下，命名参数的变化会同步更新到arguement对象中。严格模式下不会。</p>
<p><em>ES6</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first,second=”<span class="number">6</span>“</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">//1</span></span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//false</span></span><br><span class="line">	first=<span class="string">&quot;c&quot;</span>;</span><br><span class="line">	second=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(first===<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//false</span></span><br><span class="line">	<span class="built_in">console</span>.log(second===<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是否显示定义严格模式，arguement的行为都会与命名参数分离。</p>
<p><strong>默认参数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second=getValue()</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>先定义的参数也可以作为后定义的参数的默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second=first</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first+second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>但不允许先定义的参数引用后定义参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first=second, second</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first+second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>,<span class="number">1</span>));   <span class="comment">//抛出错误</span></span><br></pre></td></tr></table></figure>

<p><strong>默认参数的临时死区</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于上一段代码</span></span><br><span class="line"><span class="comment">//调用add(1,1)相当于</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用add(undefined,1)</span></span><br><span class="line"><span class="keyword">let</span> first = second;  <span class="comment">//let不会变量提升，报错</span></span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="处理无命名参数"><a href="#处理无命名参数" class="headerlink" title="处理无命名参数"></a>处理无命名参数</h3><p>处理传入更多数量的参数。</p>
<p><em>ES5中的无命名参数</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>, len=<span class="built_in">arguments</span>.length; i&lt;len; i++)&#123;</span><br><span class="line">		result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> book=&#123;</span><br><span class="line">	title:<span class="string">&quot;Understanding ECMAScript 5&quot;</span>,</span><br><span class="line">	author:<span class="string">&quot;rose&quot;</span>,</span><br><span class="line">	year:<span class="number">1997</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bookData = pick(book,<span class="string">&quot;author&quot;</span>,<span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bookData.author); <span class="comment">//&quot;rose&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.year); <span class="comment">//1997</span></span><br></pre></td></tr></table></figure>

<p><em>ES6中的不定参数</em> 类似jva</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;keys.length; i++)&#123;</span><br><span class="line">		results[keys[i]] = object[keys[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不定参数的加入不会影响函数length属性的值，本例中pick函数的length为1.</p>
</blockquote>
<p>每个函数最多只有一个不定参数，且一定在所有参数的末尾。</p>
<p><strong>不定参数对arguments对象的影响</strong></p>
<p>arguments对象包含所有传入函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(args.length);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">	<span class="built_in">console</span>.log(args[<span class="number">0</span>],<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">console</span>.log(args[<span class="number">1</span>],<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">a a</span><br><span class="line">b b</span><br></pre></td></tr></table></figure>

<p><strong>增强的Function构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;first&quot;</span>,<span class="string">&quot;second&quot;</span>,<span class="string">&quot;return first+second&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p><em>ES6中允许在增强构造函数中加默认值与不定参数</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;first&quot;</span>,<span class="string">&quot;second=first&quot;</span>,<span class="string">&quot;return first+second&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));   <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;...args&quot;</span>,<span class="string">&quot;return args[0]&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>展开运算符</strong></p>
<p>JavaScript内建的Math.max()方法可以接受任意数量的参数并返回值最大的那一个，但只适用于两个值，不允许传入数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5的解决办法</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的解决办法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将展开运算符与其他正常值混合使用</span></span><br><span class="line"><span class="keyword">let</span> values = [-<span class="number">100</span>,-<span class="number">75</span>,-<span class="number">50</span>,-<span class="number">25</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...values,<span class="number">0</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="函数的name属性"><a href="#函数的name属性" class="headerlink" title="函数的name属性"></a>函数的name属性</h3><p>ES6新增了name属性，主要解决问题：<br>JavaScript有多种定义函数的方式，特别是匿名函数表达式的广泛使用更加大了调试的难度，name属性可以更好的辨别函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">//doSomething</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name); <span class="comment">//doAnotherThing</span></span><br></pre></td></tr></table></figure>

<p><strong>ES6也做了许多工作来确保所有函数都有合适的名称</strong>，具体省略。</p>
<h3 id="函数的多重用途"><a href="#函数的多重用途" class="headerlink" title="函数的多重用途"></a>函数的多重用途</h3><p>没看懂</p>
<h3 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h3><p>ES5及以前不支持块级函数的声明，ES5严格模式下引入了一个错误提示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//ES5抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6中会将其视作一个块级声明，从而在定义该函数的代码块内访问和调用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//&quot;function&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//块级函数会被提升至顶部</span></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">doSomething(); <span class="comment">//undefined，if外不存在</span></span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//抛出错误</span></span><br><span class="line">	<span class="keyword">let</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//块级函数会被提升至顶部</span></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">doSomething(); <span class="comment">//undefined，if外不存在</span></span><br></pre></td></tr></table></figure>

<p><strong>非严格模式下的块级函数</strong></p>
<p>ES6非严格模式下，不在被提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//&quot;function&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//&quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6引入的一种全新的方式来声明函数</p>
<p><strong>箭头函数与传统的JavaScript函数有些许不同</strong>：</p>
<ul>
<li>没有this\super\arguments\new.target绑定，箭头函数的这些值由外围最近一层非箭头函数决定；</li>
<li>不能通过new关键字调用，没有[[Construct]]方法；</li>
<li>没有原型;</li>
<li>不可以改变this的绑定；</li>
<li>不支持arguments对象</li>
<li>不支持重复的命名参数</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个参数</span></span><br><span class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">let</span> reflet = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入两个及以上的参数</span></span><br><span class="line"><span class="keyword">let</span> reflect  = <span class="function">(<span class="params">num1,num2</span>)=&gt;</span>num1+num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有传入参数</span></span><br><span class="line"><span class="keyword">let</span> getName = <span class="function">()=&gt;</span><span class="string">&quot;rose&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由多个表达式组成的更传统的函数体，用&#123;&#125;包围</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1,num2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空函数</span></span><br><span class="line"><span class="keyword">let</span> doNothing = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象字面量</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;<span class="attr">id</span>:id,<span class="attr">name</span>:<span class="string">&quot;Temp&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>创建立即执行函数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">//rose</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将箭头函数包裹在小括号内即可</span></span><br><span class="line"><span class="keyword">let</span> person = (<span class="function">(<span class="params">name</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName); <span class="comment">//rose</span></span><br></pre></td></tr></table></figure>

<p><strong>箭头函数没有this绑定</strong></p>
<p><em>ES5</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PageHandler = &#123;</span><br><span class="line">	id:<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.doSomething(event.type);<span class="comment">//抛出错误</span></span><br><span class="line">		&#125;,<span class="literal">false</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	doSomething:<span class="function"><span class="title">fuction</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span>+type+<span class="string">&quot; for &quot;</span>+<span class="built_in">this</span>.id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中的this为方法对象，因此此时this为document对象而不PageHandler</p>
<p><em>ES5中的解决办法</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.doSomething(event.type);<span class="comment">//抛出错误</span></span><br><span class="line">		&#125;).bind(<span class="built_in">this</span>) ,<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><em>ES6中用箭头解决办法</em></p>
<p>箭头函数被非箭头函数包含，this绑定的时最近一层非箭头函数的this，否则，this值为undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,</span><br><span class="line">			event=&gt;<span class="built_in">this</span>.doSomething(event.type),<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript中箭头函数的初衷时“即用即弃”，因此不能new。</p>
<p><strong>箭头数字非常适用于数组处理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数没有arguments绑定</strong></p>
<p>箭头函数没有自己的arguments对象，且始终可以访问外围函数的arguments对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">()=&gt;</span><span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction()); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doSomethingElse(); <span class="comment">//尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES5引擎中，尾调的实现与其他函数调用的实现类似：创建一个新=帧，将其堆入调用栈来表示函数调用。即，在循环调用中，每一个未用完的帧都被保存在内存里，当调用栈过大会造成程序问题。</p>
<p><strong>ES6中的尾调优化</strong>：缩减了严格模式下尾调用栈的大小（非严格模式下不受影响），若满足以下条件，尾调不再创建新帧，而是清除并重用当前栈帧：</p>
<ul>
<li>尾调不访问当前栈帧的变量</li>
<li>在函数内部，时最后一条语句</li>
<li>尾调用的结果作为函数返回值</li>
</ul>
<p><strong>如何利用尾调优化</strong></p>
<p>常用于递归函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n*factotial(n-<span class="number">1</span>); <span class="comment">//尾调无法优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾调优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n,p=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>*p;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> result = n*p;</span><br><span class="line">		<span class="keyword">return</span> factorial(n-<span class="number">1</span>,result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果递归函数量足够大，则尾调递归优化可以大幅提升程序的性能</strong></p>
<h2 id="4-扩展对象的功能性"><a href="#4-扩展对象的功能性" class="headerlink" title="4 扩展对象的功能性"></a>4 扩展对象的功能性</h2><h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><ul>
<li>普通对象：具有JavaScript对象所有的默认内部行为</li>
<li>特异对象：具有某些与默认行为不符的内部行为</li>
<li>标准对象：ES6规范中定义的对象，如Array，Date等，既可以是普通对象，也可以是特异对象</li>
<li>内建对象：脚本开始执行时存在于JavaScript执行环境中的对象，所有标准对象都是内建对象。</li>
</ul>
<h4 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h4><p><strong>属性的简洁表示法</strong></p>
<p>当一个对象的属性与本地变量同名时，不必再写冒号和值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当对象字面量只有一个属性名称时，引擎会在可访问的作用域查找其同名变量并赋值。</p>
</blockquote>
<p><strong>对象方法的简写</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHi();  <span class="comment">//&quot;Hi&quot;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHi();<span class="comment">//&quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>可计算属性名</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5访问对象属性的一种方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;,</span><br><span class="line">	lastName = <span class="string">&quot;last name&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;first name&quot;</span>]=<span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person[lastName] = <span class="string">&quot;Zakas&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6中，可在对象字面量中使用可计算属性名称</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&quot;last name&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="string">&quot;first name&quot;</span>:<span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	[lastName]:<span class="string">&quot;Zakas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或是</span></span><br><span class="line"><span class="keyword">let</span> suffix = <span class="string">&quot; name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	[<span class="string">&quot;first&quot;</span>+suffix]:<span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	[<span class="string">&quot;last&quot;</span>+suffix]=<span class="string">&quot;Zakas&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许用表达式作为属性名</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h4><p><strong>Object.is()</strong></p>
<p>作用：弥补全等运算符的不足</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一是+0不等于-0</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,-<span class="number">0</span>);  <span class="comment">//false</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//二是NaN等于本身</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>); <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.assign()</strong></p>
<p>作用：将源对象的所有可枚举属性复制到目标对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="number">3</span>);         <span class="comment">// Number &#123;3&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">3</span>);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>);       <span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>);  <span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line">当参数不止一个时，<span class="literal">null</span> 和 <span class="literal">undefined</span> 不放第一个，即不为目标对象时，会跳过 <span class="literal">null</span> 和 <span class="literal">undefined</span> ，不报错</span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="number">1</span>,<span class="literal">undefined</span>);  <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,<span class="literal">null</span>);  <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>,&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);  <span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure>

<p><strong>此拷贝为浅拷贝</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sourceObj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> targetObj = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, sourceObj);</span><br><span class="line">targetObj.a.b = <span class="number">2</span>;</span><br><span class="line">sourceObj.a.b;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的处理</span></span><br><span class="line"><span class="built_in">Object</span>.assign([<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>]);  <span class="comment">// [5,3]</span></span><br></pre></td></tr></table></figure>

<h4 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h4><p><em>ES5严格模式下，对象中不允许出现同名属性</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	name : <span class="string">&quot;Greg&quot;</span>  <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ES6移除检查，直接取最后一个取值</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">	name : <span class="string">&quot;Greg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>

<h4 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h4><p>ES5中未定义对象属性的枚举顺序。ES6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到<code>Object.getOwnPropertyNames()</code>方法以及<code>Reflect.ownKeys()</code>，<code>Object.assign()</code>方法处理属性的顺序也将随之改变。</p>
<p>自有属性枚举顺序的基本规则：</p>
<ul>
<li>所有数字键按升序</li>
<li>所有字符键按被加入对象的顺序</li>
<li>所有symnol键按照它们被加入对象的顺序</li>
</ul>
<h2 id="5-解构"><a href="#5-解构" class="headerlink" title="5 解构"></a>5 解构</h2><h2 id="6-JavaScript中的类"><a href="#6-JavaScript中的类" class="headerlink" title="6 JavaScript中的类"></a>6 JavaScript中的类</h2><p><strong>类的基本语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5中构造类对象方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.brand = brand;</span><br><span class="line">	<span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Phone.propotype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> huawei = <span class="keyword">new</span> Phone(<span class="string">&quot;huawei&quot;</span>,<span class="number">5999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(huawei);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.brand = brand;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//必须写以下语法</span></span><br><span class="line">	<span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> onePlus = <span class="keyword">new</span> Phone(<span class="string">&quot;1+&quot;</span>,<span class="number">4999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(onePlus);</span><br></pre></td></tr></table></figure>

<p><strong>类的静态属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> name = <span class="string">&#x27;手机&#x27;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cosole.log(<span class="string">&quot;我可以改变世界&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nokia = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(nokia.name);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Phone.name);<span class="comment">//&#x27;手机&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>类的继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.brand = brand;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">brand,price,color,size</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(brand,price);</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">		<span class="built_in">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get和set方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">	<span class="keyword">get</span> <span class="title">price</span>()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;价格属性被读取了&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;iloveyou&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">price</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;价格属性被修改了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(s.price); <span class="comment">//价格属性被读取了   price=iloveyou</span></span><br><span class="line">s.price = <span class="string">&#x27;free&#x27;</span>;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/JavaScript%E5%A4%8D%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/JavaScript%E5%A4%8D%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">JavaScript复习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 15:38:30" itemprop="dateCreated datePublished" datetime="2021-03-19T15:38:30+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 21:13:47" itemprop="dateModified" datetime="2021-03-26T21:13:47+08:00">2021-03-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.runoob.com/js/js-output.html" target="_blank">参考</a></p>
<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><p>JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p>
<p>主要作用：</p>
<ul>
<li>直接写入HTML输出流</li>
<li>对事件进行反应</li>
<li>改变HTML内容、图像、样式</li>
<li>验证输入</li>
</ul>
<h2 id="JavaScript用法"><a href="#JavaScript用法" class="headerlink" title="JavaScript用法"></a>JavaScript用法</h2><p>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。</p>
<ul>
<li>脚本可被放置在 HTML 页面的 <body> 和 <head> 部分中。</li>
<li>外部文件，请在 <script> 标签的 "src" 属性中设置该 .js 文件</li>
</ul>
<h2 id="JavaScript输出"><a href="#JavaScript输出" class="headerlink" title="JavaScript输出"></a>JavaScript输出</h2><ul>
<li>使用 <strong>window.alert()</strong> 弹出警告框。</li>
<li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li>
<li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li>
<li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li>
</ul>
<h2 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h2><p><strong>JavaScript字面量</strong></p>
<p>Number(3.14、1001、123e05)、表达式、数组([40,100,1,15,20])、对象({firstName:”John”,lastName:”Doe”, age:50, eyeColor:”blue”})、函数(function myFunction(a, b) { return a * b;})</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 JavaScript 中有 6 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<p><strong>创建数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">cars[<span class="number">0</span>]=<span class="string">&quot;Saab&quot;</span>;</span><br><span class="line">cars[<span class="number">1</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">cars[<span class="number">2</span>]=<span class="string">&quot;BMW&quot;</span>; <span class="comment">//方式一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);<span class="comment">//方式二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cars=[<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>]; <span class="comment">//方式三</span></span><br></pre></td></tr></table></figure>

<p><strong>创建对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">firstname</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastname</span>:<span class="string">&quot;Doe&quot;</span>, <span class="attr">id</span>:<span class="number">5566</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">firstname : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">lastname  : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">id        :  <span class="number">5566</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//两种寻址方式</span></span><br><span class="line">name=person.lastname;</span><br><span class="line">name=person[<span class="string">&quot;lastname&quot;</span>];</span><br><span class="line"><span class="comment">//对象方法</span></span><br><span class="line">methodName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象方法调用</span></span><br><span class="line">objectName.methodName()</span><br><span class="line"></span><br><span class="line">objectName.methodName  <span class="comment">//返回方法定义的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>调用带参数的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;点击这个按钮，来调用带参数的函数。&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;myFunction(&#x27;Harry Potter&#x27;,&#x27;Wizard&#x27;)&quot;</span>&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">name,job</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Welcome &quot;</span> + name + <span class="string">&quot;, the &quot;</span> + job);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>带返回值的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=myFunction(<span class="number">4</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>局部变量与全局变量</strong></p>
<p>局部变量：在 JavaScript 函数内部声明的变量（使用 var）是<em>局部</em>变量，所以只能在函数内部访问它；</p>
<p>全局变量：在函数外声明的变量是<em>全局</em>变量，网页上的<strong>所有脚本和函数</strong>都能访问它。</p>
<p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>HTML 事件可以是浏览器行为，也可以是用户行为。</p>
<p>以下是 HTML 事件的实例：</p>
<ul>
<li>HTML 页面完成加载</li>
<li>HTML input 字段改变时</li>
<li>HTML 按钮被点击</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;getElementById(&#x27;demo&#x27;).innerHTML=Date()&quot;</span>&gt;现在的时间是?&lt;/button&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;点击按钮执行 &lt;em&gt;displayDate()&lt;<span class="regexp">/em&gt; 函数.&lt;/</span>p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;displayDate()&quot;</span>&gt;点这里&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayDate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>常见的HTML事件</strong></p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">浏览器已完成页面的加载</td>
</tr>
</tbody></table>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以是插入到引号中的任何字符。你可以使用单引号或双引号，可以使用索引位置来访问字符串中的每个字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carname = <span class="string">&quot;Volvo XC60&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> carname = <span class="string">&#x27;Volvo XC60&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> character = carname[<span class="number">7</span>]; <span class="comment">//索引从0开始</span></span><br></pre></td></tr></table></figure>

<p>你可以在字符串中使用引号，字符串中的引号不要与字符串的引号相同:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="string">&quot;It&#x27;s alright&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">&quot;He is called &#x27;Johnny&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">&#x27;He is called &quot;Johnny&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用内置属性 <strong>length</strong> 来计算字符串的长度：<code>var x = txt.length</code></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>基本与Java相同</p>
<p><strong>对于字符串和数字进行加法运算</strong>：两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串，如下实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span>+<span class="number">5</span>; <span class="comment">//x=10</span></span><br><span class="line">y=<span class="string">&quot;5&quot;</span>+<span class="number">5</span>; <span class="comment">//y=55</span></span><br><span class="line">z=<span class="string">&quot;Hello&quot;</span>+<span class="number">5</span>; z=Hello5</span><br></pre></td></tr></table></figure>

<p><strong>比较运算</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">===</td>
<td align="left">绝对等于（值和类型均相等）</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">!==</td>
<td align="left">不绝对等于（值和类型有一个不相等，或两个都不相等）</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于或等于</td>
</tr>
</tbody></table>
<p><strong>逻辑运算</strong></p>
<table>
<thead>
<tr>
<th align="left">算符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">and</td>
<td align="left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">or</td>
<td align="left">(x==5 || y==5) 为 false</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">not</td>
<td align="left">!(x==y) 为 true</td>
</tr>
</tbody></table>
<p><strong>条件运算</strong></p>
<p><code>variablename = (condition) ? value1 : value2 </code></p>
<h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><p>基本与Java相同</p>
<p><strong>for/in循环</strong>类似于foreach</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> person)  <span class="comment">// x 为属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeof-null和undefined"><a href="#typeof-null和undefined" class="headerlink" title="typeof,null和undefined"></a>typeof,null和undefined</h3><p><strong>typeof</strong>：检测变量的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;John&quot;</span>                <span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>                  <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>                 <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]             <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125; <span class="comment">// 返回 object</span></span><br></pre></td></tr></table></figure>

<p><strong>null</strong></p>
<p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p>
<p><strong>undefined</strong></p>
<p>在 JavaScript 中, <strong>undefined</strong> 是一个没有设置值的变量。</p>
<p><strong>undefined和null的区别</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//null 和 undefined 的值相等，但类型不等</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>             <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                  <span class="comment">// object</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h4 id="数字转为字符串"><a href="#数字转为字符串" class="headerlink" title="数字转为字符串"></a>数字转为字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>)       <span class="comment">// 将数字 123 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">100</span> + <span class="number">23</span>)  <span class="comment">// 将数字表达式转换为字符串并返回</span></span><br></pre></td></tr></table></figure>

<p>Number 方法 <strong>toString()</strong> 也是有同样的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.toString()</span><br><span class="line">(<span class="number">123</span>).toString()</span><br><span class="line">(<span class="number">100</span> + <span class="number">23</span>).toString()</span><br></pre></td></tr></table></figure>

<p>更多数字转换为字符串的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">toExponential()</td>
<td align="left">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="left">toFixed()</td>
<td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。</td>
</tr>
<tr>
<td align="left">toPrecision()</td>
<td align="left">把数字格式化为指定的长度。</td>
</tr>
</tbody></table>
<h4 id="将布尔值转换为字符串"><a href="#将布尔值转换为字符串" class="headerlink" title="将布尔值转换为字符串"></a>将布尔值转换为字符串</h4><p>同上。</p>
<h4 id="将日期转为字符串"><a href="#将日期转为字符串" class="headerlink" title="将日期转为字符串"></a>将日期转为字符串</h4><p>同上。</p>
<p>更多关于日期转换为字符串的函数：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getDate()</td>
<td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">getDay()</td>
<td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left">getFullYear()</td>
<td align="left">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">getMilliseconds()</td>
<td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getMonth()</td>
<td align="left">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getTime()</td>
<td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<h4 id="字符串转为数字"><a href="#字符串转为数字" class="headerlink" title="字符串转为数字"></a>字符串转为数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;3.14&quot;</span>)    <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot; &quot;</span>)       <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;99 88&quot;</span>)   <span class="comment">// 返回 NaN</span></span><br></pre></td></tr></table></figure>

<p>更多关于字符串转为数字的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">parseFloat()</td>
<td align="left">解析一个字符串，并返回一个浮点数。</td>
</tr>
<tr>
<td align="left">parseInt()</td>
<td align="left">解析一个字符串，并返回一个整数。</td>
</tr>
</tbody></table>
<p>…</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;正则表达式主体&#x2F;修饰符(可选)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>主要方法</strong></p>
<p>正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p><strong>search() 方法</strong> 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并<strong>返回子串的起始位置</strong>。</p>
<p><strong>replace() 方法</strong> 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Visit Runoob!&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> n = str.search(<span class="regexp">/Runoob/i</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;myFunction()&quot;</span>&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;Visit Microsoft!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML; </span><br><span class="line">    <span class="keyword">var</span> txt = str.replace(<span class="regexp">/microsoft/i</span>,<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = txt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修饰符</strong> 可以在全局搜索中不区分大小写:</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">执行多行匹配。</td>
</tr>
</tbody></table>
<p><strong>使用RegExp对象</strong></p>
<p>RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p>
<p><em>test()方法</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/e/</span>;</span><br><span class="line">patt.test(<span class="string">&quot;The best things in life are free!&quot;</span>);</span><br><span class="line">/e/.test(<span class="string">&quot;The best things in life are free!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><em>exec()方法</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/e/.exec(<span class="string">&quot;The best things in life are free!&quot;</span>); <span class="comment">//e</span></span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>try\catch\finally、throw</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;demo&quot;</span> type=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;myFunction()&quot;</span>&gt;测试输入&lt;/button&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;message&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message, x;</span><br><span class="line">    message = <span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    message.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    x = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).value;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&quot;&quot;</span>)  <span class="keyword">throw</span> <span class="string">&quot;值为空&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">&quot;不是数字&quot;</span>;</span><br><span class="line">        x = <span class="built_in">Number</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">5</span>)    <span class="keyword">throw</span> <span class="string">&quot;太小&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">10</span>)   <span class="keyword">throw</span> <span class="string">&quot;太大&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        message.innerHTML = <span class="string">&quot;错误: &quot;</span> + err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。**”hoisting(变量提升)”**</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span>; <span class="comment">// 变量 x 设置为 5</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x;                     <span class="comment">// 在元素中显示 x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x; <span class="comment">// 声明 x</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 初始化不会提升</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x + <span class="string">&quot; &quot;</span> + y;           <span class="comment">// 显示 x 和 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br></pre></td></tr></table></figure>

<p>实例 2 的 y 输出了 <strong>undefined</strong>，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。</p>
<p><strong>严格模式</strong></p>
<p><code>&quot;use strict&quot; </code>，即在严格的条件下运行，不允许使用未声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">x = &#123;<span class="attr">p1</span>:<span class="number">10</span>, <span class="attr">p2</span>:<span class="number">20</span>&#125;;      <span class="comment">// 不允许使用未声明的变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">delete</span> x;                <span class="comment">// 不允许删除变量或对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p2</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> x;                <span class="comment">// 不允许删除函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p1</span>) </span>&#123;&#125;;   <span class="comment">// 不允许变量重名</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">010</span>;             <span class="comment">// 不允许使用八进制</span></span><br></pre></td></tr></table></figure>

<p>…</p>
<p><strong>在 JavaScript 中，分号是可选的 分号是可选的,在缺少了分号就无法正确解析代码的时候，JavaScript 才会填补分号，也可以使用多行来结束一个语句。</strong></p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h2 id="JavaScript的异步编程"><a href="#JavaScript的异步编程" class="headerlink" title="JavaScript的异步编程"></a>JavaScript的异步编程</h2><p><a href="https://www.runoob.com/js/js-async.html" target="_blank">参考</a></p>
<h3 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h3><p>avascript语言的执行环境是”单线程”（single thread）。</p>
<p>所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任。</p>
<p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<p>为了解决这个问题，JavaScript 中的异步操作函数往往通过<strong>回调函数来实现异步任务的结果处理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function print() &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;RUNOOB!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(print, 3000);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&quot;./a.txt&quot;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a.txt data is : &quot;</span> + data);</span><br><span class="line">    fs.readFile(<span class="string">&quot;./b.txt&quot;</span>,<span class="function">(<span class="params">err1,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err1) <span class="keyword">throw</span> err1;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;b.txt data is : &quot;</span> + data);</span><br><span class="line">        fs.readFile(<span class="string">&quot;./c.txt&quot;</span>,<span class="function">(<span class="params">err2,data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err2) <span class="keyword">throw</span> err2;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;b.txt data is : &quot;</span> + data);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">test1</span><br><span class="line">a.txt data is : 我是a.txt</span><br><span class="line">test2</span><br><span class="line">b.txt data is : 我是b.txt</span><br><span class="line">test3</span><br><span class="line">b.txt data is : 我是c.txt</span><br><span class="line">test4</span><br></pre></td></tr></table></figure>



<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line"></span><br><span class="line">　　　　　　f1.trigger(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line"></span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line">　　f1.on(<span class="string">&#x27;done&#x27;</span>,f2);</span><br></pre></td></tr></table></figure>

<p><code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发done事件，从而开始执行f2。</p>
<h3 id="Promises对象"><a href="#Promises对象" class="headerlink" title="Promises对象"></a>Promises对象</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。</p>
<p><strong>Promise就是为了解决回调问题而提出来的，它可以把函数嵌套，改为链式调用</strong></p>
<p>假定读取A文件之后，再读取B文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, function (err, data) &#123;</span><br><span class="line">  fs.readFile(fileB, function (err, data) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName,<span class="string">&quot;utf-8&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">readFile(<span class="string">&quot;./a.txt&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="string">&quot;./b.txt&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="string">&quot;./c.txt&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>第一步，协程A开始执行。</p>
<p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p>
<p>第三步，（一段时间后）协程B交还执行权。</p>
<p>第四步，协程A恢复执行。</p>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/iterator">遍历器</a> ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。</p>
<p>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<p><strong>Generator函数的数据交换和错误处理</strong></p>
<p>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello_wolrd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;over...&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = hello_wolrd();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> hw); <span class="comment">//object</span></span><br><span class="line"><span class="keyword">let</span> hello = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line"><span class="keyword">let</span> world = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(world);</span><br><span class="line"><span class="keyword">let</span> over = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(over);</span><br><span class="line"><span class="keyword">let</span> done = hw.next();</span><br><span class="line"><span class="built_in">console</span>.log(done);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">object</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125; </span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">&#x27;world&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125; </span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">&#x27;over...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thunk函数的自动执行"><a href="#Thunk函数的自动执行" class="headerlink" title="Thunk函数的自动执行"></a>Thunk函数的自动执行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="function">(<span class="params">fileName</span>)=&gt;</span>(<span class="function">(<span class="params">callback</span>)=&gt;</span>fs.readFile(fileName,callback));</span><br><span class="line"><span class="keyword">var</span> fileA = readFileThunk(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">fileA(<span class="function">(<span class="params">err,data</span>)=&gt;</span><span class="built_in">console</span>.log(data+<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> readFileGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> AResult = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(AResult+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> BResult = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;./b.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(BResult+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> CResult = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;./c.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(CResult+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span>(result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(readFileGenerator);</span><br></pre></td></tr></table></figure>

<h3 id="Promise回调"><a href="#Promise回调" class="headerlink" title="Promise回调"></a>Promise回调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">return</span> reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFileGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&quot;./a.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&quot;./b.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f2+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> f3 = <span class="keyword">yield</span> readFile(<span class="string">&quot;./c.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f3+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> g = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">        <span class="keyword">if</span>(result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(readFileGenerator);</span><br></pre></td></tr></table></figure>

<h3 id="await和async"><a href="#await和async" class="headerlink" title="await和async"></a>await和async</h3><p>最后但是也是最重要执行异步调用的方式就是最新的async和await关键字，它们其实是Generator生成器的语法优化，区别在于：</p>
<ul>
<li>使用await和async返回的函数可以<strong>自动执行</strong></li>
<li>使用async替换原来的*，await替换原来的yield</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/18/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 22:23:54" itemprop="dateCreated datePublished" datetime="2021-03-18T22:23:54+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-19 15:30:57" itemprop="dateModified" datetime="2021-03-19T15:30:57+08:00">2021-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.runoob.com/git/git-workflow.html" target="_blank">参考</a></p>
<h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p>Git 是一个开源的<strong>分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目，是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的<strong>版本控制软件</strong>。</p>
<h2 id="Git流程"><a href="#Git流程" class="headerlink" title="Git流程"></a>Git流程</h2><p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p>下图展示了 Git 的工作流程：</p>
<p><img src="https://i.loli.net/2021/03/18/Qr1oIHlTiSg6fzB.png" alt="image.png"></p>
<h2 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h2><ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<p><img src="https://i.loli.net/2021/03/18/T13NPufdt9IxLUJ.png" alt="image.png"></p>
<h2 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h2><h3 id="方法一：创建本地仓库"><a href="#方法一：创建本地仓库" class="headerlink" title="方法一：创建本地仓库"></a>方法一：创建本地仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git init newrepo &#x2F;&#x2F;使用我们指定目录作为Git仓库</span><br></pre></td></tr></table></figure>

<p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录（<strong>隐藏目录</strong>），该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<h3 id="方法二：远程克隆"><a href="#方法二：远程克隆" class="headerlink" title="方法二：远程克隆"></a>方法二：远程克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br><span class="line">$ git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git</span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt; &#x2F;&#x2F;克隆到指定的目录</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --list  &#x2F;&#x2F;显示当前的git配置信息</span><br><span class="line">&#x2F;&#x2F;编辑git配置文件</span><br><span class="line">git config --e     #针对当前仓库</span><br><span class="line">git config --e --global  #针对系统上所有仓库</span><br><span class="line">&#x2F;&#x2F;设置提交代码时的用户信息</span><br><span class="line">$ git config --global user.name &quot;runoob&quot;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br><span class="line">&#x2F;&#x2F;去掉 --global 参数只对当前仓库有效。</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p><strong>签名的设置</strong>：</p>
<blockquote>
<p>用户名：xxx</p>
<p>邮箱：<a href="mailto:&#120;&#x78;&#x78;&#x40;&#120;&#120;&#120;&#x2e;&#x63;&#111;&#109;">&#120;&#x78;&#x78;&#x40;&#120;&#120;&#120;&#x2e;&#x63;&#111;&#109;</a></p>
</blockquote>
<p>作用：区分不同开发人员的身份</p>
<p>辨析：这里设置的签名和登录远程库的账号、密码没有任何关系</p>
<p>命令：</p>
<ul>
<li>项目级别\仓库级别：仅在当前本地库范围内有效，在<code>.git/config</code>目录下，命令为<code>git config user.name kiro</code></li>
<li>系统用户级别：登录当前操作系统的用户范围，在<code>C:Users/kiro/.gitconfig</code>，命令为<code>git config --global user.name kiro</code></li>
</ul>
<p><strong>优先级</strong>：就近原则</p>
<h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p><img src="https://i.loli.net/2021/03/18/GJsNAHwt2fqLcIn.png" alt="image.png"></p>
<p>创建仓库命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git init</code></td>
<td align="left">初始化仓库</td>
</tr>
<tr>
<td align="left"><code>git clone</code></td>
<td align="left">拷贝一份远程仓库，也就是下载一个项目。</td>
</tr>
</tbody></table>
<p>提交与修改：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git add </code></td>
<td align="left">添加文件到仓库</td>
</tr>
<tr>
<td align="left"><code>git status</code></td>
<td align="left">查看仓库当前的状态（工作区、暂存区），显示有变更的文件。</td>
</tr>
<tr>
<td align="left"><code>git diff</code>（不加文件名表示比较所有文件的不同）</td>
<td align="left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td align="left"><code>git diff [本地库中历史版本][文件名]</code></td>
<td align="left">比较与某版本的文件的不同</td>
</tr>
<tr>
<td align="left"><code>git commit -m &quot;commit message&quot; [file name]</code></td>
<td align="left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td align="left"><code>git reset</code></td>
<td align="left">回退版本。</td>
</tr>
<tr>
<td align="left"><code>git rm</code></td>
<td align="left">删除工作区文件。</td>
</tr>
<tr>
<td align="left"><code>git mv</code></td>
<td align="left">移动或重命名工作区文件。</td>
</tr>
</tbody></table>
<p>日志：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code>`git log –pretty=oneline<code>\</code>git log –oneline<code>（只显示过去）\</code>git reflog`（过去未来均显示）</td>
<td align="left">查看历史提交记录</td>
</tr>
<tr>
<td align="left"><code>git reset --hard [index]</code></td>
<td align="left">根据索引值前进后退</td>
</tr>
<tr>
<td align="left"><code>git reset --hard Head^^</code>`git reset –hard HEAD~2`</td>
<td align="left">有几个^就后退几步，只能后退</td>
</tr>
<tr>
<td align="left"><code>git blame &lt;file&gt;</code></td>
<td align="left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody></table>
<p>多屏显示控制方式：</p>
<p>空格向下翻页、b向上翻页、q退出</p>
<p><strong>reset命令的三个参数对比</strong></p>
<ul>
<li><p>–soft参数</p>
<ul>
<li>仅仅在本地库移动HEAD指针</li>
</ul>
</li>
<li><p>–mixed参数</p>
<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
</ul>
</li>
<li><p>–hard</p>
<ul>
<li>在本地库移动HEAD指针</li>
<li>重置暂存区</li>
<li>重置工作区</li>
</ul>
</li>
</ul>
<p>远程操作：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote</code></td>
<td align="left">远程仓库操作</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">从远程获取代码库</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">下载远程代码并合并</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">上传远程代码并合并</td>
</tr>
</tbody></table>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p><strong>什么是分支？</strong></p>
<p>在版本控制过程中，使用多条线同时推进多个任务。</p>
<p><strong>分支的好处</strong></p>
<ul>
<li>同时并行推进多个功能开发，提高开发效率</li>
<li>各个分支在开发过程中，若某个分支开发失败，对其他分支不产生影响</li>
</ul>
<p><strong>Git分支的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>git branch -v</code></td>
<td>查看当前分支状态</td>
</tr>
<tr>
<td><code>git branch [分支名]</code></td>
<td>常见分支</td>
</tr>
<tr>
<td><code>git branch checkout [分支名]</code></td>
<td>切换分支</td>
</tr>
<tr>
<td><code>git merge [分支名]</code></td>
<td>合并分支（<strong>需切换到被合并的分支上</strong>）</td>
</tr>
<tr>
<td><code>git branch -d [分支名]</code></td>
<td>删除分支</td>
</tr>
</tbody></table>
<h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p><img src="https://i.loli.net/2021/03/19/pPZdXRhBcvj4KI7.png" alt="image.png"></p>
<p><strong>冲突解决过程</strong>：</p>
<ul>
<li>第一步：编辑文件，删除特殊符号</li>
<li>第二步：把文件修改到满意的程度，保存退出</li>
<li>第三步：<code>git add [文件名]</code>,<code>git commit -m &quot;修改信息&quot;</code>（不能带文件名）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kiro-xu"
      src="/images/avater.jpg">
  <p class="site-author-name" itemprop="name">kiro-xu</p>
  <div class="site-description" itemprop="description">Be who you want to be</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-2 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kiro-xu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
