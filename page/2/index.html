<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be who you want to be">
<meta property="og:type" content="website">
<meta property="og:title" content="kiro的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="kiro的博客">
<meta property="og:description" content="Be who you want to be">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="kiro-xu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>kiro的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kiro的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Java并发编程（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-15 16:08:28 / 修改时间：18:47:51" itemprop="dateCreated datePublished" datetime="2021-03-15T16:08:28+08:00">2021-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>进程与线程</strong></p>
<p><em>进程</em>：视为程序的一个实例，进程是资源分配的最小单元，一个进程对应一块独立的内存、资源。</p>
<p><em>线程</em>：一个进程中可以有多个线程，最小调度单元。</p>
<p><em>对比</em>：</p>
<ul>
<li>进程相互独立，线程存在于进程中，是进程的一个子集；</li>
<li>进程是资源分配的最小单元，同一个进程内的线程资源共享；</li>
<li>进程间通信复杂（IPC、HTTP），线程通信相对简单，因为内存共享；</li>
<li>线程更轻量，其上下文切换成本一般比进程低。</li>
</ul>
<p><strong>并行与并发</strong></p>
<p><em>并发</em>：同一时间应对多件事件的能力，单核CPU在任务调度器的管理下使线程轮流使用CPU，实现“微观串行，宏观并行”的效果。</p>
<p><em>并行</em>：同一时间动手做多件事情的能力，多核CPU同时调度运行线程。</p>
<p><strong>线程的优势</strong></p>
<ul>
<li>发挥多核处理器的强大能力；</li>
<li>建模简单，每个线程只执行一种任务，不需要考虑不同任务的管理与切换；</li>
<li>异步事件的简化处理</li>
<li>友好的用户体验</li>
</ul>
<p><strong>线程的风险</strong></p>
<ul>
<li>安全问题：由于多线程共享存储空间，并发运行时，某线程可能会访问或修改其他线程正在使用的变量；</li>
<li>活跃性问题：死锁、饥饿等</li>
<li>性能问题</li>
</ul>
<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="线程的创建和运行"><a href="#线程的创建和运行" class="headerlink" title="线程的创建和运行"></a>线程的创建和运行</h2><p><strong>方法一：继承Thread</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p><strong>方法二：实现Runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精简版： Runnable runnable = ()-&gt;log.debug(&quot;hello&quot;);</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p><strong>方法三：FutureTask配合Thread</strong></p>
<p>FutureTask 能够接收 Callable 类型的参数，用来处理有<strong>返回值</strong>的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Thread(task3,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">Integer result = task.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,result);</span><br></pre></td></tr></table></figure>

<h2 id="线程运行的原理"><a href="#线程运行的原理" class="headerlink" title="线程运行的原理"></a>线程运行的原理</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">计算机网络基本知识整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-07 18:53:00" itemprop="dateCreated datePublished" datetime="2021-03-07T18:53:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-11 20:39:46" itemprop="dateModified" datetime="2021-03-11T20:39:46+08:00">2021-03-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md" target="_blank">参考1</a></p>
<p><a href="https://www.bilibili.com/video/BV1c4411d7jb" target="_blank">参考2</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>网络</strong>是由若干<strong>结点</strong>（电脑、交换机）和连接这些结点的<strong>链路</strong>组成的；</li>
<li>多个网络可以通过路由器来互联，就构成了一个更大的网络——互联网</li>
<li>因特网是世界上最大的互连网络。</li>
</ul>
<h3 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h3><ol>
<li><p>电路交换</p>
<p>电路交换用于电话通信系统。两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
</li>
<li><p>分组交换</p>
<p>每个分组都有<strong>首部和尾部</strong>，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
</li>
</ol>
<h2 id="OSI与TCP-IP各层的结构、功能、协议？"><a href="#OSI与TCP-IP各层的结构、功能、协议？" class="headerlink" title="OSI与TCP/IP各层的结构、功能、协议？"></a>OSI与TCP/IP各层的结构、功能、协议？</h2><p><img src="https://i.loli.net/2021/03/07/5npwPXiqv68ojy4.png" alt="image.png"></p>
<p>OSI理论模型：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层；</p>
<p>TCP/IP协议体系：应用层、运输层、网络层、网络接口层；</p>
<p>常用五层体系：应用层、运输层、网络层、数据链路层、物理层。</p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>计算机网络是一个非常复杂的系统，分层可以将庞大的问题转化为若干较小的问题。</p>
<p><strong>物理层</strong>：解决使用何种信号来传输比特的问题</p>
<p><strong>链路层</strong>：解决分组在一个网络（或一段链路）上的传输问题（主机标识Mac地址、比特信号分解——地址和数据、交换机）</p>
<p><strong>网络层</strong>：解决分组在多个网络上传输（路由）的问题（网络及网络中的各主机标识IP、路由器转发分组及路由选择）</p>
<p><strong>运输层</strong>：进程之间基于网络通讯的问题（进程之间进行基于网络的通信问题、传输错误的处理）</p>
<p><strong>应用层</strong>：通过应用进程间的交互来完成特定网络应用的问题（交互的格式）</p>
<p><img src="https://i.loli.net/2021/03/09/ZzKbNy7T9lkMvqn.png" alt="IOS.jpg"></p>
<hr>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>重点：</p>
<p><strong>考虑如何在连接各计算机的传输媒体上传输数据比特流</strong></p>
<p><strong>物理层为数据链路层屏蔽了各种传输媒体的差异</strong>，使数据链路层只需要考虑如何完成本层的协议和服务，而忽略具体的传输媒体是什么。</p>
<p>传输媒介：光纤、电力线、微波、红外等</p>
<p>传输方式：串行传输和并行传输、同步传输和异步传输、单向通讯、双向交替通讯和双向同时通信。</p>
<p><strong>主要设备</strong>：集线器HUB、中继器</p>
<hr>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>主要作用：帧头帧尾包含重要的控制信息（目的地址、源地址），帧定界。</p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>指数据链路层对上层交付的传输数据没有任何限制，好像链路层不存在一样。（由于链路层需要将上层交付的数据封装成帧，如何准确判断帧头帧尾就是实现透明传输的关键问题）<strong>转义字符</strong></p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><ul>
<li>奇偶校验：在待发送数据后添加1位奇偶校验码。此时若奇数个位发生错误可以检查出误码；</li>
<li>循环冗余校验CRC：约定好一个多项式，基于数据与多项式计算出差错检测码，将其添加到带传输数据末尾；<strong>广泛应用</strong></li>
</ul>
<h4 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h4><p><strong>停止-等待协议</strong></p>
<p>确认ACK与否认NAK、超时重发、分组序号</p>
<p><img src="https://i.loli.net/2021/03/08/OQXBRAfLDcWTV4x.png" alt="image.png"></p>
<p>停止等待协议的通道利用率低。</p>
<p><strong>回退帧协议</strong>（一种ARQ连续协议）</p>
<table>
<thead>
<tr>
<th>发送方</th>
<th>接收方</th>
</tr>
</thead>
<tbody><tr>
<td>发送窗口尺寸范围：1~2^n-1，n位构成分组序号的比特数量</td>
<td>接收窗口尺寸为1，只能<strong>按序</strong>接收数据分组</td>
</tr>
<tr>
<td>发送方可以在未收到确认信号的情况下，将在发送窗口的多个分组全部发送</td>
<td>只接受序号落在接收窗口内且无误码的数据分组</td>
</tr>
<tr>
<td>只有在收到确认信号后，窗口才能滑动</td>
<td>可以在连续收到好几个按序到达且无误码的数据分组后，才对最后一个数据分组发送确认分组，即累积确认</td>
</tr>
<tr>
<td>收到多个重复确认时，可在计时器超时前提前重传</td>
<td>或者在自己有数据分组要发送时才进行捎带确认</td>
</tr>
<tr>
<td>发送窗口内某个已发送数据分组超时重发时，其后续在发送窗口内且已发送的分组也必须重传</td>
<td>收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据进行确认</td>
</tr>
</tbody></table>
<p><strong>当通信线路质量不好时，其通道利用率并不比停止-等待协议高</strong></p>
<p><strong>选择重传</strong></p>
<p>与回退N帧协议的区别：</p>
<ul>
<li>发送窗口尺寸范围为1~2^(n-1)，接收窗口尺寸与发送窗口相同；</li>
<li>不能进行累积确认，必须逐一确认</li>
<li>只有按序收到已发送分组的确认时窗口才能滑动，否则是对未按序到达的分组进行记录，防止超时重发。</li>
</ul>
<p><strong>PPP协议</strong></p>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<p><strong>CSMA/CD协议</strong></p>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p><strong>MAC地址</strong></p>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<h4 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h4><table>
<thead>
<tr>
<th>集线器HUB</th>
<th>交换机SWITCH</th>
</tr>
</thead>
<tbody><tr>
<td>早期的以太网的互联设备</td>
<td>目前以太网使用最广泛的互联设备</td>
</tr>
<tr>
<td>工作在物理层，没有容错检测等功能</td>
<td>工作在数据链路层</td>
</tr>
<tr>
<td>对接收到的信号进行放大、转发</td>
<td>根据MAC地址对帧进行转发，且可以根据MAC地址过滤帧，即隔离碰撞</td>
</tr>
<tr>
<td>使用集线器作为互连设备仍属于共享总线式以太网，所有主机属于同一个碰撞域和广播域</td>
<td>交换机的每个接口是一个独立的碰撞域</td>
</tr>
</tbody></table>
<h4 id="局域网、以太网、虚拟局域网"><a href="#局域网、以太网、虚拟局域网" class="headerlink" title="局域网、以太网、虚拟局域网"></a>局域网、以太网、虚拟局域网</h4><p><strong>局域网</strong></p>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。<strong>一个广播域</strong></p>
<p><strong>以太网</strong></p>
<p>以太网是一种星型拓扑结构局域网。早期用集线器连接，现广泛使用<strong>用交换机连接</strong>。</p>
<p><strong>虚拟局域网VLAN</strong></p>
<p>巨大的广播域会导致许多弊端：广播风暴、难以管理和维护、潜在的安全问题 ==&gt; 利用802.1Q帧格式建立虚拟局域网：将局域网内的设备划分成与物理位置无关的逻辑组的技术。</p>
<hr>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>主要任务：实现网络互联，进而实现数据包在各网络之间的传输。</p>
<p>主要解决以下问题：</p>
<ul>
<li>网络层向运输层提供什么服务？可靠传输还是不可靠传输</li>
<li>网络层寻址问题</li>
<li>网络层路由选择问题</li>
</ul>
<h4 id="地址解析ARP"><a href="#地址解析ARP" class="headerlink" title="地址解析ARP"></a>地址解析ARP</h4><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<p>ARP工作原理：</p>
<ul>
<li>每个主机都有一个 ARP <strong>高速缓存</strong>，里面有<strong>本局域网</strong>上的各主机和路由器的 IP 地址到 MAC 地址的<strong>映射表</strong>。</li>
<li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过<strong>广播</strong>的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li>
</ul>
<h4 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h4><p><strong>主机发送IP数据报</strong></p>
<p>判断目的主机是否与自己在同一个网络（目的地址与子网掩码相与）：</p>
<ul>
<li>若在同一个网络，直接交付，通过交换机；</li>
<li>若不在同一个网络，间接交付，传输给主机所在的默认网关，由默认网关帮忙转发</li>
</ul>
<p><strong>路由器转发IP数据报</strong></p>
<ul>
<li>检查IP数据报首部是否出错，出错则丢弃并通告源主机，否则转发</li>
<li>检查IP数据报的目的地址，在路由器中查找匹配的条目</li>
</ul>
<h4 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h4><ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<hr>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。</p>
<p>运输层的主要协议：</p>
<ul>
<li>传输控制协议TCP（Transmission Control Protocol）–<strong>面向连接、可靠的数据传输</strong></li>
<li>用户数据协议UDP（User Datagram Protocol）–<strong>提供无连接的，尽最大努力的数据传输服务，不保证数据传输的可靠性</strong> </li>
</ul>
<h4 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h4><p>三次握手：</p>
<img src="https://i.loli.net/2021/03/07/TlzeNp6kCQK59At.png" alt="image.png" style="zoom:67%;" />

<p>第一次握手：服务器确定对方发送正常、自己接受正常；</p>
<p>第二次握手：客户端确定自己发送、接收正常，对方发送接收正常；服务器确定对方发送正常、自己接收正常；</p>
<p>第三次握手：客户端确定自己发送、接收正常，对方发送、接收正常；服务器确定自己发送、接收正常，对方发送、接收正常。</p>
<p><strong>第2次握手传回了ACK，为什么还要传回SYN？</strong></p>
<p>ACK标识只表明服务端接收到了请求信号，通信是正常的，并不能完全保证数据传输可以实现完整可靠传输，传回第一次握手的SYN可以由客户端确认数据传输可靠。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="https://i.loli.net/2021/03/07/eVmJrkl56F3Txi9.png" alt="image.png" style="zoom: 67%;" />

<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p><strong>四次可以确保数据传输完成、完整</strong></p>
<h4 id="TCP和UDP协议的区别"><a href="#TCP和UDP协议的区别" class="headerlink" title="TCP和UDP协议的区别"></a>TCP和UDP协议的区别</h4><p><img src="https://i.loli.net/2021/03/07/g8aeL9yrc1l5phz.png" alt="image.png"></p>
<h4 id="TCP如何保证传输的可靠性？"><a href="#TCP如何保证传输的可靠性？" class="headerlink" title="TCP如何保证传输的可靠性？"></a>TCP如何保证传输的可靠性？</h4><ol>
<li>应用数据会被分割成TCP认为最合适发送的数据块；</li>
<li>TCP会给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传给应用层。</li>
<li><strong>校验和</strong>：</li>
</ol>
<hr>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是<strong>应用进程</strong>（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<h4 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h4><p>它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p><strong>请求报文结构</strong></p>
<ul>
<li>请求行，包含请求方法、URL、协议版本；</li>
<li>请求头，每个首部都有一个首部名称，以及对应的值；</li>
<li>空行</li>
<li>数据包，请求内容的主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.example.com&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br></pre></td></tr></table></figure>

<p><strong>响应报文结构</strong></p>
<ul>
<li>协议版本、状态码及描述；</li>
<li>首部内容；</li>
<li>空行；</li>
<li>数据包，响应内容主体。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age&#x3D;604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc&#x2F;16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;&#x2F;title&gt;</span><br><span class="line">	&#x2F;&#x2F; 省略... </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>HTTP方法</strong></p>
<p>GET、HEAD（和 GET 方法类似，但是不返回报文实体主体部分）、POST、PUT（上传文件）、PATCH（对资源进行部分修改）、DELETE（删除文件）、OPTIONS（查询指定URL支持的方法）、CONNECT（要求在与代理服务器通信时建立隧道）、TRACE。</p>
<p><strong>HTTP状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息性状态码</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/JVM%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/JVM%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">JVM重点知识整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 17:30:16" itemprop="dateCreated datePublished" datetime="2021-02-28T17:30:16+08:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-01 20:38:55" itemprop="dateModified" datetime="2021-03-01T20:38:55+08:00">2021-03-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a herf="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank">参考1</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md" target="_blank">参考2</a></p>
<blockquote>
<p>对于Java，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
</blockquote>
<h2 id="1-JVM的位置"><a href="#1-JVM的位置" class="headerlink" title="1 JVM的位置"></a>1 JVM的位置</h2><p><img src="https://i.loli.net/2021/02/28/ILUgZ68zYedipDJ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/28/qjso7LWkE5uNx2A.png" alt="image.png"></p>
<h2 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2 类加载机制"></a>2 类加载机制</h2><p>类是在运行期间<strong>第一次使用时</strong>动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<p><strong>类的生命周期</strong></p>
<p><img src="https://i.loli.net/2021/02/28/nFLrI4wVNMSDAcX.png" alt="image.png"></p>
<h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<h2 id="3-运行时数据区域"><a href="#3-运行时数据区域" class="headerlink" title="3 运行时数据区域"></a>3 运行时数据区域</h2><p><img src="https://i.loli.net/2021/02/28/4lhBxuZ7aFV8ITo.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/28/xJ6Z8jaXRBPTcgY.png" alt="image.png"></p>
<h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p><strong>当前线程所执行的字节码的行号指示器</strong>。</p>
<p>从上面的介绍中我们知道程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。（<strong>每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，即线程私有</strong>）</li>
</ol>
<p>它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><h2 id="Java编译程序和运行过程详解"><a href="#Java编译程序和运行过程详解" class="headerlink" title="Java编译程序和运行过程详解"></a>Java编译程序和运行过程详解</h2><p><a href="https://www.cnblogs.com/superyc/p/9987793.html" target="_blank">参考</a></p>
<p>Java程序从源文件创建到程序运行要经过两大步骤：</p>
<ol>
<li>Java文件会由编译器<strong>编译成class文件</strong>（字节码文件），会经过编译原理简单过程的前三步；</li>
<li>字节码由java虚拟机解释运行，解释执行即为目标代码生成并执行。因为java程序既要编译的同时也要经过JVM的解释运行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal &#x3D; new Animal(&quot;Tom&quot;);</span><br><span class="line">        animal.printName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Animal&#123;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void printName()&#123;</span><br><span class="line">        System.out.println(&quot;Animal &#x3D; &quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（八）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:09:25 / 修改时间：17:10:19" itemprop="dateCreated datePublished" datetime="2021-02-28T17:09:25+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="贪心算法和最小生成树"><a href="#贪心算法和最小生成树" class="headerlink" title="贪心算法和最小生成树"></a>贪心算法和最小生成树</h1><p>又可称偏心算法：先将要求高的满足，再满足要求低的。</p>
<h2 id="图论回顾"><a href="#图论回顾" class="headerlink" title="图论回顾"></a>图论回顾</h2><p>Digragh(有向图，Direct Gragh) </p>
<p>Undirected Gragh : G = (V, E), the edge set E consists of unordered pairs of vertices.</p>
<p>In either case, we have <strong>|E| = O(V^2)</strong>. Moreover, if G is connected(连通图), then <strong>|E| ≥ |V| – 1</strong>, which implies that <strong>lg |E| = Θ(lgV)</strong>. </p>
<h3 id="Adjacency-matrix-representation（邻接矩阵表示法）"><a href="#Adjacency-matrix-representation（邻接矩阵表示法）" class="headerlink" title="Adjacency-matrix representation（邻接矩阵表示法）"></a>Adjacency-matrix representation（邻接矩阵表示法）</h3><p>The adjacency matrix of a graph G = (V, E), where V = {1, 2, …, n}, is the matrix A[1 . . n, 1 . . n] given by：</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/5d4357ea9df7d304dc7f52c8686f1723.svg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608798696801-17933b85-e281-4aad-a51b-df57834b7c8c.png" alt="image.png"></p>
<p><strong>该表示方法需要的存储空间为：</strong><img src="https://cdn.nlark.com/yuque/__latex/c0e4ef8d0c23513de13cacd3a809e240.svg" alt="img"></p>
<h3 id="Adjacency-list-representation（邻接表表示法）"><a href="#Adjacency-list-representation（邻接表表示法）" class="headerlink" title="Adjacency-list representation（邻接表表示法）"></a>Adjacency-list representation（邻接表表示法）</h3><p>An adjacency list of a vertex v ∈ V is the list Adj[v] of vertices adjacent to v.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608798812866-bbc6b590-4583-4235-8707-e0556f85d7a3.png" alt="image.png"></p>
<p>For undirected graphs, <strong>|Adj[v]| = degree(v)</strong>.</p>
<p>For digraphs, <strong>|Adj[v]| = out-degree(v)</strong>.</p>
<p><strong>Handshaking Lemma:</strong></p>
<p><img src="https://cdn.nlark.com/yuque/__latex/8ae10bb61baf43fb0315e0d0e1723722.svg" alt="img">  for undirected graphs ⇒ adjacency lists use <strong>Θ(V + E) storage</strong> — a <strong>sparse</strong> representation (for either type of graph).</p>
<h2 id="Minimum-Spanning-Trees（最小生成树）"><a href="#Minimum-Spanning-Trees（最小生成树）" class="headerlink" title="Minimum Spanning Trees（最小生成树）"></a>Minimum Spanning Trees（最小生成树）</h2><p><strong>Input</strong>: A <strong>connected, undirected graph</strong> G = (V, E) with weight function w : E → R. </p>
<ul>
<li> For simplicity, assume that all edge weights are distinct. (CLRS covers the general case.)</li>
</ul>
<p><strong>Output:</strong> A spanning tree T — a tree that connects all vertices — of minimum weight:</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/bfeb9c51c8c6c276ff467de232055f3d.svg" alt="img"></p>
<p>**<br>**</p>
<p><strong>An Example of MST</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799270562-8475bbc6-1fa5-43d8-acb1-3a772058a15c.png" alt="image.png"></p>
<h3 id="Optimal-substructure（最优子结构）"><a href="#Optimal-substructure（最优子结构）" class="headerlink" title="Optimal substructure（最优子结构）"></a>Optimal substructure（最优子结构）</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799463185-839e2aa0-e522-4f40-88d4-dc5340bd5d37.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799492463-2d950e9a-bc4f-4e8c-b42a-ad8afcac774e.png" alt="image.png"></p>
<p>Remove any edge Remove any edge (u, v) ∈ T. Then, . T is partitioned into two subtrees T1 and T2.</p>
<p><strong>Theotem：</strong></p>
<p>The subtree T1 is an MST of G1 = (V1, E1), the subgraph of G induced by the vertices of T1:</p>
<p>V1 = vertices of T1,</p>
<p>E1 = { (x, y) ∈ E : x, y ∈ V1 }</p>
<p>Similarly for T2.</p>
<p><strong>Proof：</strong></p>
<p><strong>Cut and paste</strong>: If T1′ were a lower-weight spanning tree than T1 for G1, </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/6b897148c96d5b9f6a88a7747003fd78.svg" alt="img"></p>
<p>then T′ = {(u, v)} ∪ T1′ ∪ T2 would be a lower-weight spanning tree than T for G. <strong>Wrong</strong></p>
<h3 id="overlapping-subproblems"><a href="#overlapping-subproblems" class="headerlink" title="overlapping subproblems"></a>overlapping subproblems</h3><p>hava overlapping subproblems too.</p>
<p><strong>dynamic programming may work</strong></p>
<p>but MST exhibits another powerful property which leads to an even more efficient algorithm.</p>
<h3 id="Hallmark-for-“greedy”-algorithms"><a href="#Hallmark-for-“greedy”-algorithms" class="headerlink" title="Hallmark for “greedy” algorithms"></a>Hallmark for “greedy” algorithms</h3><p><strong>Greedy-choice property A locally optimal choice is globally optimal.</strong></p>
<p>局部最优解即为全局最优解</p>
<p><strong>Theorem.</strong></p>
<p>Let T be the MST of G = (V, E), and let A ⊆ V. Suppose that (u, v) ∈ E is the least-weight edge connecting A to V – A. Then, (u, v) ∈ T.</p>
<p><strong>Proof：</strong></p>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799858055-0446731d-4e07-4f37-8a35-700882c06739.png" alt="image.png"></strong></p>
<p>Consider the unique simple path from u to v in T. Swap (u, v) with the first edge on this path that connects a vertex in A to a vertex in V – A.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799918278-5e71bc73-8caf-4196-a1a3-eec5ee1208ed.png" alt="image.png"></p>
<h3 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h3><p><strong>IDEA:</strong> Maintain V – A as a <strong>priority queue Q</strong>. Key each vertex in Q with the weight of the leastweight edge connecting it to a vertex in A.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Q&lt;-V(all)</span><br><span class="line">key[v] &lt;- 无穷 for all v ∈ V</span><br><span class="line">key[s] &lt;- 0 for some arbitrary s ∈ V</span><br><span class="line">while Q!&#x3D;null</span><br><span class="line">    do u &lt;- EXTRACT-MIN(Q)</span><br><span class="line">  for each v∈Adj[u]</span><br><span class="line">    do if v∈Q and w(u, v) &lt; key[v]</span><br><span class="line">            then key[v] ← w(u, v)</span><br><span class="line">            π[v] ← u</span><br><span class="line">At the end, &#123;(v, π[v])&#125; forms the MST</span><br></pre></td></tr></table></figure>

<p><strong>Analysis:</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608800270592-5a91ed5d-cc64-42e0-8607-e8bb1bbc172c.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/__latex/c579d84275b9876478a1164fccb8eb2a.svg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608800367455-d48c2f1a-5974-41e8-8268-edb1ef82e67c.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（七）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:07:29 / 修改时间：17:09:01" itemprop="dateCreated datePublished" datetime="2021-02-28T17:07:29+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dynamic-Programming-Longest-Common-Subsequence-动态规划，最长相同子序列"><a href="#Dynamic-Programming-Longest-Common-Subsequence-动态规划，最长相同子序列" class="headerlink" title="Dynamic Programming, Longest Common Subsequence(动态规划，最长相同子序列)"></a>Dynamic Programming, Longest Common Subsequence(动态规划，最长相同子序列)</h1><p>Design technique, like divide-and-conquer.</p>
<h2 id="Example-Longest-Common-Subsequence-LCS"><a href="#Example-Longest-Common-Subsequence-LCS" class="headerlink" title="Example: Longest Common Subsequence (LCS)"></a>Example: Longest Common Subsequence (LCS)</h2><p>Given two sequences x[1 . . m] and y[1 . . n], find <strong>a</strong>  longest subsequence common to them both.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607664315488-663bfed8-4c02-4d27-ac67-f084a8a26296.png" alt="image.png"></p>
<h3 id="Bruce-Force-algorithm"><a href="#Bruce-Force-algorithm" class="headerlink" title="Bruce-Force algorithm"></a>Bruce-Force algorithm</h3><p><strong>Check</strong>  every <strong>subsequence</strong>  of x[1 . . m] to see if it is also a subsequence of y[1 . . n].</p>
<p><strong>Analysis</strong> </p>
<ul>
<li>Checking = O(n) time per subsequence.</li>
<li>2^m subsequences of x (each bit-vector of length m determines a distinct subsequence of x).</li>
<li>So, Worst-case running time = O(n2^m) = exponential time. <strong>Slow!</strong> </li>
</ul>
<h3 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h3><ol>
<li>Look at the length of a longest-common subsequence.</li>
<li>Extend the algorithm to find the LCS itself.</li>
</ol>
<p><strong>Notation</strong> : Denote the length of a sequence s by |s|.</p>
<p><strong>Strategy</strong> : Consider <strong>prefixes</strong>  of x and y.</p>
<p><strong>Define:</strong> c[i, j] = | LCS(x[1 . . i], y[1 . . j])|. 最长子序列长度</p>
<p>那么可知，c[m,n] = |LCS(x,y)|</p>
<p><strong>Theorem.</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/b1bb05baea482e6d80396d5c32b90f41.svg" alt="img"></p>
<p><strong>证明略</strong> </p>
<h3 id="Dynamic-programming-hallmark-1"><a href="#Dynamic-programming-hallmark-1" class="headerlink" title="Dynamic-programming hallmark #1"></a>Dynamic-programming hallmark #1</h3><p>Optimal substructure ：An optimal solution to a problem (instance) contains optimal solutions to subproblems。</p>
<p>动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Recursion algorithm for LCS</span><br><span class="line">    if x[i]&#x3D;y[j]</span><br><span class="line">    then c[i,j]&#x3D;LCS(c[i-1,j-1])+1</span><br><span class="line">  else</span><br><span class="line">    c[i,j] &#x3D; max&#123;LCS(i,j-1),LCS(i-1,j)&#125;;</span><br><span class="line">  return c[i,j]</span><br></pre></td></tr></table></figure>

<p>Worst-case: x[i]!=y[j], 对任意i，j。in which case the algorithm evaluates two subproblems, each with only one parameter decremented.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607665733966-d9db75bc-ae0d-4999-869a-cb4440a6b969.png" alt="image.png"></p>
<p><strong>Height = m + n</strong>  ⇒ work potentially exponential。but we’re solving subproblems already solved!</p>
<h3 id="Dynamic-programming-hallmark-2"><a href="#Dynamic-programming-hallmark-2" class="headerlink" title="Dynamic-programming hallmark #2"></a>Dynamic-programming hallmark #2</h3><p>Overlapping subproblems A recursive solution contains a “small” number of distinct subproblems repeated many times.</p>
<p>The number of distinct LCS subproblems for two strings of lengths m and n is only mn.</p>
<p><strong>Memoization algorithm</strong> </p>
<p>Memoization: After computing a solution to a subproblem, store it in a table. Subsequent calls check the table to avoid redoing work.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Memoization Algorithm</span><br><span class="line">    c[i,j]&#x3D;LCS(x,y,i,j)</span><br><span class="line">  if c[i,j]&#x3D;nil</span><br><span class="line">    then if x[i]&#x3D;y[j]</span><br><span class="line">                then c[i,j] &#x3D; LCS(x,ymi-1,j-1)+1</span><br><span class="line">        else </span><br><span class="line">            c[i,j] &#x3D; max&#123;LCS(i,j-1),LCS(i-1,j)&#125;</span><br><span class="line">   return c[i,j];</span><br></pre></td></tr></table></figure>

<p><strong>Time</strong>  = Θ(mn) = constant work per table entry. </p>
<p><strong>Space</strong>  = Θ(mn).</p>
<h3 id="Dynamic-programming-algorithm"><a href="#Dynamic-programming-algorithm" class="headerlink" title="Dynamic-programming algorithm"></a>Dynamic-programming algorithm</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607666136741-e15b79c5-9bdb-4bde-a236-9841b7cea989.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LCS-LENGTH(X,Y)</span><br><span class="line">m &#x3D; length[X]</span><br><span class="line">n &#x3D; length[Y]</span><br><span class="line">for i&#x3D;1 to m</span><br><span class="line">    do c[i,0] &#x3D; 0</span><br><span class="line">for j&#x3D;0 to n</span><br><span class="line">    fo c[0,j] &#x3D; 0</span><br><span class="line">for i&#x3D;1 to n</span><br><span class="line">    do for j&#x3D;1 to n</span><br><span class="line">    do if x[i] &#x3D; y[j]</span><br><span class="line">        then c[i,j] &#x3D; c[i-1,j-1]+1</span><br><span class="line">    else if c[i-1,j] &gt;&#x3D; c[i,j-1]</span><br><span class="line">      then c[i,j] &#x3D; c[i-1,j]</span><br><span class="line">      else c[i,j] &#x3D; c[i,j-1]</span><br><span class="line">return c</span><br></pre></td></tr></table></figure>

<p><strong>Time = Θ(mn)</strong> .</p>
<p>Reconstruct LCS by <strong>tracing backwards</strong> .</p>
<ul>
<li><strong>Space = Θ (mn )</strong> .</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>分治算法是指将问题划分成一些 <strong>独立</strong> 的子问题，递归求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题 <strong>不是独立</strong> 的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子子问题。</p>
<p>动态规划算法对每个子子问题只求解一次，将其结果保存在一张表种，从而避免每次遇到各子问题时重新计算答案。</p>
<p>动态规划通常应用于 <strong>最优化问题</strong> 。此类问题可能有很多种可行解。每个解有一个值，而我们希望找出一个具有最优（最大或最小）值的解。称这样的解为该问题的 <strong>一个</strong> 最优解（而不是确定的最优解），因为可能存在多个取最优值的解。</p>
<p>动态规划算法的设计可以分为以下四步：</p>
<ol>
<li>描述最优解的结构i</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算出的结果构造一个最优解</li>
</ol>
<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h3><p><strong>题目描述</strong> </p>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p><strong>示例</strong> </p>
<p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3</p>
<p>输出：4</p>
<p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。</p>
<p>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p>
<p><strong>思路</strong> </p>
<p>第一步，要明确两点，[状态]和[选择]。</p>
<p>状态有三个， [背包对1的容量]、[背包对0的容量]和 [可选择的字符串]；选择就是把字符串[装进背包]或者[不装进背包]。</p>
<p>第二步，要明确dp数组的定义：</p>
<p>首先，[状态]有三个，所以需要一个三维的dp数组。dp[i][j][k]的定义如下：若只使用前i个物品，当背包容量为j个0，k个1时，能够容纳的最多字符串数。</p>
<p>第三步，根据选择，思考状态转移的逻辑：</p>
<p>注意，这是一个0-1背包问题，每个字符串只有一个选择机会，要么选择装，要么选择不装。</p>
<p><strong>如果你不能把这第 i 个物品装入背包</strong> （等同于容量不足，装不下去），也就是说你不使用strs[i]这一个字符串，那么当前的字符串数dp[i][j][k]应该等于dp[i - 1][j][k], <strong>继承</strong> 之前的结果。</p>
<p><strong>如果你可以把这第 i 个物品装入了背包</strong> (此时背包容量是充足的，因此要选择装或者不装)，也就是说你能使用 strs[i] 这个字符串，那么 dp[i][j] 应该等于 Max(dp[i - 1][j][k], dp[i - 1][j - cnt[0]][k - cnt[1]] + 1)。 Max函数里的两个式子，分别是装和不装strs[i的字符串数量。(cnt 是根据strs[i]计算出来的。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line">        int len &#x3D; strs.length;</span><br><span class="line">        int[][][] dp &#x3D;new int[len+1][m+1][n+1];</span><br><span class="line">        for(int i&#x3D;1; i&lt;&#x3D;len; i++)&#123;</span><br><span class="line">            String s &#x3D; strs[i-1];</span><br><span class="line">            int zeronum &#x3D; countzero(s);</span><br><span class="line">            int onenum &#x3D; s.length()-zeronum;</span><br><span class="line">            for(int j&#x3D;0; j&lt;m+1; j++)&#123;</span><br><span class="line">                for(int k&#x3D;0; k&lt;n+1; k++)&#123;</span><br><span class="line">                    dp[i][j][k]  &#x3D; dp[i-1][j][k];</span><br><span class="line">                    if(j&gt;&#x3D;zeronum &amp;&amp; k&gt;&#x3D;onenum)&#123;</span><br><span class="line">                        dp[i][j][k] &#x3D; Math.max(dp[i-1][j][k],dp[i-1][j-zeronum][k-onenum]+1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    public int countzero(String s)&#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for(int i&#x3D;0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(s.charAt(i)&#x3D;&#x3D;&#39;0&#39;)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:06:13 / 修改时间：17:07:06" itemprop="dateCreated datePublished" datetime="2021-02-28T17:06:13+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Skip-Lists-跳跃表（Pugh，1989）"><a href="#Skip-Lists-跳跃表（Pugh，1989）" class="headerlink" title="Skip Lists 跳跃表（Pugh，1989）"></a>Skip Lists 跳跃表（Pugh，1989）</h1><p>a <strong>simple, randomized, efficient</strong> dynamic search structrue</p>
<p>Maintains a dynamic set of n elements in <strong>O(lgn)</strong> time per operation in expectation an  <strong>with high probability</strong> (w.h.p)”almost always”</p>
<h2 id="one-linked-list"><a href="#one-linked-list" class="headerlink" title="one linked list"></a>one linked list</h2><p>Start from simplest data structure: <strong>(sort) linked list</strong> </p>
<ul>
<li>Searches take <strong>O(n) time in worst case</strong></li>
<li>How can we speed up searches?</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607435349427-5c0be976-bff3-4230-b4c3-8eafcb35879c.png" alt="image.png"></p>
<h2 id="Two-linked-lists"><a href="#Two-linked-lists" class="headerlink" title="Two linked lists"></a>Two linked lists</h2><p>Suppose we had two sorted linked lists (on subsets of the elements).</p>
<ul>
<li>Each element can appear in one or both lists</li>
<li>How can we speed up searches?</li>
</ul>
<p><strong>IDEA</strong> : 类似客车的快线与慢线</p>
<ul>
<li>Express line connects a few of the stations</li>
<li>Local line connects all stations</li>
<li>Links between lines at common stations</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607435637348-02714b61-fede-4d6c-8a0b-a887fbca512a.png" alt="image.png"></p>
<h3 id="Searching-in-two-linked-lists"><a href="#Searching-in-two-linked-lists" class="headerlink" title="Searching in two linked lists"></a>Searching in two linked lists</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEARCH(x)</span><br><span class="line">    Walk right in top linked list(L1) until going right would go too far</span><br><span class="line">  Walk down to bottom linked list(L2)</span><br><span class="line">  Walk right in L2 until element found(or not)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607435834020-bf9ee095-c95c-40ef-af74-30061278bed0.png" alt="image.png"></p>
<p><strong>Question</strong> : Which nodes should be in L1?</p>
<ul>
<li>In a subway, the “Popular stations”</li>
<li>Here we care about worst-case performance</li>
<li><strong>Best approach</strong> : Evenly space the nodes in L1</li>
<li>But how many nodes should be in L1</li>
</ul>
<p><strong>Analysis</strong> </p>
<p>Search cost is roughly <strong>|L1|+|L2|/|L1|</strong> </p>
<p>Minimized(up to constant factors) when terms are equal: <img src="https://cdn.nlark.com/yuque/__latex/8b9b4bcee9ff40263ae229e873e98cd7.svg" alt="img">, and Search cost is roughly <img src="https://cdn.nlark.com/yuque/__latex/c1fbe26c9914fdbeb3c992b9b72c91e4.svg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607436391944-660662f0-f936-404b-9dbd-fed4bc2fdfbe.png" alt="image.png"></p>
<h2 id="More-linked-lists"><a href="#More-linked-lists" class="headerlink" title="More linked lists"></a>More linked lists</h2><p>What if we had more sorted linked lists?</p>
<ul>
<li>2 sorted lists <img src="https://cdn.nlark.com/yuque/__latex/5c178e70690758153ae450d69509e497.svg" alt="img"></li>
<li>3 sorted lists <img src="https://cdn.nlark.com/yuque/__latex/29ec5a303e64980341f3011343ac63f1.svg" alt="img"></li>
<li>k sorted lists <img src="https://cdn.nlark.com/yuque/__latex/4b398932c7d4408df795ced985a3b13e.svg" alt="img"></li>
<li>lgn sorted lists <img src="https://cdn.nlark.com/yuque/__latex/f06c5d0a7973de0894d7a1b3f08a1e28.svg" alt="img"></li>
</ul>
<p>lgn sorted linked lists are like a <strong>binary tree</strong> .</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607436699061-2785b69b-65b9-4c9a-b2de-1c163ae1da9d.png" alt="image.png"></p>
<h3 id="insert-x-and-delete-x"><a href="#insert-x-and-delete-x" class="headerlink" title="insert(x) and delete(x)"></a>insert(x) and delete(x)</h3><p><strong>Skip list data structure</strong>  maintains roughly this structure subject to updates (insert/delete)</p>
<p>To insert an element x into a skip list:</p>
<ul>
<li>SEARCH(x) to see where x fits in bottom list</li>
<li>Always insert into bottom list</li>
</ul>
<p><strong>INVARIANT</strong> : Bottom list contains all elements , insert into some of the lists above…</p>
<p><strong>QUESTION</strong> : To which other lists should we add x?</p>
<p><strong>IDEA</strong> : <strong>Flip a (fair) coin</strong> ; if HEADS, promote x to next level up and flip again</p>
<p>Probability of promotion to next level = 1/2</p>
<p><strong>Small changes</strong> : Add special −∞ value to every list ⇒ can search with the same algorithm</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607437031127-ae9d874a-aed2-40d0-a9b0-598b994c7b89.png" alt="image.png"></p>
<h3 id="How-good-are-skip-lists-speed-balance"><a href="#How-good-are-skip-lists-speed-balance" class="headerlink" title="How good are skip lists? (speed/balance)"></a>How good are skip lists? (speed/balance)</h3><p><strong>INTUITIVELY</strong> : Pretty good on average</p>
<p><strong>CLAIM</strong> : Really, really good, almost always</p>
<p><strong>THEOREM</strong> : <em>With high probability</em>, every search in an n-element skip list costs <strong>O(lgn)</strong></p>
<p>证明略</p>
<p><strong>LEMMA</strong> : <em>With high probability</em>, n-element skip list has <strong>O(lgn)</strong> levels</p>
<p>证明略</p>
<p><strong>CLAIM</strong> : Number of coin flips until <strong>c lgn</strong> HEADs = <strong>Θ(lgn)</strong> <em>with high probability</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************  SkipList.java  *********************&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class SkipList&lt;T extends Comparable&lt;? super T&gt;&gt; &#123;</span><br><span class="line">    private int maxLevel;</span><br><span class="line">    private SkipListNode&lt;T&gt;[] root;</span><br><span class="line">    private int[] powers;</span><br><span class="line">    private Random rd &#x3D; new Random();</span><br><span class="line">    SkipList() &#123;</span><br><span class="line">        this(4);</span><br><span class="line">    &#125;</span><br><span class="line">    SkipList(int i) &#123;</span><br><span class="line">        maxLevel &#x3D; i;</span><br><span class="line">        root &#x3D; new SkipListNode[maxLevel];</span><br><span class="line">        powers &#x3D; new int[maxLevel];</span><br><span class="line">        for (int j &#x3D; 0; j &lt; maxLevel; j++)</span><br><span class="line">            root[j] &#x3D; null;</span><br><span class="line">        choosePowers();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return root[0] &#x3D;&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void choosePowers() &#123;</span><br><span class="line">        powers[maxLevel-1] &#x3D; (2 &lt;&lt; (maxLevel-1)) - 1;    &#x2F;&#x2F; 2^maxLevel - 1</span><br><span class="line">        for (int i &#x3D; maxLevel - 2, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)</span><br><span class="line">           powers[i] &#x3D; powers[i+1] - (2 &lt;&lt; j);           &#x2F;&#x2F; 2^(j+1)</span><br><span class="line">    &#125;</span><br><span class="line">    public int chooseLevel() &#123;</span><br><span class="line">        int i, r &#x3D; Math.abs(rd.nextInt()) % powers[maxLevel-1] + 1;</span><br><span class="line">        for (i &#x3D; 1; i &lt; maxLevel; i++)</span><br><span class="line">            if (r &lt; powers[i])</span><br><span class="line">                return i-1; &#x2F;&#x2F; return a level &lt; the highest level;</span><br><span class="line">        return i-1;         &#x2F;&#x2F; return the highest level;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; make sure (with isEmpty()) that search() is called for a nonempty list;</span><br><span class="line">    public T search(T key) &#123;</span><br><span class="line">        int lvl;</span><br><span class="line">        SkipListNode&lt;T&gt; prev, curr;            &#x2F;&#x2F; find the highest nonnull</span><br><span class="line">        for (lvl &#x3D; maxLevel-1; lvl &gt;&#x3D; 0 &amp;&amp; root[lvl] &#x3D;&#x3D; null; lvl--); &#x2F;&#x2F; level;</span><br><span class="line">        prev &#x3D; curr &#x3D; root[lvl];</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (key.equals(curr.key))          &#x2F;&#x2F; success if equal;</span><br><span class="line">                 return curr.key;</span><br><span class="line">            else if (key.compareTo(curr.key) &lt; 0) &#123; &#x2F;&#x2F; if smaller, go down,</span><br><span class="line">                 if (lvl &#x3D;&#x3D; 0)                 &#x2F;&#x2F; if possible</span><br><span class="line">                      return null;</span><br><span class="line">                 else if (curr &#x3D;&#x3D; root[lvl])   &#x2F;&#x2F; by one level</span><br><span class="line">                      curr &#x3D; root[--lvl];      &#x2F;&#x2F; starting from the</span><br><span class="line">                 else curr &#x3D; prev.next[--lvl]; &#x2F;&#x2F; predecessor which</span><br><span class="line">            &#125;                                  &#x2F;&#x2F; can be the root;</span><br><span class="line">            else &#123;                             &#x2F;&#x2F; if greater,</span><br><span class="line">                 prev &#x3D; curr;                  &#x2F;&#x2F; go to the next</span><br><span class="line">                 if (curr.next[lvl] !&#x3D; null)   &#x2F;&#x2F; non-null node</span><br><span class="line">                      curr &#x3D; curr.next[lvl];   &#x2F;&#x2F; on the same level</span><br><span class="line">                 else &#123;                        &#x2F;&#x2F; or to a list on a lower level;</span><br><span class="line">                      for (lvl--; lvl &gt;&#x3D; 0 &amp;&amp; curr.next[lvl] &#x3D;&#x3D; null; lvl--);</span><br><span class="line">                      if (lvl &gt;&#x3D; 0)</span><br><span class="line">                           curr &#x3D; curr.next[lvl];</span><br><span class="line">                      else return null;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(T key) &#123;</span><br><span class="line">        SkipListNode&lt;T&gt;[] curr &#x3D; new SkipListNode[maxLevel];</span><br><span class="line">        SkipListNode&lt;T&gt;[] prev &#x3D; new SkipListNode[maxLevel];</span><br><span class="line">        SkipListNode&lt;T&gt; newNode;</span><br><span class="line">        int lvl, i;</span><br><span class="line">        curr[maxLevel-1] &#x3D; root[maxLevel-1];</span><br><span class="line">        prev[maxLevel-1] &#x3D; null;</span><br><span class="line">        for (lvl &#x3D; maxLevel - 1; lvl &gt;&#x3D; 0; lvl--) &#123;</span><br><span class="line">            while (curr[lvl] !&#x3D; null &amp;&amp; curr[lvl].key.compareTo(key) &lt; 0) &#123;</span><br><span class="line">                prev[lvl] &#x3D; curr[lvl];           &#x2F;&#x2F; go to the next</span><br><span class="line">                curr[lvl] &#x3D; curr[lvl].next[lvl]; &#x2F;&#x2F; if smaller;</span><br><span class="line">            &#125;</span><br><span class="line">            if (curr[lvl] !&#x3D; null &amp;&amp; key.equals(curr[lvl].key)) &#x2F;&#x2F; don&#39;t</span><br><span class="line">                return;                          &#x2F;&#x2F; include duplicates;</span><br><span class="line">            if (lvl &gt; 0)                         &#x2F;&#x2F; go one level down</span><br><span class="line">                if (prev[lvl] &#x3D;&#x3D; null) &#123;         &#x2F;&#x2F; if not the lowest</span><br><span class="line">                      curr[lvl-1] &#x3D; root[lvl-1]; &#x2F;&#x2F; level, using a link</span><br><span class="line">                      prev[lvl-1] &#x3D; null;        &#x2F;&#x2F; either from the root</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;                           &#x2F;&#x2F; or from the predecessor;</span><br><span class="line">                     curr[lvl-1] &#x3D; prev[lvl].next[lvl-1];</span><br><span class="line">                     prev[lvl-1] &#x3D; prev[lvl];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lvl &#x3D; chooseLevel();                &#x2F;&#x2F; generate randomly level</span><br><span class="line">        newNode &#x3D; new SkipListNode&lt;T&gt;(key,lvl+1); &#x2F;&#x2F; for newNode;</span><br><span class="line">        for (i &#x3D; 0; i &lt;&#x3D; lvl; i++) &#123;        &#x2F;&#x2F; initialize next fields of</span><br><span class="line">            newNode.next[i] &#x3D; curr[i];      &#x2F;&#x2F; newNode and reset to newNode</span><br><span class="line">            if (prev[i] &#x3D;&#x3D; null)            &#x2F;&#x2F; either fields of the root</span><br><span class="line">                 root[i] &#x3D; newNode;         &#x2F;&#x2F; or next fields of newNode&#39;s</span><br><span class="line">            else prev[i].next[i] &#x3D; newNode; &#x2F;&#x2F; predecessors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="平摊分析，表的扩增"><a href="#平摊分析，表的扩增" class="headerlink" title="平摊分析，表的扩增"></a>平摊分析，表的扩增</h1><h3 id="How-large-should-a-hash-table-be"><a href="#How-large-should-a-hash-table-be" class="headerlink" title="How large should a hash table be?"></a>How large should a hash table be?</h3><p><strong>Goal</strong> : Make the table as small as possible, but large enough so that it won’t overflow (or otherwise become inefficient).</p>
<p><strong>Problem</strong> : What if we don’t know the proper size in advance?</p>
<p><strong>Solution</strong> : Dynamic tables</p>
<p><strong>IDEA</strong> : Whenever the table gets too full(overflows), “grow” it.</p>
<ul>
<li>Allocate(malloc or new) a large table.</li>
<li>move the items from the old to new.</li>
<li>Free the old table.</li>
</ul>
<h2 id="The-aggregate-method"><a href="#The-aggregate-method" class="headerlink" title="The aggregate method"></a>The aggregate method</h2><p><strong>Analysis</strong> :</p>
<p>A sequence of n insertion operations worst-case of 1 insert = O(n)</p>
<p>let ci = the cost of the i-th insertion = i(if i-1 is an exact power of 2)/ 1(otherwise).</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607510557071-e0c52191-540c-446c-969e-e93707486c9b.png" alt="image.png"></p>
<p>Cost of n insertions = </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/0f7d83486dfa3992f4b423e2c46f1b0e.svg" alt="img"></p>
<p><strong>Thus, the average cost of each dynamic-table operation is O(n)/n= O(1)</strong> </p>
<p>An <strong>amortized analysis(平摊分析)</strong>  is any strategy for analyzing a sequence of operations to show that the average cost per operation is small, even though a single operation within the sequence might be expensive.</p>
<p>常见的平摊分析技术：</p>
<ul>
<li>the aggregate method(聚集分析)</li>
<li>the accounting method(记账分析)</li>
<li>the potential method(势能方法)</li>
</ul>
<p>The aggregate method, though simple, lacks the precision of the other two methods. In particular, the accounting and potential methods allow a specific amortized cost to be allocated to each operation.</p>
<h2 id="The-accounting-method"><a href="#The-accounting-method" class="headerlink" title="The accounting method"></a>The accounting method</h2><ul>
<li>Charge i th operation a fictitious <strong>amortized cost</strong>  ĉ i, where $1 pays for 1 unit of work (i.e., time).</li>
<li>This fee is consumed to perform the operation.</li>
<li>Any amount not immediately consumed is stored in the <strong>bank</strong>  for use by subsequent operations.</li>
<li>The bank balance must not go negative! We must ensure that:</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/__latex/4b118e6d70c4524d2aa8c44c889a0feb.svg" alt="img"> for all n</p>
<ul>
<li>Thus, the total amortized costs provide an upper bound on the total true costs.</li>
</ul>
<h3 id="Accounting-analysis-of-dynamic-tables"><a href="#Accounting-analysis-of-dynamic-tables" class="headerlink" title="Accounting analysis of dynamic tables"></a>Accounting analysis of dynamic tables</h3><p>Charge an amortized cost of ĉi = $3 for the i th insertion.</p>
<ul>
<li>$1 pays for the immediate insertion.</li>
<li>$2 is stored for later table doubling.</li>
</ul>
<p>When the table doubles, $1 pays to move a recent item, and $1 pays to move an old item.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607512860027-3bee36d8-33e2-480a-a20f-f57197bc5b06.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607512870933-cbd8f415-d45b-4155-bdfb-aa27d4141d22.png" alt="image.png"></p>
<p><strong>Key invariant</strong> : Bank balance never drops below 0. Thus, the sum of the amortized costs provides an upper bound on the sum of the true costs.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607512957085-eb223056-a840-4f72-b796-0a1f4c9e94a8.png" alt="image.png"></p>
<h2 id="The-potential-method"><a href="#The-potential-method" class="headerlink" title="The potential method"></a>The potential method</h2><p><strong>IDEA</strong> : View the bank account as the potential energy (à la physics) of the dynamic set.</p>
<p><strong>Framework</strong> :</p>
<ul>
<li>Start with an initial data structure <img src="https://cdn.nlark.com/yuque/__latex/736d64eeb0602d2a2ad1b0ede073c768.svg" alt="img">.</li>
<li>Operation i transforms <img src="https://cdn.nlark.com/yuque/__latex/b50f141401f087f46e72d2c3056ac42d.svg" alt="img"> to <img src="https://cdn.nlark.com/yuque/__latex/d32893051e4add28fec0f40ed7f0713f.svg" alt="img">.</li>
<li>The cost of operation <em>i</em> is <img src="https://cdn.nlark.com/yuque/__latex/d9899588b2b28a768a63ade0f3523596.svg" alt="img">.</li>
<li>Define a potenrial function <img src="https://cdn.nlark.com/yuque/__latex/fc9a659d8326f608a5a441906c27ebc4.svg" alt="img">, such that <img src="https://cdn.nlark.com/yuque/__latex/380f13e6a33e6a642edf3b6d3b153b72.svg" alt="img"> and <img src="https://cdn.nlark.com/yuque/__latex/981d786c81fd5e6732e15e169fe49d96.svg" alt="img"> for all i.</li>
<li>The amortized cost <img src="https://cdn.nlark.com/yuque/__latex/99a663da937f5d7d41ce0f2e75f80065.svg" alt="img"> with respect to Φ is defined to be <img src="https://cdn.nlark.com/yuque/__latex/ac7ede85dacafad1dba3b81bd006caa9.svg" alt="img">. 其中，<img src="https://cdn.nlark.com/yuque/__latex/1cd3c9a3bf58afcb14b46cef9582d75a.svg" alt="img"></li>
<li>if ∆Φi &gt; 0, then ĉi &gt; ci. Operation i stores work in the data structure for later use; If ∆Φi &lt; 0, then ĉi &lt; ci. The data structure delivers up stored work to help pay for operation i.</li>
</ul>
<p>The total amortized cost of n operations is:</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/7c0b9890c61e98513055d27d89a8c9e6.svg" alt="img"></p>
<p><strong>例子略</strong> </p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><ul>
<li>Amortized costs can provide a clean abstraction of data-structure performance.</li>
<li>Any of the analysis methods can be used when an amortized analysis is called for, but each method has some situations where it is arguably the simplest or most precise.</li>
<li>Different schemes may work for assigning amortized costs in the accounting method, or potentials in the potential method, sometimes yielding radically different bounds.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:01:39 / 修改时间：17:05:47" itemprop="dateCreated datePublished" datetime="2021-02-28T17:01:39+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树中关键字的存储方式总是满足以下的二叉查找树性质：</p>
<ul>
<li>设x为二叉查找树中的一个结点。如果y是x的左子树中的一个结点，则<img src="https://cdn.nlark.com/yuque/__latex/0b68d2ce7eb0d3141ee4aa4bcc2270b7.svg" alt="img">。如果y是x的右子树中的结点，则<img src="https://cdn.nlark.com/yuque/__latex/5c14372f94ace8cd2d27a35597d66303.svg" alt="img">。</li>
</ul>
<p>根据二叉树的性质，可以用一个递归算法按排列顺序输出树中的所有关键字，即中序遍历算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void inOrderTreeWalk(TreeNode x)&#123;</span><br><span class="line">    if(x！&#x3D;null)&#123;</span><br><span class="line">        inOrderTreeWalk(x.left);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        inOrderTreeWalk(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定理</strong> ：如果x是一棵包含n个结点的子树的根，则调用InOrderTreeWalk(x)过程的时间为Θ(n)。</p>
<h2 id="查询二叉查找树"><a href="#查询二叉查找树" class="headerlink" title="查询二叉查找树"></a>查询二叉查找树</h2><p><strong>查找一个给定的关键字</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode treeSearch(TreeNode x, int k)&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;null || x.val&#x3D;&#x3D;k)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k&lt;x.val)</span><br><span class="line">        return treeSearch(x.left,k);</span><br><span class="line">    else</span><br><span class="line">        return treeSearch(x.right.k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用非递归算法（While循环）来实现，在大多数计算机上，非递归版本运行的要更快一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public iterativeTreeSearch(TreeNode x, int k)&#123;</span><br><span class="line">    while(x!&#x3D;null &amp;&amp; k!&#x3D;x.val)&#123;</span><br><span class="line">        if(k&lt;x.val)</span><br><span class="line">            x &#x3D; x.left;</span><br><span class="line">        else</span><br><span class="line">            x &#x3D; x.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最大关键字元素和最小关键字元素</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode treeMinimun(TreeNode x)&#123;</span><br><span class="line">    while(x.left!&#x3D;null)&#123;</span><br><span class="line">        x &#x3D; x.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大关键字类似。对高度为h的树，这两个过程的运行时间都是O(h)。</p>
<p><strong>前趋和后继</strong> </p>
<p>给定一个二叉查找树中的结点，有时候要求找出在中序遍历顺序下它的后继，如果所有的关键字均不相同，则某一个结点x的后继即具有大于key[x]中的关键字中的最小值的那个结点。</p>
<p>若s的右子树为空，则从x向上查找，直到遇到某个是其父节点的左儿子的结点为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x)</span><br><span class="line">if right[x]!&#x3D;null&#123;</span><br><span class="line">    then return treeMinimum(x.right);</span><br><span class="line">y &#x3D; p[x]</span><br><span class="line">whilr y!&#x3D;null and x &#x3D; right[y]</span><br><span class="line">    do x &#x3D; y</span><br><span class="line">     y &#x3D; p[y]</span><br><span class="line">return y</span><br></pre></td></tr></table></figure>

<h2 id="删除和插入"><a href="#删除和插入" class="headerlink" title="删除和插入"></a>删除和插入</h2><p><strong>插入</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void treeInsert(TreeNode x, int z)&#123;</span><br><span class="line">    TreeNode pre &#x3D; null;</span><br><span class="line">    TreeNode cur &#x3D; x;</span><br><span class="line">    while(cur!&#x3D;null)&#123;</span><br><span class="line">        pre &#x3D; cur;</span><br><span class="line">        if(z&lt;x.val)</span><br><span class="line">            cur &#x3D; cur.left;</span><br><span class="line">        else</span><br><span class="line">            cur &#x3D; cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre&#x3D;&#x3D;null)</span><br><span class="line">        x &#x3D; new TreeNode(z);</span><br><span class="line">    else if(z&lt;pre.val)</span><br><span class="line">        pre.left &#x3D; new TreeNode(z);</span><br><span class="line">    else</span><br><span class="line">        pre.right &#x3D; new TreeNode(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和其他查找树上的原始操作一样，过程TreeInsert的运行时间也为O(h).</p>
<p><strong>删除</strong> </p>
<p>给定结点z从二叉查找树中删除的过程以指向z的指针为参数，并考虑三种情况：1）如果z没有子女，则修改其父节点p[z]，使NIL为其子女；如果结点z只有一个子女，则通过在其子节点与父节点间建立一条链来删除z。最后，如果结点z有两个子女，先删除z的后继y（没有左儿子），再用y的内容来替代z的内容。 <strong>以下代码并不完善</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void treeDelete(TreeNode z)&#123;</span><br><span class="line">    if(z.left&#x3D;&#x3D;null &amp;&amp; z.right&#x3D;&#x3D;null)&#123;</span><br><span class="line">        &#x2F;&#x2F;没有孩子</span><br><span class="line">        p[z].next &#x3D; null; &#x2F;&#x2F;其父节点连接null</span><br><span class="line">    &#125;else if(z.right!&#x3D;null &amp;&amp; z.left!&#x3D;null)&#123;</span><br><span class="line">        x &#x3D; treeMinimum(z.right);</span><br><span class="line">        z.val &#x3D; x.val;</span><br><span class="line">        treeDelete(x);</span><br><span class="line">    &#125;else if(z.right !&#x3D;null)&#123;</span><br><span class="line">        p[z].next &#x3D; z.right;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        p[z].next &#x3D; z.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定理</strong> 对高度为h的二叉查找树，动态集合操作INSERT和DELETE的运行时间为O(h)。</p>
<p><strong>The Relation to QuickSort:</strong><br>BST Sort &amp; QuickSort make same comparisons but in a different order.</p>
<h2 id="随机构造的二叉树"><a href="#随机构造的二叉树" class="headerlink" title="随机构造的二叉树"></a>随机构造的二叉树</h2><p><strong>步骤</strong> ：</p>
<ul>
<li>Randomly permite A</li>
<li>BST Sort(A)</li>
</ul>
<p>Time(BST) = Time(Randomized-QuickSort)</p>
<p><strong>定理</strong> </p>
<p><strong>一棵在n个关键字上随机构造的二叉查找树的期望高度为O(lgn)。</strong></p>
<h1 id="Balanced-Search-Tree"><a href="#Balanced-Search-Tree" class="headerlink" title="Balanced Search Tree"></a>Balanced Search Tree</h1><p>search tree data structure maintaining dynamic set of n elements using a tree of height order <strong>lgn</strong> .</p>
<p><strong>Examples</strong> </p>
<ul>
<li>AVL Tree</li>
<li>2-3 Tree</li>
<li>2-3-4 Tree</li>
<li>B Tree</li>
<li>Red-Black Trees</li>
<li>Skip lists</li>
<li>Treaps</li>
</ul>
<h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p>BST data structure with <strong>extra color</strong> field for each node satisfying.</p>
<p><strong>Red-Black properties</strong> </p>
<ol>
<li>Every Node is either red or black</li>
<li>the root and the leaves(nil’s) are black</li>
<li><strong>Every red node has black parent</strong> </li>
<li>All simple paths from a node x to a descended leaf of x have <strong>same number of black nodes</strong> . which means have the <strong>same black-height(x)</strong> </li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607175972577-de09ec02-a0d2-410e-a2f1-62141f0803d1.png" alt="image.png"></p>
<p><strong>定理</strong> ： <strong>Red-Black tree with n keys has height h &lt;= 2lg(n+1)</strong> </p>
<p>证明：《算法导论》上有归纳法的详细证明</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607178361377-faade872-4db3-4b0b-a925-376377132939.png" alt="image.png"></p>
<ul>
<li>Merge red nodes into their black parents.</li>
<li>This process produce a tree in which each node  has 2,3 or 4 children</li>
<li>the 2-3-4 tree has uniform depth h’ of leaves</li>
<li>We have <img src="https://cdn.nlark.com/yuque/__latex/71ea6a1b4e5c283c27e3e1688fab7e72.svg" alt="img">, since at most half the leaves on any path are red</li>
<li>The number of leaves in each tree is n+1<img src="https://cdn.nlark.com/yuque/__latex/5475dbf1000faf21127c46a2734b1fbb.svg" alt="img"></li>
</ul>
<p><strong>Corollary</strong> . The queries <em>Search, Min, Max, Successor, and Predecessor</em> all run in <strong>O(lgn)</strong> time on a red-black tree with <strong>n</strong> nodes.</p>
<p><strong>Modifying operations</strong> </p>
<p>The operations Insert and Delete cause modifications to the red-black tree:</p>
<ul>
<li>the operation itself,</li>
<li>color changes,</li>
<li>restucturing the links of the tree via <strong>rotations</strong> </li>
</ul>
<h3 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607179845880-0cf3fbb7-2ecd-49bb-b12e-e68921943f67.png" alt="image.png"></p>
<p>A rotation can be performed in <strong>O(1)</strong> time.</p>
<h3 id="Insertion-into-a-red-black-tree"><a href="#Insertion-into-a-red-black-tree" class="headerlink" title="Insertion into a red-black tree"></a>Insertion into a red-black tree</h3><p><strong>IDEA</strong> : Insert x in tree. Color x red. Only red-black property 3 might be violated. Move the violation up the tree by recoloring until it can be fixed with rotations and recolored.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180036211-4ca11487-0a92-4ed1-a342-7fd9c30b758a.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,x)</span><br><span class="line">    Tree-INSERT(T,x)</span><br><span class="line">  color[x]&#x3D;red</span><br><span class="line">  while x!&#x3D;root[T] and color[p[x]]&#x3D;RED</span><br><span class="line">    do if p[x]&#x3D;left[p[p[x]]]</span><br><span class="line">        then y&#x3D;right[p[p[x]]]</span><br><span class="line">        if color[y]&#x3D;RED</span><br><span class="line">        then &lt;Case 1&gt;</span><br><span class="line">        else if x&#x3D;right[p[x]]</span><br><span class="line">            then &lt;case 2&gt;</span><br><span class="line">        &lt;Case 3&gt;</span><br><span class="line">      else&lt;&quot;Then&quot; clause with &quot;left&quot; and &quot;right&quot; swapped&gt;</span><br><span class="line">  color[root[T]]&#x3D;black</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180316709-9a8490be-003f-4126-9577-3584a8dd3087.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180326781-f9a4a4df-9930-42ac-9307-0759fd873cb2.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180388203-0f9bc8c6-8492-4876-8dee-5883a177c84e.png" alt="image.png"></p>
<p><strong>Analysis</strong> </p>
<ul>
<li>Go up the tree performing Case 1, with only recolors node.</li>
<li>If Case 2 or Case 3 occurs, perform 1 or 2 rotations, and terminate.</li>
</ul>
<p><strong>Running Time</strong> </p>
<p><strong>O(lgn)</strong> with <strong>O(1)</strong> rotations.</p>
<p>RB-Delete: same asymptotic running time and number of rotations as RB-Insert(See textbook).</p>
<h1 id="扩充的数据结构、动态有序统计和区间树"><a href="#扩充的数据结构、动态有序统计和区间树" class="headerlink" title="扩充的数据结构、动态有序统计和区间树"></a>扩充的数据结构、动态有序统计和区间树</h1><p>augmentation data structures 数据结构的扩充</p>
<h2 id="Dynamic-order-statistics"><a href="#Dynamic-order-statistics" class="headerlink" title="Dynamic order statistics"></a>Dynamic order statistics</h2><p>新增的两个操作：</p>
<ul>
<li>OS-Select(i): returns i-th smallest item in dynamic set</li>
<li>OS-Rank(i): returns rank of x in sorted order.</li>
</ul>
<p><strong>IDEA</strong> : <strong>Keep subtree size in node of r-b trees</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607327491484-617b49bf-cd80-4ba2-8ad9-bad2f661a185.png" alt="image.png"></p>
<p><strong>size[x] = size[left[x]]+size[right[x]]+1</strong> </p>
<h3 id="OS-Select-i"><a href="#OS-Select-i" class="headerlink" title="OS-Select(i)"></a>OS-Select(i)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OS-Select(x,i) &#x2F;&#x2F;i-th smallest in subtree rooted at x</span><br><span class="line">    r &#x3D; x.left.size + 1; &#x2F;&#x2F;rank of x</span><br><span class="line">  if i&#x3D;&#x3D;r</span><br><span class="line">    return x</span><br><span class="line">  else if i&lt;r</span><br><span class="line">    return OS-Select(x.left,i)</span><br><span class="line">  else</span><br><span class="line">    return OS-Select(x.right,i-r)</span><br></pre></td></tr></table></figure>

<h3 id="OS-Rank-i"><a href="#OS-Rank-i" class="headerlink" title="OS-Rank(i)"></a>OS-Rank(i)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OS-RANK(T,x)</span><br><span class="line">    r &#x3D; x.left.size + 1</span><br><span class="line">  y &#x3D; x</span><br><span class="line">  while y!&#x3D;T.root</span><br><span class="line">    if y&#x3D;&#x3D;y.p.right</span><br><span class="line">        r &#x3D; r + y.p.left.size + 1</span><br><span class="line">    y &#x3D; y.p</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure>

<p><strong>Analysis</strong> T(n)=<strong>O(lgn)</strong></p>
<p>Q: Why not keep the ranks in nodes instead of subtree sizes?</p>
<p>A: It’s hard to maintain when t-b tree is motified.</p>
<p><strong>Mutifying operations: Insert and Delete</strong> </p>
<p><strong>Stratege</strong> : Update subtree sizes when inserting or deleting.</p>
<p>EX:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607327990012-11baa4a2-5670-402e-8f69-69029764e4f3.png" alt="image.png"></p>
<p><strong>but also need to handle rebalancing</strong> </p>
<ul>
<li>r-b color changes: no effect to size</li>
<li>rotation: look at children and fix up in O(1) time</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607328155405-cda58171-a018-4a0d-b12b-7da039806060.png" alt="image.png"></p>
<p>So,  <strong>RB-Insert and RB-Delete still run in O(lgn) time</strong> </p>
<h3 id="Data-structrue-augmentation"><a href="#Data-structrue-augmentation" class="headerlink" title="Data-structrue augmentation"></a>Data-structrue augmentation</h3><p><strong>Methodology</strong> : (e.g. order-statistics trees)</p>
<ol>
<li>Choose an underlying data structrue.(red-black trees)</li>
<li>Determine additional information to be stored in the data structure.(subtree size)</li>
<li>Verify that this information can be maintained for modifying operations.(RBINSERT, RB-DELETE — don’t forget rotations)</li>
<li>Develop new dynamic-set operations that use the informations.(OS-Select and OS-Rank)</li>
</ol>
<p><strong>These steps are guidelines, not rigid rules</strong> </p>
<h2 id="Example-Interval-trees-区间树"><a href="#Example-Interval-trees-区间树" class="headerlink" title="Example: Interval trees 区间树"></a>Example: Interval trees 区间树</h2><p><strong>IDEA</strong> ：maintain a set of intervals. e.g. time intervals</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607329725240-770943dd-5a03-45f2-955f-b7ce8e9627fc.png" alt="image.png"></p>
<p><strong>Query</strong> : For a given query interval i, find an interval in the set that overlaps i.</p>
<h3 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a><strong>Methodology</strong></h3><ol>
<li>Choose an underlying data structure.</li>
</ol>
<p>(Red-Black Tree key on <strong>low(left) endpoint</strong> )</p>
<ol>
<li>Determine additional information to be stored in the data structure.</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607329913708-467fd2f4-8e79-4fa7-9bc9-2e3da3176d14.png" alt="image.png"></p>
<ol>
<li>Modifying operations:<br><strong>Insert: fix m’s on way down</strong> .</li>
</ol>
<p>​    Rotations——Fixup = <strong>O(1)</strong>  time per rotation:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607330009760-b6920705-4e40-40ce-a980-a15b3a0fc014.png" alt="image.png"></p>
<p>So, <strong>Total Insert Time = O(lgn)</strong>  Delete similar</p>
<ol>
<li>Develop new dynamic-set operations that use the information.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INTERVAL-SEARCH(T,i)</span><br><span class="line">    x &#x3D; T.root</span><br><span class="line">  while x!&#x3D;nil and (low[i]&gt;high[int[x]] or high[i]&lt;low[int[x]]) &#x2F;&#x2F; i does not overlaps x</span><br><span class="line">    if x.left!&#x3D;nil and x.left.m &gt;&#x3D; low[i]</span><br><span class="line">        x&#x3D;x.left</span><br><span class="line">    else x &#x3D; x.right</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure>

<p><strong>List all overlaps: O(klgn)</strong> <strong>Output sensitive</strong> </p>
<p><strong>Correctness</strong> </p>
<p>Theorem. Let L be the set of intervals in the left subtree of node x, and let R be the set of intervals in x’s right subtree.</p>
<p><strong>If the search goes right, then</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/4367610265a8d75d48ee1815aa026566.svg" alt="img"></p>
<p><strong>If the search goes left, then</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/3a302c645f324058b030290ff28bf071.svg" alt="img"></p>
<p><strong>证明略</strong> </p>
<h2 id="补充1：2-3数"><a href="#补充1：2-3数" class="headerlink" title="补充1：2-3数"></a>补充1：2-3数</h2><p><strong>2–3树</strong>是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">树型数据结构</a>，内部节点（存在子节点的节点）要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果一个内部节点拥有一个数据元素、两个子节点，则此节点为<strong>2节点</strong>。</p>
<p>如果一个内部节点拥有两个数据元素、三个子节点，则此节点为<strong>3节点</strong>。</p>
<p>当且仅当以下叙述中有一条成立时，<em>T</em>为2–3树：</p>
<ul>
<li><em>T</em>为空。即<em>T</em>不包含任何节点。</li>
<li>为拥有数据元素<em>a</em>的2节点。若<em>T</em>的左孩子为<em>L</em>、右孩子为<em>R</em>，则：<em>L</em>和<em>R</em>是等高的非空2–3树；<em>a</em>大于<em>L</em>中的所有数据元素；且<em>a</em>小于等于<em>R</em>中的所有数据元素。</li>
<li><em>T</em>为拥有数据元素<em>a</em>和<em>b</em>的3节点，其中<em>a</em> &lt; <em>b</em>。若<em>T</em>的左孩子为<em>L</em>、中孩子为<em>M</em>、右孩子为<em>R</em>，则：<em>L</em>、<em>M</em>、和<em>R</em>是等高的非空2–3树；<em>a</em>大于<em>L</em>中的所有数据元素，并且小于等于<em>M</em>中的所有数据元素；<em>b</em>大于<em>M</em>中的所有数据元素，并且小于等于<em>R</em>中的所有数据元素。</li>
</ul>
<h3 id="2-3树的查找"><a href="#2-3树的查找" class="headerlink" title="2-3树的查找"></a>2-3树的查找</h3><p>与普通二叉搜索树相似。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408159789-043b9fd7-732e-474f-922d-17767f22ac6f.png" alt="image.png"></p>
<h3 id="2-3树的插入"><a href="#2-3树的插入" class="headerlink" title="2-3树的插入"></a>2-3树的插入</h3><p>前面我们知道，2-3查找树分为<strong>2结点</strong>和<strong>3结点</strong>，so，插入就分为了2结点插入和3结点插入。</p>
<p><strong>2-结点插入:</strong> 向2-结点插入一个新的结点和向而插入插入一个结点很类似，但是我们并不是将结点“吊”在结点的末尾，因为这样就没办法保持树的平衡。我们可以将2-结点替换成3-结点即可，将其中的键插入这个3-结点即可。（相当于缓存了这个结点）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408378995-5aa5404b-52dc-4638-a459-63aceefc5898.png" alt="image.png"></p>
<p><strong>3-结点插入：</strong> 3结点插入比较麻烦，它分为3种情况：</p>
<ol>
<li>向一棵只含有3-结点的树插入新键。</li>
</ol>
<p>​    假如2-3树只有一个3-结点，那么当我们插入一个新的结点的时候，我们先假设结点变成了4-结点，然后使得中间的结点为根结点，左边的结点为其左结点，右边的结点为其右结点，然后构成一棵2-3树，<strong>树的高度加1</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408488175-b4dacd99-b514-41e1-813c-ce85e1aa6323.png" alt="image"></p>
<ol>
<li>向父结点为2-结点的3-结点中插入新键。</li>
</ol>
<p>和上面的情况类似，我们将新的节点插入3-结点使之成为4-结点，然后将结点中的中间结点”升“到其父节点（2-结点）中的合适的位置，使其父节点成为一个3-节点，然后将左右节点分别挂在这个3-结点的恰当位置，<strong>树的高度不发生改变。</strong></p>
<p>**<br>**<img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408543768-2c76d858-f678-4653-a4be-d6a5a5373020.png" alt="image"></p>
<ol>
<li>向父节点为3-结点的3-结点中插入新键。</li>
</ol>
<p>​    这种情况有点类似递归：当我们的结点为3-结点的时候，我们插入新的结点会将中间的元素”升“父节点，然后父节点为4-结点，右将中间的结点”升“到其父结点的父结点，……如此进行递归操作，直到遇到的结点不再是3-结点。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408606615-da5cf49b-6e5b-4c5c-949f-4fc29d535e97.png" alt="image"></p>
<p><strong>树的高度</strong> ：<img src="https://cdn.nlark.com/yuque/__latex/03a539bfcefdaf30db1bf6a92c136a69.svg" alt="img"></p>
<h2 id="补充2-B树"><a href="#补充2-B树" class="headerlink" title="补充2-B树"></a>补充2-B树</h2><p>B树是为磁盘或其他直接存取辅助存储设备而设计的一种平衡查找树。与红黑树类似，但在降低磁盘I/O操作次数方面要更好一些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:00:27 / 修改时间：17:01:10" itemprop="dateCreated datePublished" datetime="2021-02-28T17:00:27+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列表是普通数组概念的推广，因为可以对数组进行直接寻址，故可以在O(1)的时间内访问数组的任意元素。</p>
<h2 id="直接寻址法"><a href="#直接寻址法" class="headerlink" title="直接寻址法"></a>直接寻址法</h2><p>当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。假设某应用要用到一个动态集合，其中每个元素都有一个取自全域U={0,1,…,m-1}的关键字，此处m是一个很大的数。另，假设没有两个元素具有相同的关键字。</p>
<p>为表示动态集合，我们用一个数组（或称直接寻址表）T[0,…,m-1]，其中每个位置（或称槽）对应全域U中的一个关键字。对SEARCH、INSERT、DELETE等操作均只需O(1).</p>
<h2 id="散列表-1"><a href="#散列表-1" class="headerlink" title="散列表"></a>散列表</h2><p>直接寻址技术存在一个明显的问题：如果域U很大，在一台典型计算机的可用内从容量限制下，要在机器中存储大小为|U|的一张表T就优点不切实际，甚至不可能。还有，实际要存储的关键字集合K相对于U来说可能很小，因而分配给T 的大部分空间都要浪费掉。</p>
<p>在直接寻址方式下， <strong>具有关键字k的元素被存放在槽k中</strong> 。在散列方式下， <strong>该元素处于h(k)中</strong> 。即利用散列函数h，根据关键字k计算出槽的位置。 <strong>函数h将关键字域U映射到散列表T[0,…,m-1]的槽位上</strong> 。</p>
<p>这样做有一个小问题： <strong>两个关键字可能映射到同一个槽位上</strong> ，我们称之为 <strong>碰撞</strong> 。</p>
<h3 id="通过链接法来解决碰撞"><a href="#通过链接法来解决碰撞" class="headerlink" title="通过链接法来解决碰撞"></a>通过链接法来解决碰撞</h3><p>在链接法中，把散列到同一槽的所有元素都放在一个链表中。槽j中有一个指针，它指向由所有散列到j的元素构成的链表的头。</p>
<p>采用链接法后散列表的性能怎么样呢？特别的，要查找一个具有给定关键字的元素需要多长时间？</p>
<p>给定一个能存放n个元素的、具有m个空槽位的散列表T，定义T的装载因子(Load factor)<img src="https://cdn.nlark.com/yuque/__latex/f50c6d3557faf32740b6b49917e5b0f1.svg" alt="img">，即一个链表中平均存储的元素数。</p>
<p>Worst-Case：所有的n个关键字都散列到同一个槽内，<strong>Θ(n)</strong>.</p>
<p>若假定任何元素散列到m个槽中的每一个可能性是相同的，且与其他元素已被散列到什么位置上是无关的，即 <strong>简单一致性假设</strong> </p>
<p><strong>则在简单一致性假设下，对于用链接技术解决碰撞的散列表，平均情况下一次成功或不成功的查找需要</strong> <img src="https://cdn.nlark.com/yuque/__latex/a0a8d5c552af1b569cf03e4f7e0c5d77.svg" alt="img"></p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>在这一节里，讨论一些有关如何设计出好的散列函数的问题。</p>
<h3 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h3><p>通过取k除以m的余数，来将关键字k映射到m个槽的某一个去。即，散列函数为 <strong>h(k) = k mod m</strong> </p>
<p>当应用除法散列时，应 <strong>注意m的选择</strong> 。可以选作m的值常常是 <strong>与2的整数幂不太接近的质数</strong> </p>
<h3 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h3><p>构造散列函数的乘法方法包含两个步骤：首先，用关键字k乘上常数A（0&lt;A&lt;1），并抽出kA的小数部分。然后用m乘以这个值，再取结果的底。总之，散列函数为</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/7126e1116411a1c9095b27e8906f8ddd.svg" alt="img"></p>
<h3 id="全域散列"><a href="#全域散列" class="headerlink" title="全域散列"></a>全域散列</h3><p>如果让某个和你作对的人来选择要散列的关键字，那么他会选择全部散列到同一个槽中的n个关键字，使得平均检索时间为<strong>Θ(n)**。任何一个特定的散列函数都可能出现这种最坏情况形态：唯一有效的改进方法是 **随机地选择散列函数</strong> ，使之独立于要存储地关键字，这种方法称之为 <strong>全域散列</strong> 。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法（openning addressing）中，所有的元素都存放在散列表里。亦即，每个表项或包含动态集合的一个元素，或包含nil。当查找一个元素时，要检查所有的表项，直到找到所需元素，或最终发现该元素不在表中。</p>
<p><strong>线性勘查</strong> </p>
<p>当冲突发生时，使用某些探测技术在散列表中形成一个探测序列，沿此序列逐个单元查找，直到找到给定的关键字、或者碰到一个开放地 址（即该地址单元为空、空桶）为止。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1606997448519-ae4bc0eb-c36c-4874-a603-ac2a9bb86dd6.png" alt="image.png"></p>
<p><strong>双重散列</strong> </p>
<p>双重散列是用于开放寻址的最好方法之一，因为它所产生的排列具有随机选择的排列的许多特性。它采用如下形式的散列函数：</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/602cda7c22ffc6dd4c89cc272f40b65b.svg" alt="img"></p>
<h3 id="对开放寻址散列的分析"><a href="#对开放寻址散列的分析" class="headerlink" title="对开放寻址散列的分析"></a>对开放寻址散列的分析</h3><p><strong>Assumption</strong> : <strong>一致散列法</strong> ：在这种理想的方法中，用于插入或查找每一个关键字k的探索序列为&lt;0,1,…,m-1&gt;的任一中排列的可能性是相同的。</p>
<p>则在该假设下： <strong>给定一个装载因子a=n/m&lt;1的开放寻址散列表，在一次不成功的查找中，期望的勘察天数至多为1/(1-a)</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 16:58:21 / 修改时间：16:59:43" itemprop="dateCreated datePublished" datetime="2021-02-28T16:58:21+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>在排序算法中使用的是最大堆，最小堆通常在构造优先序列时使用。</p>
<h3 id="保持堆的性质"><a href="#保持堆的性质" class="headerlink" title="保持堆的性质"></a>保持堆的性质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">l&#x3D;left(i);</span><br><span class="line">r&#x3D;right(i);</span><br><span class="line">if l&lt;&#x3D;heap-size[A] and A[l]&gt;A[i]</span><br><span class="line">    then largest &#x3D; l</span><br><span class="line">else largest &#x3D; i;</span><br><span class="line">    if r&lt;&#x3D;heap-size[A] and A[r]&gt;A[largest]</span><br><span class="line">        then largest &#x3D; r</span><br><span class="line">if(largest!&#x3D;r)</span><br><span class="line">    then exchange A[i],A[largest]</span><br><span class="line">    Max-Heapify(A,largest)</span><br></pre></td></tr></table></figure>

<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>可以自底而上地用MAX-HEAPIFY来将一个数组A[1…n]变成最大堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">heap-size[A] &#x3D; length[A]</span><br><span class="line">for i &#x3D; length(A)&#x2F;2 向上取整 downto 1</span><br><span class="line">    do MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure>

<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAPSORT(A)</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">for i&#x3D;length(A) down to 2</span><br><span class="line">    do swap(A,l,i)</span><br><span class="line">  heap-size[A] &#x3D; heap-size[A]-1</span><br><span class="line">  MAX-HEAPIFY(A,l)</span><br></pre></td></tr></table></figure>

<h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><p><strong>How Fast can we sort?</strong> depends on model of what you can do with the elements!</p>
<p>目前学习的插入排序、归并排序、快速排序以及堆排序都是基于 <strong>比较排序</strong> 的算法。</p>
<h3 id="排序算法的下界"><a href="#排序算法的下界" class="headerlink" title="排序算法的下界"></a>排序算法的下界</h3><p>比较排序可以被抽象地视为决策树。一棵决策树是一棵满二叉树，表示某排序算法作用于给定输入所作的所有比较，而控制结构、数据移动等都被忽略了。</p>
<p>Comparision Sorting: only use comparisons to determine the relative order of elements. </p>
<p>Runing time(#Comparisons)=length of path</p>
<p>Worst-case running time = height of tree</p>
<p><strong>Lower bound on decision-tree sorting:</strong> </p>
<p><strong>Any decision-tree sorting n elements has the height</strong>  <img src="https://cdn.nlark.com/yuque/__latex/3320c7a3017e0a921a83c91bfeba4ea3.svg" alt="img"></p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>基本思想</strong> 对每一个输入元素x，确定出小于x的元素个数。</p>
<p><strong>前提</strong> n个输入元素中的每一个都是0到k之间的整数。</p>
<p>在计数排序算法的代码中，我们假定输入是n个数的数组A，存放排序结果的B，以及提供临时存储区的C（0…k）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void countingSort(int[] A, int[] B, k)&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    int n &#x3D; A.length;</span><br><span class="line">    int[] C &#x3D; new int[k];</span><br><span class="line">    for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">        C[A[i]] &#x3D; C[A[i]]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1; i&lt;k; i++)&#123;</span><br><span class="line">        C[i] &#x3D; C[i-1]+C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;n-1; i&gt;&#x3D;0; i--)&#123;</span><br><span class="line">        B[C[A[i]]] &#x3D; A[i];</span><br><span class="line">        C[A[i]] &#x3D; C[A[i]]-1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>T(n) = Θ(n+k)</strong> </p>
<h3 id="基数排序（Hallerith-1890）"><a href="#基数排序（Hallerith-1890）" class="headerlink" title="基数排序（Hallerith 1890）"></a>基数排序（Hallerith 1890）</h3><p>从低位向高位依次排序， <strong>要求按位排序要稳定</strong> </p>
<p>定理：给定n个d位数，每一个数位可以取k种可能的值，基数排序算法能以**Θ(d(n+k))**的时间正确地对这些数排序</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>当 <strong>桶排序</strong> 的输入符合均匀分布时，既可以实现线性时间运行。与计数排序类似，桶排序也对输入作了某种假设，因而运行很快：计数排序假设 <strong>输入是一个由小范围内的整数构成</strong> ，而桶排序则假设 <strong>输入有一个随机过程产生</strong> ，该过程将元素均匀地分布在区间[0,1]上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    int bucketNum &#x3D; (max - min) &#x2F; arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num &#x3D; (arr[i] - min) &#x2F; (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中位数和顺序统计学"><a href="#中位数和顺序统计学" class="headerlink" title="中位数和顺序统计学"></a>中位数和顺序统计学</h1><p>本章讨论从一个由n个不同数值构成的集合中选择其第i个顺序统计值的问题。为方便起见，假设集合中的数互异。</p>
<p>Input：一个包含n个（不同的）数的集合A和一个数i，<img src="https://cdn.nlark.com/yuque/__latex/9c5935072f94d570ccfcb75043b3f859.svg" alt="img">.</p>
<p>Output：<img src="https://cdn.nlark.com/yuque/__latex/ae04b7455d654ee119e014c9b0e805db.svg" alt="img"></p>
<p>该选择问题可以在<strong>O(nlgn)**时间内解决，因为可以用</strong>堆排序或合并排序**对输入数据进行排序，然后在输出数组中标出第i个元素即可。但还有其他更快的解法。</p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int Minmum(A)&#123;</span><br><span class="line">    int min &#x3D; A[0];</span><br><span class="line">    for(int i : A)&#123;</span><br><span class="line">        if(min&gt;i)</span><br><span class="line">            min &#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">    return min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以期望线性时间做选择"><a href="#以期望线性时间做选择" class="headerlink" title="以期望线性时间做选择"></a>以期望线性时间做选择</h3><p>介绍一种用来解决选择问题的分治算法，即RANDOMIZED-SELECT算法，以 <strong>快速排序算法</strong> 为模型。与快速排序不同的是，RANDOMIZED-SELECT <strong>只处理划分的一边</strong> 。这一差异使得快速排序的期望运行时间是 <strong>Θ(nlgn)</strong> ,而RANDOMIZED-SELECT的期望时间是 <strong>Θ(n)</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A,p,r,i)</span><br><span class="line">if(p&#x3D;&#x3D;r)</span><br><span class="line">    then return A[p]</span><br><span class="line">q &#x3D; RANDOMIZED-PARTITION(A,p,r);</span><br><span class="line">k &#x3D; q-p+1</span><br><span class="line">if i&#x3D;k</span><br><span class="line">    then return A[q]</span><br><span class="line">else if i&lt;k</span><br><span class="line">    then return RANDOMIZED-SELECT(A,p,q-1,i);</span><br><span class="line">else</span><br><span class="line">    then return RANDOMIZED-SELECT(A,q+1,r,i-k)</span><br></pre></td></tr></table></figure>

<p><strong>在平均情况下，任何顺序统计量（特别是中位数）都可以在线性时间内得到</strong> ，证明略。</p>
<h3 id="最坏情况线性时间的选择"><a href="#最坏情况线性时间的选择" class="headerlink" title="最坏情况线性时间的选择"></a>最坏情况线性时间的选择</h3><p>现在来看一个最坏情况运行时间为O(n)的选择算法SELECT。该算法的基本思想是要 <strong>保证对数组的划分上是个好的划分</strong> 。算法通过执行下列步骤来确定一个有n&gt;1个元素的输入数组中的第i小的元素：</p>
<ul>
<li>将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一个组由剩下的n mod 5个元素构成。</li>
<li>寻找n/5个组中每一组的中位数，首先对每组中的元素（至多5个）进行插入排序，然后从排序过的序列中选出中位数。</li>
<li>对第2步中找出的n/5个中位数，递归调用SELECT以找出中位数x</li>
<li>利用修改过的PARTITION过程，按中位数的中位数x对输入数组进行划分。让k比划分低区的元素数目多1，所以x是第k小的元素。</li>
<li>如果i==k，则返回x，否则，如果，i&lt;k，在低区递归调用SELECT，i&gt;k，在高区递归调用SELECT。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 16:56:35 / 修改时间：16:57:51" itemprop="dateCreated datePublished" datetime="2021-02-28T16:56:35+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p><strong>分治模式</strong> </p>
<p><strong>分解（Divide）</strong>：将原问题分解成一系列子问题；</p>
<p><strong>解决（Conquer）</strong>：递归地解各子问题。若子问题足够小，则直接求解；</p>
<p><strong>合并（Combine）</strong>：将子问题的结果合并成原问题的解。</p>
<p>Ex.Merge Sort, Binary Search</p>
<h2 id="一些举例"><a href="#一些举例" class="headerlink" title="一些举例"></a>一些举例</h2><h3 id="powering-the-number"><a href="#powering-the-number" class="headerlink" title="powering the number"></a>powering the number</h3><p>given a number x, and integer <img src="https://cdn.nlark.com/yuque/__latex/c36c48c557a498703465d5431d607e60.svg" alt="img">, compute x^n</p>
<p>Native algorithm: <strong>Θ(n)</strong></p>
<p>Divide and conquer:</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/49636e9e784d9d86cba24daa372ba700.svg" alt="img">  <strong>T(n)=**</strong>Θ(lgn)**</p>
<h3 id="Fibonacci-numbers"><a href="#Fibonacci-numbers" class="headerlink" title="Fibonacci numbers"></a>Fibonacci numbers</h3><p><img src="https://cdn.nlark.com/yuque/__latex/7be51ef698b6e78a7be66f6145259127.svg" alt="img"></p>
<p>Native recursive algorithm: Time <img src="https://cdn.nlark.com/yuque/__latex/0b5be7ae172ade05832c0c10cea793ac.svg" alt="img"></p>
<p>recursive squaring: 转化为矩阵：<img src="https://cdn.nlark.com/yuque/__latex/da906dce963bedafb27275c2c507589f.svg" alt="img"></p>
<h3 id="Matrix-Multiplition"><a href="#Matrix-Multiplition" class="headerlink" title="Matrix Multiplition"></a>Matrix Multiplition</h3><p>Input: A=[a_ij], B=[b_ij]</p>
<p>Output: C=[c_ij] = A*B, <img src="https://cdn.nlark.com/yuque/__latex/e0d06d1cd929c98b7ad638619b63b092.svg" alt="img"></p>
<p>standard algorithm: <strong>Θ(n^3)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i&#x3D;1 to n</span><br><span class="line">    do for j&#x3D;1 to n</span><br><span class="line">    do c_ij &#x3D; 0</span><br><span class="line">    for k&#x3D;1 to n</span><br><span class="line">        c_ij &#x3D; a_ik * b_kj + c_ij</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>IDEA</strong>:n<em>n matrix = 2</em>2 blank matrix of n/2 * n/2 sub matrix</p>
<p>need 8 recursive calls: T(n) = 8T(n/2)+Θ(n^2) = <strong>Θ(n^3)</strong></p>
<p><strong>Strassen’s algorithm:</strong></p>
<p><strong>IDEA</strong>:reduce recursive calls to 7 recursive calls</p>
<h3 id="二叉树遍历及相关特性"><a href="#二叉树遍历及相关特性" class="headerlink" title="二叉树遍历及相关特性"></a>二叉树遍历及相关特性</h3><p><strong>计算二叉树高度</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int TreeHeight(TreeNode root)&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(TreeHight(root.left),TreeHeight(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的遍历</strong> </p>
<p>前序遍历、中序遍历、后序遍历</p>
<h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><p>Native aglorithm recursive: need 4 recursive calls;</p>
<p>change to <strong>3 recursive calls</strong>;</p>
<h3 id="最近点对问题"><a href="#最近点对问题" class="headerlink" title="最近点对问题"></a>最近点对问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EfficientClosestPair(P,Q)</span><br><span class="line">if n&lt;&#x3D;3</span><br><span class="line">    return the minimal distance found by bruce-force aglorithm</span><br><span class="line">else</span><br><span class="line">    copy the first (n&#x2F;2)向上取整 points of P to array Pl</span><br><span class="line">  copy the same (n&#x2F;2) points from Q to arrays Ql</span><br><span class="line">  copy the remaining (n&#x2F;2)向下取整 points of P to array Pr</span><br><span class="line">  copy the same (n&#x2F;2)points from Q to array Qr</span><br><span class="line">  dl &#x3D; EfficientClosestPair(Pl,Ql)</span><br><span class="line">  dr &#x3D; EfficientClosestPair(Pr,Qr)</span><br><span class="line">  d &#x3D; min(dl,dr)</span><br><span class="line">  m &#x3D; P[(n&#x2F;2)-1].x</span><br><span class="line">  copy all the points of Q for which |x-m|&lt;d into array S[0...num-1]</span><br><span class="line">  dminsq &#x3D; d^2</span><br><span class="line">  for i&#x3D;0 to num-2 do</span><br><span class="line">    k &#x3D; i+1</span><br><span class="line">    while k&lt;&#x3D;num-1 and (S[k].x)-S[i].x)^2&lt;dminsq</span><br><span class="line">        dminsq &#x3D; min((S[k].x-S[i].x)^2+(S[k].y-S[i].y)^2,dminsq)</span><br><span class="line">      k&#x3D;k+1</span><br><span class="line"> return sqrt(dminsq)</span><br></pre></td></tr></table></figure>

<h1 id="快排和随机化算法"><a href="#快排和随机化算法" class="headerlink" title="快排和随机化算法"></a>快排和随机化算法</h1><h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><p>QuickSort: Hoare 1962</p>
<ul>
<li>Divide and conquer</li>
<li>sorts “in place”</li>
<li>very pratical( with turning)</li>
</ul>
<p><strong>step 1</strong>: Divide: Patition array into 2 subarrays around pivot x</p>
<p><strong>step 2</strong>: Recursively sort 2 subarrays</p>
<p><strong>step 3</strong>: combine: trivial</p>
<p><strong>key: linear-time partitioning subroutine</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int partition(int[] A, int left, int right)&#123;</span><br><span class="line">    pivot &#x3D; A[left];</span><br><span class="line">  i &#x3D; p;</span><br><span class="line">  for(j&#x3D;p+1; j&lt;&#x3D;q; j++)&#123;</span><br><span class="line">    if(A[j]&lt;pivot)&#123;</span><br><span class="line">        i++;</span><br><span class="line">      swap(A,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(A,left, i+1);</span><br><span class="line">  return i+1;</span><br><span class="line">&#125;</span><br><span class="line">public void QuickSort(int[] A,int left, int right)&#123;</span><br><span class="line">    if(left&gt;right)&#123;</span><br><span class="line">    int p &#x3D; partition(A, left, right);</span><br><span class="line">    QuickSort(A,left,p-1);</span><br><span class="line">    QuickSort(A, p+1, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>assume:</strong> all numbers distinct</p>
<p>T(n):</p>
<p><strong>Worst-Case:</strong> <strong>T(n)=T(n-1)+T(0)+**</strong>Θ(n) =** <strong>Θ(n^2)</strong></p>
<ul>
<li>input sorted or reversed sorted</li>
<li>one side of partition has no elements</li>
</ul>
<p><strong>Best-Case analysis( intution only)</strong></p>
<p>if we can really lucky, partition splits the array n/2, n/2, then T(n)=<strong>Θ(nlgn)</strong></p>
<p><strong>suppose:</strong> slipts is always 0.1:0.9  <strong>lucky</strong></p>
<p><strong>soppose</strong>: we alternate lucky, unlucky, lucky…  <strong>lucky</strong></p>
<h2 id="随机化快速排序算法（Randomized-QuickSort）"><a href="#随机化快速排序算法（Randomized-QuickSort）" class="headerlink" title="随机化快速排序算法（Randomized QuickSort）"></a>随机化快速排序算法（Randomized QuickSort）</h2><ul>
<li>the running time is independent of input ordering</li>
<li>no assumption about the input distribution</li>
<li>no specific input elicit worst-case behavior</li>
<li>the worst-case is detemined only by a random-number generator</li>
</ul>
<p>​    在这种方法中，不是始终采用A[r]作为主元，而是从子数组A[p…r]中随机选择一个元素，即将A[r]与从A[p…r]中随机选出的一个元素交换。<strong>即主元元素是随机选取的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-PARTITION(A,p,r)</span><br><span class="line">i&#x3D;random(p,r);</span><br><span class="line">swap(A,i,p);</span><br><span class="line">return partition(A,p,r);</span><br></pre></td></tr></table></figure>

<p>注意：关于时间复杂度证明的部分没看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kiro-xu"
      src="/images/avater.jpg">
  <p class="site-author-name" itemprop="name">kiro-xu</p>
  <div class="site-description" itemprop="description">Be who you want to be</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-2 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kiro-xu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
