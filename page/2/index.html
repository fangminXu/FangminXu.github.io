<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be who you want to be">
<meta property="og:type" content="website">
<meta property="og:title" content="kiro的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="kiro的博客">
<meta property="og:description" content="Be who you want to be">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="kiro-xu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>kiro的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kiro的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/JVM%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/JVM%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">JVM重点知识整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 17:30:16" itemprop="dateCreated datePublished" datetime="2021-02-28T17:30:16+08:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-01 20:38:55" itemprop="dateModified" datetime="2021-03-01T20:38:55+08:00">2021-03-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a herf="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank">参考1</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md" target="_blank">参考2</a></p>
<blockquote>
<p>对于Java，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
</blockquote>
<h2 id="1-JVM的位置"><a href="#1-JVM的位置" class="headerlink" title="1 JVM的位置"></a>1 JVM的位置</h2><p><img src="https://i.loli.net/2021/02/28/ILUgZ68zYedipDJ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/28/qjso7LWkE5uNx2A.png" alt="image.png"></p>
<h2 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2 类加载机制"></a>2 类加载机制</h2><p>类是在运行期间<strong>第一次使用时</strong>动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<p><strong>类的生命周期</strong></p>
<p><img src="https://i.loli.net/2021/02/28/nFLrI4wVNMSDAcX.png" alt="image.png"></p>
<h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<h2 id="3-运行时数据区域"><a href="#3-运行时数据区域" class="headerlink" title="3 运行时数据区域"></a>3 运行时数据区域</h2><p><img src="https://i.loli.net/2021/02/28/4lhBxuZ7aFV8ITo.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/28/xJ6Z8jaXRBPTcgY.png" alt="image.png"></p>
<h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p><strong>当前线程所执行的字节码的行号指示器</strong>。</p>
<p>从上面的介绍中我们知道程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。（<strong>每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，即线程私有</strong>）</li>
</ol>
<p>它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><h2 id="Java编译程序和运行过程详解"><a href="#Java编译程序和运行过程详解" class="headerlink" title="Java编译程序和运行过程详解"></a>Java编译程序和运行过程详解</h2><p><a href="https://www.cnblogs.com/superyc/p/9987793.html" target="_blank">参考</a></p>
<p>Java程序从源文件创建到程序运行要经过两大步骤：</p>
<ol>
<li>Java文件会由编译器<strong>编译成class文件</strong>（字节码文件），会经过编译原理简单过程的前三步；</li>
<li>字节码由java虚拟机解释运行，解释执行即为目标代码生成并执行。因为java程序既要编译的同时也要经过JVM的解释运行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal &#x3D; new Animal(&quot;Tom&quot;);</span><br><span class="line">        animal.printName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Animal&#123;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void printName()&#123;</span><br><span class="line">        System.out.println(&quot;Animal &#x3D; &quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（八）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:09:25 / 修改时间：17:10:19" itemprop="dateCreated datePublished" datetime="2021-02-28T17:09:25+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="贪心算法和最小生成树"><a href="#贪心算法和最小生成树" class="headerlink" title="贪心算法和最小生成树"></a>贪心算法和最小生成树</h1><p>又可称偏心算法：先将要求高的满足，再满足要求低的。</p>
<h2 id="图论回顾"><a href="#图论回顾" class="headerlink" title="图论回顾"></a>图论回顾</h2><p>Digragh(有向图，Direct Gragh) </p>
<p>Undirected Gragh : G = (V, E), the edge set E consists of unordered pairs of vertices.</p>
<p>In either case, we have <strong>|E| = O(V^2)</strong>. Moreover, if G is connected(连通图), then <strong>|E| ≥ |V| – 1</strong>, which implies that <strong>lg |E| = Θ(lgV)</strong>. </p>
<h3 id="Adjacency-matrix-representation（邻接矩阵表示法）"><a href="#Adjacency-matrix-representation（邻接矩阵表示法）" class="headerlink" title="Adjacency-matrix representation（邻接矩阵表示法）"></a>Adjacency-matrix representation（邻接矩阵表示法）</h3><p>The adjacency matrix of a graph G = (V, E), where V = {1, 2, …, n}, is the matrix A[1 . . n, 1 . . n] given by：</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/5d4357ea9df7d304dc7f52c8686f1723.svg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608798696801-17933b85-e281-4aad-a51b-df57834b7c8c.png" alt="image.png"></p>
<p><strong>该表示方法需要的存储空间为：</strong><img src="https://cdn.nlark.com/yuque/__latex/c0e4ef8d0c23513de13cacd3a809e240.svg" alt="img"></p>
<h3 id="Adjacency-list-representation（邻接表表示法）"><a href="#Adjacency-list-representation（邻接表表示法）" class="headerlink" title="Adjacency-list representation（邻接表表示法）"></a>Adjacency-list representation（邻接表表示法）</h3><p>An adjacency list of a vertex v ∈ V is the list Adj[v] of vertices adjacent to v.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608798812866-bbc6b590-4583-4235-8707-e0556f85d7a3.png" alt="image.png"></p>
<p>For undirected graphs, <strong>|Adj[v]| = degree(v)</strong>.</p>
<p>For digraphs, <strong>|Adj[v]| = out-degree(v)</strong>.</p>
<p><strong>Handshaking Lemma:</strong></p>
<p><img src="https://cdn.nlark.com/yuque/__latex/8ae10bb61baf43fb0315e0d0e1723722.svg" alt="img">  for undirected graphs ⇒ adjacency lists use <strong>Θ(V + E) storage</strong> — a <strong>sparse</strong> representation (for either type of graph).</p>
<h2 id="Minimum-Spanning-Trees（最小生成树）"><a href="#Minimum-Spanning-Trees（最小生成树）" class="headerlink" title="Minimum Spanning Trees（最小生成树）"></a>Minimum Spanning Trees（最小生成树）</h2><p><strong>Input</strong>: A <strong>connected, undirected graph</strong> G = (V, E) with weight function w : E → R. </p>
<ul>
<li> For simplicity, assume that all edge weights are distinct. (CLRS covers the general case.)</li>
</ul>
<p><strong>Output:</strong> A spanning tree T — a tree that connects all vertices — of minimum weight:</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/bfeb9c51c8c6c276ff467de232055f3d.svg" alt="img"></p>
<p>**<br>**</p>
<p><strong>An Example of MST</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799270562-8475bbc6-1fa5-43d8-acb1-3a772058a15c.png" alt="image.png"></p>
<h3 id="Optimal-substructure（最优子结构）"><a href="#Optimal-substructure（最优子结构）" class="headerlink" title="Optimal substructure（最优子结构）"></a>Optimal substructure（最优子结构）</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799463185-839e2aa0-e522-4f40-88d4-dc5340bd5d37.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799492463-2d950e9a-bc4f-4e8c-b42a-ad8afcac774e.png" alt="image.png"></p>
<p>Remove any edge Remove any edge (u, v) ∈ T. Then, . T is partitioned into two subtrees T1 and T2.</p>
<p><strong>Theotem：</strong></p>
<p>The subtree T1 is an MST of G1 = (V1, E1), the subgraph of G induced by the vertices of T1:</p>
<p>V1 = vertices of T1,</p>
<p>E1 = { (x, y) ∈ E : x, y ∈ V1 }</p>
<p>Similarly for T2.</p>
<p><strong>Proof：</strong></p>
<p><strong>Cut and paste</strong>: If T1′ were a lower-weight spanning tree than T1 for G1, </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/6b897148c96d5b9f6a88a7747003fd78.svg" alt="img"></p>
<p>then T′ = {(u, v)} ∪ T1′ ∪ T2 would be a lower-weight spanning tree than T for G. <strong>Wrong</strong></p>
<h3 id="overlapping-subproblems"><a href="#overlapping-subproblems" class="headerlink" title="overlapping subproblems"></a>overlapping subproblems</h3><p>hava overlapping subproblems too.</p>
<p><strong>dynamic programming may work</strong></p>
<p>but MST exhibits another powerful property which leads to an even more efficient algorithm.</p>
<h3 id="Hallmark-for-“greedy”-algorithms"><a href="#Hallmark-for-“greedy”-algorithms" class="headerlink" title="Hallmark for “greedy” algorithms"></a>Hallmark for “greedy” algorithms</h3><p><strong>Greedy-choice property A locally optimal choice is globally optimal.</strong></p>
<p>局部最优解即为全局最优解</p>
<p><strong>Theorem.</strong></p>
<p>Let T be the MST of G = (V, E), and let A ⊆ V. Suppose that (u, v) ∈ E is the least-weight edge connecting A to V – A. Then, (u, v) ∈ T.</p>
<p><strong>Proof：</strong></p>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799858055-0446731d-4e07-4f37-8a35-700882c06739.png" alt="image.png"></strong></p>
<p>Consider the unique simple path from u to v in T. Swap (u, v) with the first edge on this path that connects a vertex in A to a vertex in V – A.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608799918278-5e71bc73-8caf-4196-a1a3-eec5ee1208ed.png" alt="image.png"></p>
<h3 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h3><p><strong>IDEA:</strong> Maintain V – A as a <strong>priority queue Q</strong>. Key each vertex in Q with the weight of the leastweight edge connecting it to a vertex in A.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Q&lt;-V(all)</span><br><span class="line">key[v] &lt;- 无穷 for all v ∈ V</span><br><span class="line">key[s] &lt;- 0 for some arbitrary s ∈ V</span><br><span class="line">while Q!&#x3D;null</span><br><span class="line">    do u &lt;- EXTRACT-MIN(Q)</span><br><span class="line">  for each v∈Adj[u]</span><br><span class="line">    do if v∈Q and w(u, v) &lt; key[v]</span><br><span class="line">            then key[v] ← w(u, v)</span><br><span class="line">            π[v] ← u</span><br><span class="line">At the end, &#123;(v, π[v])&#125; forms the MST</span><br></pre></td></tr></table></figure>

<p><strong>Analysis:</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608800270592-5a91ed5d-cc64-42e0-8607-e8bb1bbc172c.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/__latex/c579d84275b9876478a1164fccb8eb2a.svg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1608800367455-d48c2f1a-5974-41e8-8268-edb1ef82e67c.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（七）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:07:29 / 修改时间：17:09:01" itemprop="dateCreated datePublished" datetime="2021-02-28T17:07:29+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dynamic-Programming-Longest-Common-Subsequence-动态规划，最长相同子序列"><a href="#Dynamic-Programming-Longest-Common-Subsequence-动态规划，最长相同子序列" class="headerlink" title="Dynamic Programming, Longest Common Subsequence(动态规划，最长相同子序列)"></a>Dynamic Programming, Longest Common Subsequence(动态规划，最长相同子序列)</h1><p>Design technique, like divide-and-conquer.</p>
<h2 id="Example-Longest-Common-Subsequence-LCS"><a href="#Example-Longest-Common-Subsequence-LCS" class="headerlink" title="Example: Longest Common Subsequence (LCS)"></a>Example: Longest Common Subsequence (LCS)</h2><p>Given two sequences x[1 . . m] and y[1 . . n], find <strong>a</strong>  longest subsequence common to them both.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607664315488-663bfed8-4c02-4d27-ac67-f084a8a26296.png" alt="image.png"></p>
<h3 id="Bruce-Force-algorithm"><a href="#Bruce-Force-algorithm" class="headerlink" title="Bruce-Force algorithm"></a>Bruce-Force algorithm</h3><p><strong>Check</strong>  every <strong>subsequence</strong>  of x[1 . . m] to see if it is also a subsequence of y[1 . . n].</p>
<p><strong>Analysis</strong> </p>
<ul>
<li>Checking = O(n) time per subsequence.</li>
<li>2^m subsequences of x (each bit-vector of length m determines a distinct subsequence of x).</li>
<li>So, Worst-case running time = O(n2^m) = exponential time. <strong>Slow!</strong> </li>
</ul>
<h3 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h3><ol>
<li>Look at the length of a longest-common subsequence.</li>
<li>Extend the algorithm to find the LCS itself.</li>
</ol>
<p><strong>Notation</strong> : Denote the length of a sequence s by |s|.</p>
<p><strong>Strategy</strong> : Consider <strong>prefixes</strong>  of x and y.</p>
<p><strong>Define:</strong> c[i, j] = | LCS(x[1 . . i], y[1 . . j])|. 最长子序列长度</p>
<p>那么可知，c[m,n] = |LCS(x,y)|</p>
<p><strong>Theorem.</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/b1bb05baea482e6d80396d5c32b90f41.svg" alt="img"></p>
<p><strong>证明略</strong> </p>
<h3 id="Dynamic-programming-hallmark-1"><a href="#Dynamic-programming-hallmark-1" class="headerlink" title="Dynamic-programming hallmark #1"></a>Dynamic-programming hallmark #1</h3><p>Optimal substructure ：An optimal solution to a problem (instance) contains optimal solutions to subproblems。</p>
<p>动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Recursion algorithm for LCS</span><br><span class="line">    if x[i]&#x3D;y[j]</span><br><span class="line">    then c[i,j]&#x3D;LCS(c[i-1,j-1])+1</span><br><span class="line">  else</span><br><span class="line">    c[i,j] &#x3D; max&#123;LCS(i,j-1),LCS(i-1,j)&#125;;</span><br><span class="line">  return c[i,j]</span><br></pre></td></tr></table></figure>

<p>Worst-case: x[i]!=y[j], 对任意i，j。in which case the algorithm evaluates two subproblems, each with only one parameter decremented.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607665733966-d9db75bc-ae0d-4999-869a-cb4440a6b969.png" alt="image.png"></p>
<p><strong>Height = m + n</strong>  ⇒ work potentially exponential。but we’re solving subproblems already solved!</p>
<h3 id="Dynamic-programming-hallmark-2"><a href="#Dynamic-programming-hallmark-2" class="headerlink" title="Dynamic-programming hallmark #2"></a>Dynamic-programming hallmark #2</h3><p>Overlapping subproblems A recursive solution contains a “small” number of distinct subproblems repeated many times.</p>
<p>The number of distinct LCS subproblems for two strings of lengths m and n is only mn.</p>
<p><strong>Memoization algorithm</strong> </p>
<p>Memoization: After computing a solution to a subproblem, store it in a table. Subsequent calls check the table to avoid redoing work.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Memoization Algorithm</span><br><span class="line">    c[i,j]&#x3D;LCS(x,y,i,j)</span><br><span class="line">  if c[i,j]&#x3D;nil</span><br><span class="line">    then if x[i]&#x3D;y[j]</span><br><span class="line">                then c[i,j] &#x3D; LCS(x,ymi-1,j-1)+1</span><br><span class="line">        else </span><br><span class="line">            c[i,j] &#x3D; max&#123;LCS(i,j-1),LCS(i-1,j)&#125;</span><br><span class="line">   return c[i,j];</span><br></pre></td></tr></table></figure>

<p><strong>Time</strong>  = Θ(mn) = constant work per table entry. </p>
<p><strong>Space</strong>  = Θ(mn).</p>
<h3 id="Dynamic-programming-algorithm"><a href="#Dynamic-programming-algorithm" class="headerlink" title="Dynamic-programming algorithm"></a>Dynamic-programming algorithm</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607666136741-e15b79c5-9bdb-4bde-a236-9841b7cea989.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LCS-LENGTH(X,Y)</span><br><span class="line">m &#x3D; length[X]</span><br><span class="line">n &#x3D; length[Y]</span><br><span class="line">for i&#x3D;1 to m</span><br><span class="line">    do c[i,0] &#x3D; 0</span><br><span class="line">for j&#x3D;0 to n</span><br><span class="line">    fo c[0,j] &#x3D; 0</span><br><span class="line">for i&#x3D;1 to n</span><br><span class="line">    do for j&#x3D;1 to n</span><br><span class="line">    do if x[i] &#x3D; y[j]</span><br><span class="line">        then c[i,j] &#x3D; c[i-1,j-1]+1</span><br><span class="line">    else if c[i-1,j] &gt;&#x3D; c[i,j-1]</span><br><span class="line">      then c[i,j] &#x3D; c[i-1,j]</span><br><span class="line">      else c[i,j] &#x3D; c[i,j-1]</span><br><span class="line">return c</span><br></pre></td></tr></table></figure>

<p><strong>Time = Θ(mn)</strong> .</p>
<p>Reconstruct LCS by <strong>tracing backwards</strong> .</p>
<ul>
<li><strong>Space = Θ (mn )</strong> .</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>分治算法是指将问题划分成一些 <strong>独立</strong> 的子问题，递归求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题 <strong>不是独立</strong> 的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子子问题。</p>
<p>动态规划算法对每个子子问题只求解一次，将其结果保存在一张表种，从而避免每次遇到各子问题时重新计算答案。</p>
<p>动态规划通常应用于 <strong>最优化问题</strong> 。此类问题可能有很多种可行解。每个解有一个值，而我们希望找出一个具有最优（最大或最小）值的解。称这样的解为该问题的 <strong>一个</strong> 最优解（而不是确定的最优解），因为可能存在多个取最优值的解。</p>
<p>动态规划算法的设计可以分为以下四步：</p>
<ol>
<li>描述最优解的结构i</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算出的结果构造一个最优解</li>
</ol>
<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h3><p><strong>题目描述</strong> </p>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p><strong>示例</strong> </p>
<p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3</p>
<p>输出：4</p>
<p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。</p>
<p>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p>
<p><strong>思路</strong> </p>
<p>第一步，要明确两点，[状态]和[选择]。</p>
<p>状态有三个， [背包对1的容量]、[背包对0的容量]和 [可选择的字符串]；选择就是把字符串[装进背包]或者[不装进背包]。</p>
<p>第二步，要明确dp数组的定义：</p>
<p>首先，[状态]有三个，所以需要一个三维的dp数组。dp[i][j][k]的定义如下：若只使用前i个物品，当背包容量为j个0，k个1时，能够容纳的最多字符串数。</p>
<p>第三步，根据选择，思考状态转移的逻辑：</p>
<p>注意，这是一个0-1背包问题，每个字符串只有一个选择机会，要么选择装，要么选择不装。</p>
<p><strong>如果你不能把这第 i 个物品装入背包</strong> （等同于容量不足，装不下去），也就是说你不使用strs[i]这一个字符串，那么当前的字符串数dp[i][j][k]应该等于dp[i - 1][j][k], <strong>继承</strong> 之前的结果。</p>
<p><strong>如果你可以把这第 i 个物品装入了背包</strong> (此时背包容量是充足的，因此要选择装或者不装)，也就是说你能使用 strs[i] 这个字符串，那么 dp[i][j] 应该等于 Max(dp[i - 1][j][k], dp[i - 1][j - cnt[0]][k - cnt[1]] + 1)。 Max函数里的两个式子，分别是装和不装strs[i的字符串数量。(cnt 是根据strs[i]计算出来的。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line">        int len &#x3D; strs.length;</span><br><span class="line">        int[][][] dp &#x3D;new int[len+1][m+1][n+1];</span><br><span class="line">        for(int i&#x3D;1; i&lt;&#x3D;len; i++)&#123;</span><br><span class="line">            String s &#x3D; strs[i-1];</span><br><span class="line">            int zeronum &#x3D; countzero(s);</span><br><span class="line">            int onenum &#x3D; s.length()-zeronum;</span><br><span class="line">            for(int j&#x3D;0; j&lt;m+1; j++)&#123;</span><br><span class="line">                for(int k&#x3D;0; k&lt;n+1; k++)&#123;</span><br><span class="line">                    dp[i][j][k]  &#x3D; dp[i-1][j][k];</span><br><span class="line">                    if(j&gt;&#x3D;zeronum &amp;&amp; k&gt;&#x3D;onenum)&#123;</span><br><span class="line">                        dp[i][j][k] &#x3D; Math.max(dp[i-1][j][k],dp[i-1][j-zeronum][k-onenum]+1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    public int countzero(String s)&#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for(int i&#x3D;0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(s.charAt(i)&#x3D;&#x3D;&#39;0&#39;)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:06:13 / 修改时间：17:07:06" itemprop="dateCreated datePublished" datetime="2021-02-28T17:06:13+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Skip-Lists-跳跃表（Pugh，1989）"><a href="#Skip-Lists-跳跃表（Pugh，1989）" class="headerlink" title="Skip Lists 跳跃表（Pugh，1989）"></a>Skip Lists 跳跃表（Pugh，1989）</h1><p>a <strong>simple, randomized, efficient</strong> dynamic search structrue</p>
<p>Maintains a dynamic set of n elements in <strong>O(lgn)</strong> time per operation in expectation an  <strong>with high probability</strong> (w.h.p)”almost always”</p>
<h2 id="one-linked-list"><a href="#one-linked-list" class="headerlink" title="one linked list"></a>one linked list</h2><p>Start from simplest data structure: <strong>(sort) linked list</strong> </p>
<ul>
<li>Searches take <strong>O(n) time in worst case</strong></li>
<li>How can we speed up searches?</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607435349427-5c0be976-bff3-4230-b4c3-8eafcb35879c.png" alt="image.png"></p>
<h2 id="Two-linked-lists"><a href="#Two-linked-lists" class="headerlink" title="Two linked lists"></a>Two linked lists</h2><p>Suppose we had two sorted linked lists (on subsets of the elements).</p>
<ul>
<li>Each element can appear in one or both lists</li>
<li>How can we speed up searches?</li>
</ul>
<p><strong>IDEA</strong> : 类似客车的快线与慢线</p>
<ul>
<li>Express line connects a few of the stations</li>
<li>Local line connects all stations</li>
<li>Links between lines at common stations</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607435637348-02714b61-fede-4d6c-8a0b-a887fbca512a.png" alt="image.png"></p>
<h3 id="Searching-in-two-linked-lists"><a href="#Searching-in-two-linked-lists" class="headerlink" title="Searching in two linked lists"></a>Searching in two linked lists</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEARCH(x)</span><br><span class="line">    Walk right in top linked list(L1) until going right would go too far</span><br><span class="line">  Walk down to bottom linked list(L2)</span><br><span class="line">  Walk right in L2 until element found(or not)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607435834020-bf9ee095-c95c-40ef-af74-30061278bed0.png" alt="image.png"></p>
<p><strong>Question</strong> : Which nodes should be in L1?</p>
<ul>
<li>In a subway, the “Popular stations”</li>
<li>Here we care about worst-case performance</li>
<li><strong>Best approach</strong> : Evenly space the nodes in L1</li>
<li>But how many nodes should be in L1</li>
</ul>
<p><strong>Analysis</strong> </p>
<p>Search cost is roughly <strong>|L1|+|L2|/|L1|</strong> </p>
<p>Minimized(up to constant factors) when terms are equal: <img src="https://cdn.nlark.com/yuque/__latex/8b9b4bcee9ff40263ae229e873e98cd7.svg" alt="img">, and Search cost is roughly <img src="https://cdn.nlark.com/yuque/__latex/c1fbe26c9914fdbeb3c992b9b72c91e4.svg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607436391944-660662f0-f936-404b-9dbd-fed4bc2fdfbe.png" alt="image.png"></p>
<h2 id="More-linked-lists"><a href="#More-linked-lists" class="headerlink" title="More linked lists"></a>More linked lists</h2><p>What if we had more sorted linked lists?</p>
<ul>
<li>2 sorted lists <img src="https://cdn.nlark.com/yuque/__latex/5c178e70690758153ae450d69509e497.svg" alt="img"></li>
<li>3 sorted lists <img src="https://cdn.nlark.com/yuque/__latex/29ec5a303e64980341f3011343ac63f1.svg" alt="img"></li>
<li>k sorted lists <img src="https://cdn.nlark.com/yuque/__latex/4b398932c7d4408df795ced985a3b13e.svg" alt="img"></li>
<li>lgn sorted lists <img src="https://cdn.nlark.com/yuque/__latex/f06c5d0a7973de0894d7a1b3f08a1e28.svg" alt="img"></li>
</ul>
<p>lgn sorted linked lists are like a <strong>binary tree</strong> .</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607436699061-2785b69b-65b9-4c9a-b2de-1c163ae1da9d.png" alt="image.png"></p>
<h3 id="insert-x-and-delete-x"><a href="#insert-x-and-delete-x" class="headerlink" title="insert(x) and delete(x)"></a>insert(x) and delete(x)</h3><p><strong>Skip list data structure</strong>  maintains roughly this structure subject to updates (insert/delete)</p>
<p>To insert an element x into a skip list:</p>
<ul>
<li>SEARCH(x) to see where x fits in bottom list</li>
<li>Always insert into bottom list</li>
</ul>
<p><strong>INVARIANT</strong> : Bottom list contains all elements , insert into some of the lists above…</p>
<p><strong>QUESTION</strong> : To which other lists should we add x?</p>
<p><strong>IDEA</strong> : <strong>Flip a (fair) coin</strong> ; if HEADS, promote x to next level up and flip again</p>
<p>Probability of promotion to next level = 1/2</p>
<p><strong>Small changes</strong> : Add special −∞ value to every list ⇒ can search with the same algorithm</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607437031127-ae9d874a-aed2-40d0-a9b0-598b994c7b89.png" alt="image.png"></p>
<h3 id="How-good-are-skip-lists-speed-balance"><a href="#How-good-are-skip-lists-speed-balance" class="headerlink" title="How good are skip lists? (speed/balance)"></a>How good are skip lists? (speed/balance)</h3><p><strong>INTUITIVELY</strong> : Pretty good on average</p>
<p><strong>CLAIM</strong> : Really, really good, almost always</p>
<p><strong>THEOREM</strong> : <em>With high probability</em>, every search in an n-element skip list costs <strong>O(lgn)</strong></p>
<p>证明略</p>
<p><strong>LEMMA</strong> : <em>With high probability</em>, n-element skip list has <strong>O(lgn)</strong> levels</p>
<p>证明略</p>
<p><strong>CLAIM</strong> : Number of coin flips until <strong>c lgn</strong> HEADs = <strong>Θ(lgn)</strong> <em>with high probability</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************  SkipList.java  *********************&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class SkipList&lt;T extends Comparable&lt;? super T&gt;&gt; &#123;</span><br><span class="line">    private int maxLevel;</span><br><span class="line">    private SkipListNode&lt;T&gt;[] root;</span><br><span class="line">    private int[] powers;</span><br><span class="line">    private Random rd &#x3D; new Random();</span><br><span class="line">    SkipList() &#123;</span><br><span class="line">        this(4);</span><br><span class="line">    &#125;</span><br><span class="line">    SkipList(int i) &#123;</span><br><span class="line">        maxLevel &#x3D; i;</span><br><span class="line">        root &#x3D; new SkipListNode[maxLevel];</span><br><span class="line">        powers &#x3D; new int[maxLevel];</span><br><span class="line">        for (int j &#x3D; 0; j &lt; maxLevel; j++)</span><br><span class="line">            root[j] &#x3D; null;</span><br><span class="line">        choosePowers();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return root[0] &#x3D;&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void choosePowers() &#123;</span><br><span class="line">        powers[maxLevel-1] &#x3D; (2 &lt;&lt; (maxLevel-1)) - 1;    &#x2F;&#x2F; 2^maxLevel - 1</span><br><span class="line">        for (int i &#x3D; maxLevel - 2, j &#x3D; 0; i &gt;&#x3D; 0; i--, j++)</span><br><span class="line">           powers[i] &#x3D; powers[i+1] - (2 &lt;&lt; j);           &#x2F;&#x2F; 2^(j+1)</span><br><span class="line">    &#125;</span><br><span class="line">    public int chooseLevel() &#123;</span><br><span class="line">        int i, r &#x3D; Math.abs(rd.nextInt()) % powers[maxLevel-1] + 1;</span><br><span class="line">        for (i &#x3D; 1; i &lt; maxLevel; i++)</span><br><span class="line">            if (r &lt; powers[i])</span><br><span class="line">                return i-1; &#x2F;&#x2F; return a level &lt; the highest level;</span><br><span class="line">        return i-1;         &#x2F;&#x2F; return the highest level;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; make sure (with isEmpty()) that search() is called for a nonempty list;</span><br><span class="line">    public T search(T key) &#123;</span><br><span class="line">        int lvl;</span><br><span class="line">        SkipListNode&lt;T&gt; prev, curr;            &#x2F;&#x2F; find the highest nonnull</span><br><span class="line">        for (lvl &#x3D; maxLevel-1; lvl &gt;&#x3D; 0 &amp;&amp; root[lvl] &#x3D;&#x3D; null; lvl--); &#x2F;&#x2F; level;</span><br><span class="line">        prev &#x3D; curr &#x3D; root[lvl];</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (key.equals(curr.key))          &#x2F;&#x2F; success if equal;</span><br><span class="line">                 return curr.key;</span><br><span class="line">            else if (key.compareTo(curr.key) &lt; 0) &#123; &#x2F;&#x2F; if smaller, go down,</span><br><span class="line">                 if (lvl &#x3D;&#x3D; 0)                 &#x2F;&#x2F; if possible</span><br><span class="line">                      return null;</span><br><span class="line">                 else if (curr &#x3D;&#x3D; root[lvl])   &#x2F;&#x2F; by one level</span><br><span class="line">                      curr &#x3D; root[--lvl];      &#x2F;&#x2F; starting from the</span><br><span class="line">                 else curr &#x3D; prev.next[--lvl]; &#x2F;&#x2F; predecessor which</span><br><span class="line">            &#125;                                  &#x2F;&#x2F; can be the root;</span><br><span class="line">            else &#123;                             &#x2F;&#x2F; if greater,</span><br><span class="line">                 prev &#x3D; curr;                  &#x2F;&#x2F; go to the next</span><br><span class="line">                 if (curr.next[lvl] !&#x3D; null)   &#x2F;&#x2F; non-null node</span><br><span class="line">                      curr &#x3D; curr.next[lvl];   &#x2F;&#x2F; on the same level</span><br><span class="line">                 else &#123;                        &#x2F;&#x2F; or to a list on a lower level;</span><br><span class="line">                      for (lvl--; lvl &gt;&#x3D; 0 &amp;&amp; curr.next[lvl] &#x3D;&#x3D; null; lvl--);</span><br><span class="line">                      if (lvl &gt;&#x3D; 0)</span><br><span class="line">                           curr &#x3D; curr.next[lvl];</span><br><span class="line">                      else return null;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insert(T key) &#123;</span><br><span class="line">        SkipListNode&lt;T&gt;[] curr &#x3D; new SkipListNode[maxLevel];</span><br><span class="line">        SkipListNode&lt;T&gt;[] prev &#x3D; new SkipListNode[maxLevel];</span><br><span class="line">        SkipListNode&lt;T&gt; newNode;</span><br><span class="line">        int lvl, i;</span><br><span class="line">        curr[maxLevel-1] &#x3D; root[maxLevel-1];</span><br><span class="line">        prev[maxLevel-1] &#x3D; null;</span><br><span class="line">        for (lvl &#x3D; maxLevel - 1; lvl &gt;&#x3D; 0; lvl--) &#123;</span><br><span class="line">            while (curr[lvl] !&#x3D; null &amp;&amp; curr[lvl].key.compareTo(key) &lt; 0) &#123;</span><br><span class="line">                prev[lvl] &#x3D; curr[lvl];           &#x2F;&#x2F; go to the next</span><br><span class="line">                curr[lvl] &#x3D; curr[lvl].next[lvl]; &#x2F;&#x2F; if smaller;</span><br><span class="line">            &#125;</span><br><span class="line">            if (curr[lvl] !&#x3D; null &amp;&amp; key.equals(curr[lvl].key)) &#x2F;&#x2F; don&#39;t</span><br><span class="line">                return;                          &#x2F;&#x2F; include duplicates;</span><br><span class="line">            if (lvl &gt; 0)                         &#x2F;&#x2F; go one level down</span><br><span class="line">                if (prev[lvl] &#x3D;&#x3D; null) &#123;         &#x2F;&#x2F; if not the lowest</span><br><span class="line">                      curr[lvl-1] &#x3D; root[lvl-1]; &#x2F;&#x2F; level, using a link</span><br><span class="line">                      prev[lvl-1] &#x3D; null;        &#x2F;&#x2F; either from the root</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;                           &#x2F;&#x2F; or from the predecessor;</span><br><span class="line">                     curr[lvl-1] &#x3D; prev[lvl].next[lvl-1];</span><br><span class="line">                     prev[lvl-1] &#x3D; prev[lvl];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lvl &#x3D; chooseLevel();                &#x2F;&#x2F; generate randomly level</span><br><span class="line">        newNode &#x3D; new SkipListNode&lt;T&gt;(key,lvl+1); &#x2F;&#x2F; for newNode;</span><br><span class="line">        for (i &#x3D; 0; i &lt;&#x3D; lvl; i++) &#123;        &#x2F;&#x2F; initialize next fields of</span><br><span class="line">            newNode.next[i] &#x3D; curr[i];      &#x2F;&#x2F; newNode and reset to newNode</span><br><span class="line">            if (prev[i] &#x3D;&#x3D; null)            &#x2F;&#x2F; either fields of the root</span><br><span class="line">                 root[i] &#x3D; newNode;         &#x2F;&#x2F; or next fields of newNode&#39;s</span><br><span class="line">            else prev[i].next[i] &#x3D; newNode; &#x2F;&#x2F; predecessors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="平摊分析，表的扩增"><a href="#平摊分析，表的扩增" class="headerlink" title="平摊分析，表的扩增"></a>平摊分析，表的扩增</h1><h3 id="How-large-should-a-hash-table-be"><a href="#How-large-should-a-hash-table-be" class="headerlink" title="How large should a hash table be?"></a>How large should a hash table be?</h3><p><strong>Goal</strong> : Make the table as small as possible, but large enough so that it won’t overflow (or otherwise become inefficient).</p>
<p><strong>Problem</strong> : What if we don’t know the proper size in advance?</p>
<p><strong>Solution</strong> : Dynamic tables</p>
<p><strong>IDEA</strong> : Whenever the table gets too full(overflows), “grow” it.</p>
<ul>
<li>Allocate(malloc or new) a large table.</li>
<li>move the items from the old to new.</li>
<li>Free the old table.</li>
</ul>
<h2 id="The-aggregate-method"><a href="#The-aggregate-method" class="headerlink" title="The aggregate method"></a>The aggregate method</h2><p><strong>Analysis</strong> :</p>
<p>A sequence of n insertion operations worst-case of 1 insert = O(n)</p>
<p>let ci = the cost of the i-th insertion = i(if i-1 is an exact power of 2)/ 1(otherwise).</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607510557071-e0c52191-540c-446c-969e-e93707486c9b.png" alt="image.png"></p>
<p>Cost of n insertions = </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/0f7d83486dfa3992f4b423e2c46f1b0e.svg" alt="img"></p>
<p><strong>Thus, the average cost of each dynamic-table operation is O(n)/n= O(1)</strong> </p>
<p>An <strong>amortized analysis(平摊分析)</strong>  is any strategy for analyzing a sequence of operations to show that the average cost per operation is small, even though a single operation within the sequence might be expensive.</p>
<p>常见的平摊分析技术：</p>
<ul>
<li>the aggregate method(聚集分析)</li>
<li>the accounting method(记账分析)</li>
<li>the potential method(势能方法)</li>
</ul>
<p>The aggregate method, though simple, lacks the precision of the other two methods. In particular, the accounting and potential methods allow a specific amortized cost to be allocated to each operation.</p>
<h2 id="The-accounting-method"><a href="#The-accounting-method" class="headerlink" title="The accounting method"></a>The accounting method</h2><ul>
<li>Charge i th operation a fictitious <strong>amortized cost</strong>  ĉ i, where $1 pays for 1 unit of work (i.e., time).</li>
<li>This fee is consumed to perform the operation.</li>
<li>Any amount not immediately consumed is stored in the <strong>bank</strong>  for use by subsequent operations.</li>
<li>The bank balance must not go negative! We must ensure that:</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/__latex/4b118e6d70c4524d2aa8c44c889a0feb.svg" alt="img"> for all n</p>
<ul>
<li>Thus, the total amortized costs provide an upper bound on the total true costs.</li>
</ul>
<h3 id="Accounting-analysis-of-dynamic-tables"><a href="#Accounting-analysis-of-dynamic-tables" class="headerlink" title="Accounting analysis of dynamic tables"></a>Accounting analysis of dynamic tables</h3><p>Charge an amortized cost of ĉi = $3 for the i th insertion.</p>
<ul>
<li>$1 pays for the immediate insertion.</li>
<li>$2 is stored for later table doubling.</li>
</ul>
<p>When the table doubles, $1 pays to move a recent item, and $1 pays to move an old item.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607512860027-3bee36d8-33e2-480a-a20f-f57197bc5b06.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607512870933-cbd8f415-d45b-4155-bdfb-aa27d4141d22.png" alt="image.png"></p>
<p><strong>Key invariant</strong> : Bank balance never drops below 0. Thus, the sum of the amortized costs provides an upper bound on the sum of the true costs.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607512957085-eb223056-a840-4f72-b796-0a1f4c9e94a8.png" alt="image.png"></p>
<h2 id="The-potential-method"><a href="#The-potential-method" class="headerlink" title="The potential method"></a>The potential method</h2><p><strong>IDEA</strong> : View the bank account as the potential energy (à la physics) of the dynamic set.</p>
<p><strong>Framework</strong> :</p>
<ul>
<li>Start with an initial data structure <img src="https://cdn.nlark.com/yuque/__latex/736d64eeb0602d2a2ad1b0ede073c768.svg" alt="img">.</li>
<li>Operation i transforms <img src="https://cdn.nlark.com/yuque/__latex/b50f141401f087f46e72d2c3056ac42d.svg" alt="img"> to <img src="https://cdn.nlark.com/yuque/__latex/d32893051e4add28fec0f40ed7f0713f.svg" alt="img">.</li>
<li>The cost of operation <em>i</em> is <img src="https://cdn.nlark.com/yuque/__latex/d9899588b2b28a768a63ade0f3523596.svg" alt="img">.</li>
<li>Define a potenrial function <img src="https://cdn.nlark.com/yuque/__latex/fc9a659d8326f608a5a441906c27ebc4.svg" alt="img">, such that <img src="https://cdn.nlark.com/yuque/__latex/380f13e6a33e6a642edf3b6d3b153b72.svg" alt="img"> and <img src="https://cdn.nlark.com/yuque/__latex/981d786c81fd5e6732e15e169fe49d96.svg" alt="img"> for all i.</li>
<li>The amortized cost <img src="https://cdn.nlark.com/yuque/__latex/99a663da937f5d7d41ce0f2e75f80065.svg" alt="img"> with respect to Φ is defined to be <img src="https://cdn.nlark.com/yuque/__latex/ac7ede85dacafad1dba3b81bd006caa9.svg" alt="img">. 其中，<img src="https://cdn.nlark.com/yuque/__latex/1cd3c9a3bf58afcb14b46cef9582d75a.svg" alt="img"></li>
<li>if ∆Φi &gt; 0, then ĉi &gt; ci. Operation i stores work in the data structure for later use; If ∆Φi &lt; 0, then ĉi &lt; ci. The data structure delivers up stored work to help pay for operation i.</li>
</ul>
<p>The total amortized cost of n operations is:</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/7c0b9890c61e98513055d27d89a8c9e6.svg" alt="img"></p>
<p><strong>例子略</strong> </p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><ul>
<li>Amortized costs can provide a clean abstraction of data-structure performance.</li>
<li>Any of the analysis methods can be used when an amortized analysis is called for, but each method has some situations where it is arguably the simplest or most precise.</li>
<li>Different schemes may work for assigning amortized costs in the accounting method, or potentials in the potential method, sometimes yielding radically different bounds.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:01:39 / 修改时间：17:05:47" itemprop="dateCreated datePublished" datetime="2021-02-28T17:01:39+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树中关键字的存储方式总是满足以下的二叉查找树性质：</p>
<ul>
<li>设x为二叉查找树中的一个结点。如果y是x的左子树中的一个结点，则<img src="https://cdn.nlark.com/yuque/__latex/0b68d2ce7eb0d3141ee4aa4bcc2270b7.svg" alt="img">。如果y是x的右子树中的结点，则<img src="https://cdn.nlark.com/yuque/__latex/5c14372f94ace8cd2d27a35597d66303.svg" alt="img">。</li>
</ul>
<p>根据二叉树的性质，可以用一个递归算法按排列顺序输出树中的所有关键字，即中序遍历算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void inOrderTreeWalk(TreeNode x)&#123;</span><br><span class="line">    if(x！&#x3D;null)&#123;</span><br><span class="line">        inOrderTreeWalk(x.left);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        inOrderTreeWalk(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定理</strong> ：如果x是一棵包含n个结点的子树的根，则调用InOrderTreeWalk(x)过程的时间为Θ(n)。</p>
<h2 id="查询二叉查找树"><a href="#查询二叉查找树" class="headerlink" title="查询二叉查找树"></a>查询二叉查找树</h2><p><strong>查找一个给定的关键字</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode treeSearch(TreeNode x, int k)&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;null || x.val&#x3D;&#x3D;k)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k&lt;x.val)</span><br><span class="line">        return treeSearch(x.left,k);</span><br><span class="line">    else</span><br><span class="line">        return treeSearch(x.right.k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用非递归算法（While循环）来实现，在大多数计算机上，非递归版本运行的要更快一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public iterativeTreeSearch(TreeNode x, int k)&#123;</span><br><span class="line">    while(x!&#x3D;null &amp;&amp; k!&#x3D;x.val)&#123;</span><br><span class="line">        if(k&lt;x.val)</span><br><span class="line">            x &#x3D; x.left;</span><br><span class="line">        else</span><br><span class="line">            x &#x3D; x.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最大关键字元素和最小关键字元素</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode treeMinimun(TreeNode x)&#123;</span><br><span class="line">    while(x.left!&#x3D;null)&#123;</span><br><span class="line">        x &#x3D; x.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大关键字类似。对高度为h的树，这两个过程的运行时间都是O(h)。</p>
<p><strong>前趋和后继</strong> </p>
<p>给定一个二叉查找树中的结点，有时候要求找出在中序遍历顺序下它的后继，如果所有的关键字均不相同，则某一个结点x的后继即具有大于key[x]中的关键字中的最小值的那个结点。</p>
<p>若s的右子树为空，则从x向上查找，直到遇到某个是其父节点的左儿子的结点为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x)</span><br><span class="line">if right[x]!&#x3D;null&#123;</span><br><span class="line">    then return treeMinimum(x.right);</span><br><span class="line">y &#x3D; p[x]</span><br><span class="line">whilr y!&#x3D;null and x &#x3D; right[y]</span><br><span class="line">    do x &#x3D; y</span><br><span class="line">     y &#x3D; p[y]</span><br><span class="line">return y</span><br></pre></td></tr></table></figure>

<h2 id="删除和插入"><a href="#删除和插入" class="headerlink" title="删除和插入"></a>删除和插入</h2><p><strong>插入</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void treeInsert(TreeNode x, int z)&#123;</span><br><span class="line">    TreeNode pre &#x3D; null;</span><br><span class="line">    TreeNode cur &#x3D; x;</span><br><span class="line">    while(cur!&#x3D;null)&#123;</span><br><span class="line">        pre &#x3D; cur;</span><br><span class="line">        if(z&lt;x.val)</span><br><span class="line">            cur &#x3D; cur.left;</span><br><span class="line">        else</span><br><span class="line">            cur &#x3D; cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre&#x3D;&#x3D;null)</span><br><span class="line">        x &#x3D; new TreeNode(z);</span><br><span class="line">    else if(z&lt;pre.val)</span><br><span class="line">        pre.left &#x3D; new TreeNode(z);</span><br><span class="line">    else</span><br><span class="line">        pre.right &#x3D; new TreeNode(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和其他查找树上的原始操作一样，过程TreeInsert的运行时间也为O(h).</p>
<p><strong>删除</strong> </p>
<p>给定结点z从二叉查找树中删除的过程以指向z的指针为参数，并考虑三种情况：1）如果z没有子女，则修改其父节点p[z]，使NIL为其子女；如果结点z只有一个子女，则通过在其子节点与父节点间建立一条链来删除z。最后，如果结点z有两个子女，先删除z的后继y（没有左儿子），再用y的内容来替代z的内容。 <strong>以下代码并不完善</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void treeDelete(TreeNode z)&#123;</span><br><span class="line">    if(z.left&#x3D;&#x3D;null &amp;&amp; z.right&#x3D;&#x3D;null)&#123;</span><br><span class="line">        &#x2F;&#x2F;没有孩子</span><br><span class="line">        p[z].next &#x3D; null; &#x2F;&#x2F;其父节点连接null</span><br><span class="line">    &#125;else if(z.right!&#x3D;null &amp;&amp; z.left!&#x3D;null)&#123;</span><br><span class="line">        x &#x3D; treeMinimum(z.right);</span><br><span class="line">        z.val &#x3D; x.val;</span><br><span class="line">        treeDelete(x);</span><br><span class="line">    &#125;else if(z.right !&#x3D;null)&#123;</span><br><span class="line">        p[z].next &#x3D; z.right;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        p[z].next &#x3D; z.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定理</strong> 对高度为h的二叉查找树，动态集合操作INSERT和DELETE的运行时间为O(h)。</p>
<p><strong>The Relation to QuickSort:</strong><br>BST Sort &amp; QuickSort make same comparisons but in a different order.</p>
<h2 id="随机构造的二叉树"><a href="#随机构造的二叉树" class="headerlink" title="随机构造的二叉树"></a>随机构造的二叉树</h2><p><strong>步骤</strong> ：</p>
<ul>
<li>Randomly permite A</li>
<li>BST Sort(A)</li>
</ul>
<p>Time(BST) = Time(Randomized-QuickSort)</p>
<p><strong>定理</strong> </p>
<p><strong>一棵在n个关键字上随机构造的二叉查找树的期望高度为O(lgn)。</strong></p>
<h1 id="Balanced-Search-Tree"><a href="#Balanced-Search-Tree" class="headerlink" title="Balanced Search Tree"></a>Balanced Search Tree</h1><p>search tree data structure maintaining dynamic set of n elements using a tree of height order <strong>lgn</strong> .</p>
<p><strong>Examples</strong> </p>
<ul>
<li>AVL Tree</li>
<li>2-3 Tree</li>
<li>2-3-4 Tree</li>
<li>B Tree</li>
<li>Red-Black Trees</li>
<li>Skip lists</li>
<li>Treaps</li>
</ul>
<h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p>BST data structure with <strong>extra color</strong> field for each node satisfying.</p>
<p><strong>Red-Black properties</strong> </p>
<ol>
<li>Every Node is either red or black</li>
<li>the root and the leaves(nil’s) are black</li>
<li><strong>Every red node has black parent</strong> </li>
<li>All simple paths from a node x to a descended leaf of x have <strong>same number of black nodes</strong> . which means have the <strong>same black-height(x)</strong> </li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607175972577-de09ec02-a0d2-410e-a2f1-62141f0803d1.png" alt="image.png"></p>
<p><strong>定理</strong> ： <strong>Red-Black tree with n keys has height h &lt;= 2lg(n+1)</strong> </p>
<p>证明：《算法导论》上有归纳法的详细证明</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607178361377-faade872-4db3-4b0b-a925-376377132939.png" alt="image.png"></p>
<ul>
<li>Merge red nodes into their black parents.</li>
<li>This process produce a tree in which each node  has 2,3 or 4 children</li>
<li>the 2-3-4 tree has uniform depth h’ of leaves</li>
<li>We have <img src="https://cdn.nlark.com/yuque/__latex/71ea6a1b4e5c283c27e3e1688fab7e72.svg" alt="img">, since at most half the leaves on any path are red</li>
<li>The number of leaves in each tree is n+1<img src="https://cdn.nlark.com/yuque/__latex/5475dbf1000faf21127c46a2734b1fbb.svg" alt="img"></li>
</ul>
<p><strong>Corollary</strong> . The queries <em>Search, Min, Max, Successor, and Predecessor</em> all run in <strong>O(lgn)</strong> time on a red-black tree with <strong>n</strong> nodes.</p>
<p><strong>Modifying operations</strong> </p>
<p>The operations Insert and Delete cause modifications to the red-black tree:</p>
<ul>
<li>the operation itself,</li>
<li>color changes,</li>
<li>restucturing the links of the tree via <strong>rotations</strong> </li>
</ul>
<h3 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607179845880-0cf3fbb7-2ecd-49bb-b12e-e68921943f67.png" alt="image.png"></p>
<p>A rotation can be performed in <strong>O(1)</strong> time.</p>
<h3 id="Insertion-into-a-red-black-tree"><a href="#Insertion-into-a-red-black-tree" class="headerlink" title="Insertion into a red-black tree"></a>Insertion into a red-black tree</h3><p><strong>IDEA</strong> : Insert x in tree. Color x red. Only red-black property 3 might be violated. Move the violation up the tree by recoloring until it can be fixed with rotations and recolored.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180036211-4ca11487-0a92-4ed1-a342-7fd9c30b758a.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,x)</span><br><span class="line">    Tree-INSERT(T,x)</span><br><span class="line">  color[x]&#x3D;red</span><br><span class="line">  while x!&#x3D;root[T] and color[p[x]]&#x3D;RED</span><br><span class="line">    do if p[x]&#x3D;left[p[p[x]]]</span><br><span class="line">        then y&#x3D;right[p[p[x]]]</span><br><span class="line">        if color[y]&#x3D;RED</span><br><span class="line">        then &lt;Case 1&gt;</span><br><span class="line">        else if x&#x3D;right[p[x]]</span><br><span class="line">            then &lt;case 2&gt;</span><br><span class="line">        &lt;Case 3&gt;</span><br><span class="line">      else&lt;&quot;Then&quot; clause with &quot;left&quot; and &quot;right&quot; swapped&gt;</span><br><span class="line">  color[root[T]]&#x3D;black</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180316709-9a8490be-003f-4126-9577-3584a8dd3087.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180326781-f9a4a4df-9930-42ac-9307-0759fd873cb2.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607180388203-0f9bc8c6-8492-4876-8dee-5883a177c84e.png" alt="image.png"></p>
<p><strong>Analysis</strong> </p>
<ul>
<li>Go up the tree performing Case 1, with only recolors node.</li>
<li>If Case 2 or Case 3 occurs, perform 1 or 2 rotations, and terminate.</li>
</ul>
<p><strong>Running Time</strong> </p>
<p><strong>O(lgn)</strong> with <strong>O(1)</strong> rotations.</p>
<p>RB-Delete: same asymptotic running time and number of rotations as RB-Insert(See textbook).</p>
<h1 id="扩充的数据结构、动态有序统计和区间树"><a href="#扩充的数据结构、动态有序统计和区间树" class="headerlink" title="扩充的数据结构、动态有序统计和区间树"></a>扩充的数据结构、动态有序统计和区间树</h1><p>augmentation data structures 数据结构的扩充</p>
<h2 id="Dynamic-order-statistics"><a href="#Dynamic-order-statistics" class="headerlink" title="Dynamic order statistics"></a>Dynamic order statistics</h2><p>新增的两个操作：</p>
<ul>
<li>OS-Select(i): returns i-th smallest item in dynamic set</li>
<li>OS-Rank(i): returns rank of x in sorted order.</li>
</ul>
<p><strong>IDEA</strong> : <strong>Keep subtree size in node of r-b trees</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607327491484-617b49bf-cd80-4ba2-8ad9-bad2f661a185.png" alt="image.png"></p>
<p><strong>size[x] = size[left[x]]+size[right[x]]+1</strong> </p>
<h3 id="OS-Select-i"><a href="#OS-Select-i" class="headerlink" title="OS-Select(i)"></a>OS-Select(i)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OS-Select(x,i) &#x2F;&#x2F;i-th smallest in subtree rooted at x</span><br><span class="line">    r &#x3D; x.left.size + 1; &#x2F;&#x2F;rank of x</span><br><span class="line">  if i&#x3D;&#x3D;r</span><br><span class="line">    return x</span><br><span class="line">  else if i&lt;r</span><br><span class="line">    return OS-Select(x.left,i)</span><br><span class="line">  else</span><br><span class="line">    return OS-Select(x.right,i-r)</span><br></pre></td></tr></table></figure>

<h3 id="OS-Rank-i"><a href="#OS-Rank-i" class="headerlink" title="OS-Rank(i)"></a>OS-Rank(i)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OS-RANK(T,x)</span><br><span class="line">    r &#x3D; x.left.size + 1</span><br><span class="line">  y &#x3D; x</span><br><span class="line">  while y!&#x3D;T.root</span><br><span class="line">    if y&#x3D;&#x3D;y.p.right</span><br><span class="line">        r &#x3D; r + y.p.left.size + 1</span><br><span class="line">    y &#x3D; y.p</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure>

<p><strong>Analysis</strong> T(n)=<strong>O(lgn)</strong></p>
<p>Q: Why not keep the ranks in nodes instead of subtree sizes?</p>
<p>A: It’s hard to maintain when t-b tree is motified.</p>
<p><strong>Mutifying operations: Insert and Delete</strong> </p>
<p><strong>Stratege</strong> : Update subtree sizes when inserting or deleting.</p>
<p>EX:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607327990012-11baa4a2-5670-402e-8f69-69029764e4f3.png" alt="image.png"></p>
<p><strong>but also need to handle rebalancing</strong> </p>
<ul>
<li>r-b color changes: no effect to size</li>
<li>rotation: look at children and fix up in O(1) time</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607328155405-cda58171-a018-4a0d-b12b-7da039806060.png" alt="image.png"></p>
<p>So,  <strong>RB-Insert and RB-Delete still run in O(lgn) time</strong> </p>
<h3 id="Data-structrue-augmentation"><a href="#Data-structrue-augmentation" class="headerlink" title="Data-structrue augmentation"></a>Data-structrue augmentation</h3><p><strong>Methodology</strong> : (e.g. order-statistics trees)</p>
<ol>
<li>Choose an underlying data structrue.(red-black trees)</li>
<li>Determine additional information to be stored in the data structure.(subtree size)</li>
<li>Verify that this information can be maintained for modifying operations.(RBINSERT, RB-DELETE — don’t forget rotations)</li>
<li>Develop new dynamic-set operations that use the informations.(OS-Select and OS-Rank)</li>
</ol>
<p><strong>These steps are guidelines, not rigid rules</strong> </p>
<h2 id="Example-Interval-trees-区间树"><a href="#Example-Interval-trees-区间树" class="headerlink" title="Example: Interval trees 区间树"></a>Example: Interval trees 区间树</h2><p><strong>IDEA</strong> ：maintain a set of intervals. e.g. time intervals</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607329725240-770943dd-5a03-45f2-955f-b7ce8e9627fc.png" alt="image.png"></p>
<p><strong>Query</strong> : For a given query interval i, find an interval in the set that overlaps i.</p>
<h3 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a><strong>Methodology</strong></h3><ol>
<li>Choose an underlying data structure.</li>
</ol>
<p>(Red-Black Tree key on <strong>low(left) endpoint</strong> )</p>
<ol>
<li>Determine additional information to be stored in the data structure.</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607329913708-467fd2f4-8e79-4fa7-9bc9-2e3da3176d14.png" alt="image.png"></p>
<ol>
<li>Modifying operations:<br><strong>Insert: fix m’s on way down</strong> .</li>
</ol>
<p>​    Rotations——Fixup = <strong>O(1)</strong>  time per rotation:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607330009760-b6920705-4e40-40ce-a980-a15b3a0fc014.png" alt="image.png"></p>
<p>So, <strong>Total Insert Time = O(lgn)</strong>  Delete similar</p>
<ol>
<li>Develop new dynamic-set operations that use the information.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INTERVAL-SEARCH(T,i)</span><br><span class="line">    x &#x3D; T.root</span><br><span class="line">  while x!&#x3D;nil and (low[i]&gt;high[int[x]] or high[i]&lt;low[int[x]]) &#x2F;&#x2F; i does not overlaps x</span><br><span class="line">    if x.left!&#x3D;nil and x.left.m &gt;&#x3D; low[i]</span><br><span class="line">        x&#x3D;x.left</span><br><span class="line">    else x &#x3D; x.right</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure>

<p><strong>List all overlaps: O(klgn)</strong> <strong>Output sensitive</strong> </p>
<p><strong>Correctness</strong> </p>
<p>Theorem. Let L be the set of intervals in the left subtree of node x, and let R be the set of intervals in x’s right subtree.</p>
<p><strong>If the search goes right, then</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/4367610265a8d75d48ee1815aa026566.svg" alt="img"></p>
<p><strong>If the search goes left, then</strong> </p>
<p><img src="https://cdn.nlark.com/yuque/__latex/3a302c645f324058b030290ff28bf071.svg" alt="img"></p>
<p><strong>证明略</strong> </p>
<h2 id="补充1：2-3数"><a href="#补充1：2-3数" class="headerlink" title="补充1：2-3数"></a>补充1：2-3数</h2><p><strong>2–3树</strong>是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">树型数据结构</a>，内部节点（存在子节点的节点）要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果一个内部节点拥有一个数据元素、两个子节点，则此节点为<strong>2节点</strong>。</p>
<p>如果一个内部节点拥有两个数据元素、三个子节点，则此节点为<strong>3节点</strong>。</p>
<p>当且仅当以下叙述中有一条成立时，<em>T</em>为2–3树：</p>
<ul>
<li><em>T</em>为空。即<em>T</em>不包含任何节点。</li>
<li>为拥有数据元素<em>a</em>的2节点。若<em>T</em>的左孩子为<em>L</em>、右孩子为<em>R</em>，则：<em>L</em>和<em>R</em>是等高的非空2–3树；<em>a</em>大于<em>L</em>中的所有数据元素；且<em>a</em>小于等于<em>R</em>中的所有数据元素。</li>
<li><em>T</em>为拥有数据元素<em>a</em>和<em>b</em>的3节点，其中<em>a</em> &lt; <em>b</em>。若<em>T</em>的左孩子为<em>L</em>、中孩子为<em>M</em>、右孩子为<em>R</em>，则：<em>L</em>、<em>M</em>、和<em>R</em>是等高的非空2–3树；<em>a</em>大于<em>L</em>中的所有数据元素，并且小于等于<em>M</em>中的所有数据元素；<em>b</em>大于<em>M</em>中的所有数据元素，并且小于等于<em>R</em>中的所有数据元素。</li>
</ul>
<h3 id="2-3树的查找"><a href="#2-3树的查找" class="headerlink" title="2-3树的查找"></a>2-3树的查找</h3><p>与普通二叉搜索树相似。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408159789-043b9fd7-732e-474f-922d-17767f22ac6f.png" alt="image.png"></p>
<h3 id="2-3树的插入"><a href="#2-3树的插入" class="headerlink" title="2-3树的插入"></a>2-3树的插入</h3><p>前面我们知道，2-3查找树分为<strong>2结点</strong>和<strong>3结点</strong>，so，插入就分为了2结点插入和3结点插入。</p>
<p><strong>2-结点插入:</strong> 向2-结点插入一个新的结点和向而插入插入一个结点很类似，但是我们并不是将结点“吊”在结点的末尾，因为这样就没办法保持树的平衡。我们可以将2-结点替换成3-结点即可，将其中的键插入这个3-结点即可。（相当于缓存了这个结点）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408378995-5aa5404b-52dc-4638-a459-63aceefc5898.png" alt="image.png"></p>
<p><strong>3-结点插入：</strong> 3结点插入比较麻烦，它分为3种情况：</p>
<ol>
<li>向一棵只含有3-结点的树插入新键。</li>
</ol>
<p>​    假如2-3树只有一个3-结点，那么当我们插入一个新的结点的时候，我们先假设结点变成了4-结点，然后使得中间的结点为根结点，左边的结点为其左结点，右边的结点为其右结点，然后构成一棵2-3树，<strong>树的高度加1</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408488175-b4dacd99-b514-41e1-813c-ce85e1aa6323.png" alt="image"></p>
<ol>
<li>向父结点为2-结点的3-结点中插入新键。</li>
</ol>
<p>和上面的情况类似，我们将新的节点插入3-结点使之成为4-结点，然后将结点中的中间结点”升“到其父节点（2-结点）中的合适的位置，使其父节点成为一个3-节点，然后将左右节点分别挂在这个3-结点的恰当位置，<strong>树的高度不发生改变。</strong></p>
<p>**<br>**<img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408543768-2c76d858-f678-4653-a4be-d6a5a5373020.png" alt="image"></p>
<ol>
<li>向父节点为3-结点的3-结点中插入新键。</li>
</ol>
<p>​    这种情况有点类似递归：当我们的结点为3-结点的时候，我们插入新的结点会将中间的元素”升“父节点，然后父节点为4-结点，右将中间的结点”升“到其父结点的父结点，……如此进行递归操作，直到遇到的结点不再是3-结点。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1607408606615-da5cf49b-6e5b-4c5c-949f-4fc29d535e97.png" alt="image"></p>
<p><strong>树的高度</strong> ：<img src="https://cdn.nlark.com/yuque/__latex/03a539bfcefdaf30db1bf6a92c136a69.svg" alt="img"></p>
<h2 id="补充2-B树"><a href="#补充2-B树" class="headerlink" title="补充2-B树"></a>补充2-B树</h2><p>B树是为磁盘或其他直接存取辅助存储设备而设计的一种平衡查找树。与红黑树类似，但在降低磁盘I/O操作次数方面要更好一些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 17:00:27 / 修改时间：17:01:10" itemprop="dateCreated datePublished" datetime="2021-02-28T17:00:27+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列表是普通数组概念的推广，因为可以对数组进行直接寻址，故可以在O(1)的时间内访问数组的任意元素。</p>
<h2 id="直接寻址法"><a href="#直接寻址法" class="headerlink" title="直接寻址法"></a>直接寻址法</h2><p>当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。假设某应用要用到一个动态集合，其中每个元素都有一个取自全域U={0,1,…,m-1}的关键字，此处m是一个很大的数。另，假设没有两个元素具有相同的关键字。</p>
<p>为表示动态集合，我们用一个数组（或称直接寻址表）T[0,…,m-1]，其中每个位置（或称槽）对应全域U中的一个关键字。对SEARCH、INSERT、DELETE等操作均只需O(1).</p>
<h2 id="散列表-1"><a href="#散列表-1" class="headerlink" title="散列表"></a>散列表</h2><p>直接寻址技术存在一个明显的问题：如果域U很大，在一台典型计算机的可用内从容量限制下，要在机器中存储大小为|U|的一张表T就优点不切实际，甚至不可能。还有，实际要存储的关键字集合K相对于U来说可能很小，因而分配给T 的大部分空间都要浪费掉。</p>
<p>在直接寻址方式下， <strong>具有关键字k的元素被存放在槽k中</strong> 。在散列方式下， <strong>该元素处于h(k)中</strong> 。即利用散列函数h，根据关键字k计算出槽的位置。 <strong>函数h将关键字域U映射到散列表T[0,…,m-1]的槽位上</strong> 。</p>
<p>这样做有一个小问题： <strong>两个关键字可能映射到同一个槽位上</strong> ，我们称之为 <strong>碰撞</strong> 。</p>
<h3 id="通过链接法来解决碰撞"><a href="#通过链接法来解决碰撞" class="headerlink" title="通过链接法来解决碰撞"></a>通过链接法来解决碰撞</h3><p>在链接法中，把散列到同一槽的所有元素都放在一个链表中。槽j中有一个指针，它指向由所有散列到j的元素构成的链表的头。</p>
<p>采用链接法后散列表的性能怎么样呢？特别的，要查找一个具有给定关键字的元素需要多长时间？</p>
<p>给定一个能存放n个元素的、具有m个空槽位的散列表T，定义T的装载因子(Load factor)<img src="https://cdn.nlark.com/yuque/__latex/f50c6d3557faf32740b6b49917e5b0f1.svg" alt="img">，即一个链表中平均存储的元素数。</p>
<p>Worst-Case：所有的n个关键字都散列到同一个槽内，<strong>Θ(n)</strong>.</p>
<p>若假定任何元素散列到m个槽中的每一个可能性是相同的，且与其他元素已被散列到什么位置上是无关的，即 <strong>简单一致性假设</strong> </p>
<p><strong>则在简单一致性假设下，对于用链接技术解决碰撞的散列表，平均情况下一次成功或不成功的查找需要</strong> <img src="https://cdn.nlark.com/yuque/__latex/a0a8d5c552af1b569cf03e4f7e0c5d77.svg" alt="img"></p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>在这一节里，讨论一些有关如何设计出好的散列函数的问题。</p>
<h3 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h3><p>通过取k除以m的余数，来将关键字k映射到m个槽的某一个去。即，散列函数为 <strong>h(k) = k mod m</strong> </p>
<p>当应用除法散列时，应 <strong>注意m的选择</strong> 。可以选作m的值常常是 <strong>与2的整数幂不太接近的质数</strong> </p>
<h3 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h3><p>构造散列函数的乘法方法包含两个步骤：首先，用关键字k乘上常数A（0&lt;A&lt;1），并抽出kA的小数部分。然后用m乘以这个值，再取结果的底。总之，散列函数为</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/7126e1116411a1c9095b27e8906f8ddd.svg" alt="img"></p>
<h3 id="全域散列"><a href="#全域散列" class="headerlink" title="全域散列"></a>全域散列</h3><p>如果让某个和你作对的人来选择要散列的关键字，那么他会选择全部散列到同一个槽中的n个关键字，使得平均检索时间为<strong>Θ(n)**。任何一个特定的散列函数都可能出现这种最坏情况形态：唯一有效的改进方法是 **随机地选择散列函数</strong> ，使之独立于要存储地关键字，这种方法称之为 <strong>全域散列</strong> 。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法（openning addressing）中，所有的元素都存放在散列表里。亦即，每个表项或包含动态集合的一个元素，或包含nil。当查找一个元素时，要检查所有的表项，直到找到所需元素，或最终发现该元素不在表中。</p>
<p><strong>线性勘查</strong> </p>
<p>当冲突发生时，使用某些探测技术在散列表中形成一个探测序列，沿此序列逐个单元查找，直到找到给定的关键字、或者碰到一个开放地 址（即该地址单元为空、空桶）为止。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/2997786/1606997448519-ae4bc0eb-c36c-4874-a603-ac2a9bb86dd6.png" alt="image.png"></p>
<p><strong>双重散列</strong> </p>
<p>双重散列是用于开放寻址的最好方法之一，因为它所产生的排列具有随机选择的排列的许多特性。它采用如下形式的散列函数：</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/602cda7c22ffc6dd4c89cc272f40b65b.svg" alt="img"></p>
<h3 id="对开放寻址散列的分析"><a href="#对开放寻址散列的分析" class="headerlink" title="对开放寻址散列的分析"></a>对开放寻址散列的分析</h3><p><strong>Assumption</strong> : <strong>一致散列法</strong> ：在这种理想的方法中，用于插入或查找每一个关键字k的探索序列为&lt;0,1,…,m-1&gt;的任一中排列的可能性是相同的。</p>
<p>则在该假设下： <strong>给定一个装载因子a=n/m&lt;1的开放寻址散列表，在一次不成功的查找中，期望的勘察天数至多为1/(1-a)</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 16:58:21 / 修改时间：16:59:43" itemprop="dateCreated datePublished" datetime="2021-02-28T16:58:21+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>在排序算法中使用的是最大堆，最小堆通常在构造优先序列时使用。</p>
<h3 id="保持堆的性质"><a href="#保持堆的性质" class="headerlink" title="保持堆的性质"></a>保持堆的性质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">l&#x3D;left(i);</span><br><span class="line">r&#x3D;right(i);</span><br><span class="line">if l&lt;&#x3D;heap-size[A] and A[l]&gt;A[i]</span><br><span class="line">    then largest &#x3D; l</span><br><span class="line">else largest &#x3D; i;</span><br><span class="line">    if r&lt;&#x3D;heap-size[A] and A[r]&gt;A[largest]</span><br><span class="line">        then largest &#x3D; r</span><br><span class="line">if(largest!&#x3D;r)</span><br><span class="line">    then exchange A[i],A[largest]</span><br><span class="line">    Max-Heapify(A,largest)</span><br></pre></td></tr></table></figure>

<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>可以自底而上地用MAX-HEAPIFY来将一个数组A[1…n]变成最大堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">heap-size[A] &#x3D; length[A]</span><br><span class="line">for i &#x3D; length(A)&#x2F;2 向上取整 downto 1</span><br><span class="line">    do MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure>

<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAPSORT(A)</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">for i&#x3D;length(A) down to 2</span><br><span class="line">    do swap(A,l,i)</span><br><span class="line">  heap-size[A] &#x3D; heap-size[A]-1</span><br><span class="line">  MAX-HEAPIFY(A,l)</span><br></pre></td></tr></table></figure>

<h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><p><strong>How Fast can we sort?</strong> depends on model of what you can do with the elements!</p>
<p>目前学习的插入排序、归并排序、快速排序以及堆排序都是基于 <strong>比较排序</strong> 的算法。</p>
<h3 id="排序算法的下界"><a href="#排序算法的下界" class="headerlink" title="排序算法的下界"></a>排序算法的下界</h3><p>比较排序可以被抽象地视为决策树。一棵决策树是一棵满二叉树，表示某排序算法作用于给定输入所作的所有比较，而控制结构、数据移动等都被忽略了。</p>
<p>Comparision Sorting: only use comparisons to determine the relative order of elements. </p>
<p>Runing time(#Comparisons)=length of path</p>
<p>Worst-case running time = height of tree</p>
<p><strong>Lower bound on decision-tree sorting:</strong> </p>
<p><strong>Any decision-tree sorting n elements has the height</strong>  <img src="https://cdn.nlark.com/yuque/__latex/3320c7a3017e0a921a83c91bfeba4ea3.svg" alt="img"></p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>基本思想</strong> 对每一个输入元素x，确定出小于x的元素个数。</p>
<p><strong>前提</strong> n个输入元素中的每一个都是0到k之间的整数。</p>
<p>在计数排序算法的代码中，我们假定输入是n个数的数组A，存放排序结果的B，以及提供临时存储区的C（0…k）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void countingSort(int[] A, int[] B, k)&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    int n &#x3D; A.length;</span><br><span class="line">    int[] C &#x3D; new int[k];</span><br><span class="line">    for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">        C[A[i]] &#x3D; C[A[i]]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1; i&lt;k; i++)&#123;</span><br><span class="line">        C[i] &#x3D; C[i-1]+C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;n-1; i&gt;&#x3D;0; i--)&#123;</span><br><span class="line">        B[C[A[i]]] &#x3D; A[i];</span><br><span class="line">        C[A[i]] &#x3D; C[A[i]]-1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>T(n) = Θ(n+k)</strong> </p>
<h3 id="基数排序（Hallerith-1890）"><a href="#基数排序（Hallerith-1890）" class="headerlink" title="基数排序（Hallerith 1890）"></a>基数排序（Hallerith 1890）</h3><p>从低位向高位依次排序， <strong>要求按位排序要稳定</strong> </p>
<p>定理：给定n个d位数，每一个数位可以取k种可能的值，基数排序算法能以**Θ(d(n+k))**的时间正确地对这些数排序</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>当 <strong>桶排序</strong> 的输入符合均匀分布时，既可以实现线性时间运行。与计数排序类似，桶排序也对输入作了某种假设，因而运行很快：计数排序假设 <strong>输入是一个由小范围内的整数构成</strong> ，而桶排序则假设 <strong>输入有一个随机过程产生</strong> ，该过程将元素均匀地分布在区间[0,1]上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    int bucketNum &#x3D; (max - min) &#x2F; arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num &#x3D; (arr[i] - min) &#x2F; (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中位数和顺序统计学"><a href="#中位数和顺序统计学" class="headerlink" title="中位数和顺序统计学"></a>中位数和顺序统计学</h1><p>本章讨论从一个由n个不同数值构成的集合中选择其第i个顺序统计值的问题。为方便起见，假设集合中的数互异。</p>
<p>Input：一个包含n个（不同的）数的集合A和一个数i，<img src="https://cdn.nlark.com/yuque/__latex/9c5935072f94d570ccfcb75043b3f859.svg" alt="img">.</p>
<p>Output：<img src="https://cdn.nlark.com/yuque/__latex/ae04b7455d654ee119e014c9b0e805db.svg" alt="img"></p>
<p>该选择问题可以在<strong>O(nlgn)**时间内解决，因为可以用</strong>堆排序或合并排序**对输入数据进行排序，然后在输出数组中标出第i个元素即可。但还有其他更快的解法。</p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int Minmum(A)&#123;</span><br><span class="line">    int min &#x3D; A[0];</span><br><span class="line">    for(int i : A)&#123;</span><br><span class="line">        if(min&gt;i)</span><br><span class="line">            min &#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">    return min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以期望线性时间做选择"><a href="#以期望线性时间做选择" class="headerlink" title="以期望线性时间做选择"></a>以期望线性时间做选择</h3><p>介绍一种用来解决选择问题的分治算法，即RANDOMIZED-SELECT算法，以 <strong>快速排序算法</strong> 为模型。与快速排序不同的是，RANDOMIZED-SELECT <strong>只处理划分的一边</strong> 。这一差异使得快速排序的期望运行时间是 <strong>Θ(nlgn)</strong> ,而RANDOMIZED-SELECT的期望时间是 <strong>Θ(n)</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A,p,r,i)</span><br><span class="line">if(p&#x3D;&#x3D;r)</span><br><span class="line">    then return A[p]</span><br><span class="line">q &#x3D; RANDOMIZED-PARTITION(A,p,r);</span><br><span class="line">k &#x3D; q-p+1</span><br><span class="line">if i&#x3D;k</span><br><span class="line">    then return A[q]</span><br><span class="line">else if i&lt;k</span><br><span class="line">    then return RANDOMIZED-SELECT(A,p,q-1,i);</span><br><span class="line">else</span><br><span class="line">    then return RANDOMIZED-SELECT(A,q+1,r,i-k)</span><br></pre></td></tr></table></figure>

<p><strong>在平均情况下，任何顺序统计量（特别是中位数）都可以在线性时间内得到</strong> ，证明略。</p>
<h3 id="最坏情况线性时间的选择"><a href="#最坏情况线性时间的选择" class="headerlink" title="最坏情况线性时间的选择"></a>最坏情况线性时间的选择</h3><p>现在来看一个最坏情况运行时间为O(n)的选择算法SELECT。该算法的基本思想是要 <strong>保证对数组的划分上是个好的划分</strong> 。算法通过执行下列步骤来确定一个有n&gt;1个元素的输入数组中的第i小的元素：</p>
<ul>
<li>将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一个组由剩下的n mod 5个元素构成。</li>
<li>寻找n/5个组中每一组的中位数，首先对每组中的元素（至多5个）进行插入排序，然后从排序过的序列中选出中位数。</li>
<li>对第2步中找出的n/5个中位数，递归调用SELECT以找出中位数x</li>
<li>利用修改过的PARTITION过程，按中位数的中位数x对输入数组进行划分。让k比划分低区的元素数目多1，所以x是第k小的元素。</li>
<li>如果i==k，则返回x，否则，如果，i&lt;k，在低区递归调用SELECT，i&gt;k，在高区递归调用SELECT。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-28 16:56:35 / 修改时间：16:57:51" itemprop="dateCreated datePublished" datetime="2021-02-28T16:56:35+08:00">2021-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p><strong>分治模式</strong> </p>
<p><strong>分解（Divide）</strong>：将原问题分解成一系列子问题；</p>
<p><strong>解决（Conquer）</strong>：递归地解各子问题。若子问题足够小，则直接求解；</p>
<p><strong>合并（Combine）</strong>：将子问题的结果合并成原问题的解。</p>
<p>Ex.Merge Sort, Binary Search</p>
<h2 id="一些举例"><a href="#一些举例" class="headerlink" title="一些举例"></a>一些举例</h2><h3 id="powering-the-number"><a href="#powering-the-number" class="headerlink" title="powering the number"></a>powering the number</h3><p>given a number x, and integer <img src="https://cdn.nlark.com/yuque/__latex/c36c48c557a498703465d5431d607e60.svg" alt="img">, compute x^n</p>
<p>Native algorithm: <strong>Θ(n)</strong></p>
<p>Divide and conquer:</p>
<p><img src="https://cdn.nlark.com/yuque/__latex/49636e9e784d9d86cba24daa372ba700.svg" alt="img">  <strong>T(n)=**</strong>Θ(lgn)**</p>
<h3 id="Fibonacci-numbers"><a href="#Fibonacci-numbers" class="headerlink" title="Fibonacci numbers"></a>Fibonacci numbers</h3><p><img src="https://cdn.nlark.com/yuque/__latex/7be51ef698b6e78a7be66f6145259127.svg" alt="img"></p>
<p>Native recursive algorithm: Time <img src="https://cdn.nlark.com/yuque/__latex/0b5be7ae172ade05832c0c10cea793ac.svg" alt="img"></p>
<p>recursive squaring: 转化为矩阵：<img src="https://cdn.nlark.com/yuque/__latex/da906dce963bedafb27275c2c507589f.svg" alt="img"></p>
<h3 id="Matrix-Multiplition"><a href="#Matrix-Multiplition" class="headerlink" title="Matrix Multiplition"></a>Matrix Multiplition</h3><p>Input: A=[a_ij], B=[b_ij]</p>
<p>Output: C=[c_ij] = A*B, <img src="https://cdn.nlark.com/yuque/__latex/e0d06d1cd929c98b7ad638619b63b092.svg" alt="img"></p>
<p>standard algorithm: <strong>Θ(n^3)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i&#x3D;1 to n</span><br><span class="line">    do for j&#x3D;1 to n</span><br><span class="line">    do c_ij &#x3D; 0</span><br><span class="line">    for k&#x3D;1 to n</span><br><span class="line">        c_ij &#x3D; a_ik * b_kj + c_ij</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>IDEA</strong>:n<em>n matrix = 2</em>2 blank matrix of n/2 * n/2 sub matrix</p>
<p>need 8 recursive calls: T(n) = 8T(n/2)+Θ(n^2) = <strong>Θ(n^3)</strong></p>
<p><strong>Strassen’s algorithm:</strong></p>
<p><strong>IDEA</strong>:reduce recursive calls to 7 recursive calls</p>
<h3 id="二叉树遍历及相关特性"><a href="#二叉树遍历及相关特性" class="headerlink" title="二叉树遍历及相关特性"></a>二叉树遍历及相关特性</h3><p><strong>计算二叉树高度</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int TreeHeight(TreeNode root)&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;null)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(TreeHight(root.left),TreeHeight(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的遍历</strong> </p>
<p>前序遍历、中序遍历、后序遍历</p>
<h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><p>Native aglorithm recursive: need 4 recursive calls;</p>
<p>change to <strong>3 recursive calls</strong>;</p>
<h3 id="最近点对问题"><a href="#最近点对问题" class="headerlink" title="最近点对问题"></a>最近点对问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EfficientClosestPair(P,Q)</span><br><span class="line">if n&lt;&#x3D;3</span><br><span class="line">    return the minimal distance found by bruce-force aglorithm</span><br><span class="line">else</span><br><span class="line">    copy the first (n&#x2F;2)向上取整 points of P to array Pl</span><br><span class="line">  copy the same (n&#x2F;2) points from Q to arrays Ql</span><br><span class="line">  copy the remaining (n&#x2F;2)向下取整 points of P to array Pr</span><br><span class="line">  copy the same (n&#x2F;2)points from Q to array Qr</span><br><span class="line">  dl &#x3D; EfficientClosestPair(Pl,Ql)</span><br><span class="line">  dr &#x3D; EfficientClosestPair(Pr,Qr)</span><br><span class="line">  d &#x3D; min(dl,dr)</span><br><span class="line">  m &#x3D; P[(n&#x2F;2)-1].x</span><br><span class="line">  copy all the points of Q for which |x-m|&lt;d into array S[0...num-1]</span><br><span class="line">  dminsq &#x3D; d^2</span><br><span class="line">  for i&#x3D;0 to num-2 do</span><br><span class="line">    k &#x3D; i+1</span><br><span class="line">    while k&lt;&#x3D;num-1 and (S[k].x)-S[i].x)^2&lt;dminsq</span><br><span class="line">        dminsq &#x3D; min((S[k].x-S[i].x)^2+(S[k].y-S[i].y)^2,dminsq)</span><br><span class="line">      k&#x3D;k+1</span><br><span class="line"> return sqrt(dminsq)</span><br></pre></td></tr></table></figure>

<h1 id="快排和随机化算法"><a href="#快排和随机化算法" class="headerlink" title="快排和随机化算法"></a>快排和随机化算法</h1><h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><p>QuickSort: Hoare 1962</p>
<ul>
<li>Divide and conquer</li>
<li>sorts “in place”</li>
<li>very pratical( with turning)</li>
</ul>
<p><strong>step 1</strong>: Divide: Patition array into 2 subarrays around pivot x</p>
<p><strong>step 2</strong>: Recursively sort 2 subarrays</p>
<p><strong>step 3</strong>: combine: trivial</p>
<p><strong>key: linear-time partitioning subroutine</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int partition(int[] A, int left, int right)&#123;</span><br><span class="line">    pivot &#x3D; A[left];</span><br><span class="line">  i &#x3D; p;</span><br><span class="line">  for(j&#x3D;p+1; j&lt;&#x3D;q; j++)&#123;</span><br><span class="line">    if(A[j]&lt;pivot)&#123;</span><br><span class="line">        i++;</span><br><span class="line">      swap(A,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(A,left, i+1);</span><br><span class="line">  return i+1;</span><br><span class="line">&#125;</span><br><span class="line">public void QuickSort(int[] A,int left, int right)&#123;</span><br><span class="line">    if(left&gt;right)&#123;</span><br><span class="line">    int p &#x3D; partition(A, left, right);</span><br><span class="line">    QuickSort(A,left,p-1);</span><br><span class="line">    QuickSort(A, p+1, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>assume:</strong> all numbers distinct</p>
<p>T(n):</p>
<p><strong>Worst-Case:</strong> <strong>T(n)=T(n-1)+T(0)+**</strong>Θ(n) =** <strong>Θ(n^2)</strong></p>
<ul>
<li>input sorted or reversed sorted</li>
<li>one side of partition has no elements</li>
</ul>
<p><strong>Best-Case analysis( intution only)</strong></p>
<p>if we can really lucky, partition splits the array n/2, n/2, then T(n)=<strong>Θ(nlgn)</strong></p>
<p><strong>suppose:</strong> slipts is always 0.1:0.9  <strong>lucky</strong></p>
<p><strong>soppose</strong>: we alternate lucky, unlucky, lucky…  <strong>lucky</strong></p>
<h2 id="随机化快速排序算法（Randomized-QuickSort）"><a href="#随机化快速排序算法（Randomized-QuickSort）" class="headerlink" title="随机化快速排序算法（Randomized QuickSort）"></a>随机化快速排序算法（Randomized QuickSort）</h2><ul>
<li>the running time is independent of input ordering</li>
<li>no assumption about the input distribution</li>
<li>no specific input elicit worst-case behavior</li>
<li>the worst-case is detemined only by a random-number generator</li>
</ul>
<p>​    在这种方法中，不是始终采用A[r]作为主元，而是从子数组A[p…r]中随机选择一个元素，即将A[r]与从A[p…r]中随机选出的一个元素交换。<strong>即主元元素是随机选取的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-PARTITION(A,p,r)</span><br><span class="line">i&#x3D;random(p,r);</span><br><span class="line">swap(A,i,p);</span><br><span class="line">return partition(A,p,r);</span><br></pre></td></tr></table></figure>

<p>注意：关于时间复杂度证明的部分没看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">算法导论学习笔记（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 16:50:50" itemprop="dateCreated datePublished" datetime="2021-02-28T16:50:50+08:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-16 11:16:53" itemprop="dateModified" datetime="2021-09-16T11:16:53+08:00">2021-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本块内容为自学麻省理工《算法导论》公开课的学习记录笔记，罗列学习过程中的重点。</p>
<h1 id="算法入门"><a href="#算法入门" class="headerlink" title="算法入门"></a>算法入门</h1><p>problem sorting:</p>
<p>Input: n个数&lt;a 1 ,a 2 ,…a n &gt;</p>
<p>Output: 输入序列的一个排序，为非递减序列</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void InsertionSort(int[] A, int n)&#123;</span><br><span class="line">    for(int j&#x3D;2; j&lt;n; j++)&#123;</span><br><span class="line">    int key &#x3D; A[j];</span><br><span class="line">    int i &#x3D; j-1;</span><br><span class="line">    while(i&gt;&#x3D;0 &amp;&amp; A[i]&gt;key)&#123;</span><br><span class="line">        A[i+1] &#x3D; A[i];</span><br><span class="line">      i &#x3D; i-1;</span><br><span class="line">    &#125;</span><br><span class="line">    A[i+1] &#x3D; key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Running Time</strong> ：</p>
<ul>
<li>Depends on input(e.g. already sorted)</li>
<li>Depends on input size(6 elements vs 6000000 elements)</li>
</ul>
<p><strong>Kind of analysis</strong> :<br>Worst-Case( usually ): T(n) = max time on any input of size n;</p>
<p>Average-Case( sometimes ): T(n) = expected time over all inputs of size n; <strong>需要概率分析假设</strong></p>
<p>Best-Case</p>
<p><strong>What is insertionSort’s use time?</strong> </p>
<p>Depends on Computer！</p>
<ul>
<li>relative speed(on same computer)</li>
<li>absolute speed(on different computer)</li>
</ul>
<p><strong>BIG IDEA!</strong> </p>
<ul>
<li>Ignore machine-dependent <strong>constant</strong></li>
<li>Look at <strong>growth</strong> of the running time as n to 无穷</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>Idea:</strong></p>
<ul>
<li>if n=1, DONE</li>
<li>Recursively sort A[1,…,n/2] and A[n/2+1,…,n]</li>
<li>merge 2 sorted list</li>
</ul>
<h2 id="渐进记号"><a href="#渐进记号" class="headerlink" title="渐进记号"></a>渐进记号</h2><h3 id="Θ（BIG-Theta）"><a href="#Θ（BIG-Theta）" class="headerlink" title="Θ（BIG Theta）"></a>Θ（BIG Theta）</h3><p><img src="https://cdn.nlark.com/yuque/__latex/beb0b2ca4fddc9e24a116e5e4cc81e4d.svg" alt="img"></p>
<p><img src="https://pic.imgdb.cn/item/6142b6cd2ab3f51d91bd2dfa.png" alt="image.png"></p>
<h3 id="O（BIG-O）"><a href="#O（BIG-O）" class="headerlink" title="O（BIG O）"></a>O（BIG O）</h3><p><img src="https://cdn.nlark.com/yuque/__latex/6aba44a76360da53f49493b56a7e83e7.svg" alt="img"></p>
<p><img src="https://pic.imgdb.cn/item/6142b6f02ab3f51d91bd59e5.png" alt="image.png"></p>
<h3 id="Ω-BIG-Ω"><a href="#Ω-BIG-Ω" class="headerlink" title="Ω(BIG Ω)"></a>Ω(BIG Ω)</h3><p><img src="https://cdn.nlark.com/yuque/__latex/6163624eb23f49eed278177d3a37bf3b.svg" alt="img"></p>
<p><img src="https://pic.imgdb.cn/item/6142b7122ab3f51d91bd8629.png" alt="image.png"></p>
<h3 id="o-小-oh-and-ω-小-omege"><a href="#o-小-oh-and-ω-小-omege" class="headerlink" title="o(小-oh) and ω(小-omege)"></a>o(小-oh) and ω(小-omege)</h3><h2 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h2><p>代换法、递归树法、主定理法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/27/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="kiro-xu">
      <meta itemprop="description" content="Be who you want to be">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kiro的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/27/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">个人博客搭建记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-27 21:09:02" itemprop="dateCreated datePublished" datetime="2021-02-27T21:09:02+08:00">2021-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-28 14:03:18" itemprop="dateModified" datetime="2021-02-28T14:03:18+08:00">2021-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/102592286" target="_blank">参考</a></p>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>官网链接：<a herf="https://git-scm.com/" target="_blank">Git官网</a></p>
<p>需要注意的是，官网下载Git非常慢！推荐去镜像网址选择自己想要的版本下载：<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank">Git镜像下载地址</a></p>
<p>安装过程中，选择一半保持默认（安装路径自定），一路next即可。</p>
<p>完成后，任意位置右键打开Git bash，输入git –version命令，出现如下即可：</p>
<p><img src="https://i.loli.net/2021/02/27/Od3k9J2IYwiaNmD.png" alt="image.png"></p>
<h2 id="Git与Github的绑定"><a href="#Git与Github的绑定" class="headerlink" title="Git与Github的绑定"></a>Git与Github的绑定</h2><h3 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h3><blockquote>
<p>SSH（安全外壳协议，Secure Shell 的缩写）是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p>
</blockquote>
<p>任意位置Git bash，输入ssh命令，查看是否安装SSH。一般安装了 Git Bash，其自带了 SSH。</p>
<p>输入<code>ssh-keygen -t sra</code>命令，表示我们指定 RSA 算法生成密钥，然后敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub.文件位置在C:/Users/你的用户名/.ssh</p>
<p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。</p>
<p>进入github主页右上角-setting进入设置页面-SSH and GPG keys-new SSH key-将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击Add SSH key即可。</p>
<p><strong>验证是否成功</strong></p>
<p>Git Bash 中输入<code>ssh -T git@github.com </code>进行检验。出现如下即可。</p>
<p><img src="https://i.loli.net/2021/02/27/pV61RkGKqPgodyc.png" alt="image.png"></p>
<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>先设置全局github用户名与邮箱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name<span class="string">&quot;fangminXu&quot;</span></span><br><span class="line">$ git config --global user.email<span class="string">&quot;***@***.com&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法一：本地没有git库"><a href="#方法一：本地没有git库" class="headerlink" title="方法一：本地没有git库"></a>方法一：本地没有git库</h4><ol>
<li>直接将远程仓库clone到本地；</li>
<li>将文件添加并commit到本地仓库；</li>
<li>将本地仓库的内容push到远程仓库。</li>
</ol>
<p><strong>过程：</strong></p>
<p>github主页点击待clone项目-点击clone or download，再复制地址，然后进入我们准备存储 Git 仓库的目录：</p>
<p>输入<code>git clone https://github.com/...</code>地址即为github项目生成的url。</p>
<p>提交步骤：</p>
<p>新建文件-<code>git add</code> 命令将文件添加到了「临时缓冲区」，再用 <code>git commit -m</code> “提交信息” 将其提交到本地仓库，<code>git push origin master</code>将本地仓库提交到远程仓库，origin是远程主机的名字。</p>
<p>其他命令：git log 查看仓库提交日志； git status 查看仓库状态；</p>
<h4 id="方法二：本地有-Git-仓库，并且我们已经进行了多次-commit-操作"><a href="#方法二：本地有-Git-仓库，并且我们已经进行了多次-commit-操作" class="headerlink" title="方法二：本地有 Git 仓库，并且我们已经进行了多次 commit 操作"></a>方法二：本地有 Git 仓库，并且我们已经进行了多次 commit 操作</h4><ol>
<li>建立一个本地仓库进入，init 初始化；</li>
<li>关联远程仓库；</li>
<li>同步远程仓库和本地仓库；</li>
<li>将文件添加提交到本地仓库；</li>
<li>将本地仓库的内容 push 到远程仓库。</li>
</ol>
<p>过程：</p>
<p>我们建立一个本地仓库 demo，使用 <code>git init</code> 命令初始化这个仓库，输入 <code>git remote add origin 网址</code>命令，关联远程仓库，接着输入 <code>git pull origin master</code> 命令，同步远程仓库和本地仓库，接下来的步骤就与第一种方法一样（可以参考上面，已经写得很详细了），先输入<code>git add</code>和 <code>git commit </code>命令，将要提交的文件添加并提交到 demo 仓库；然后再输入     git push origin master     命令，将本地仓库修改（或者添加）的内容提交到远程仓库就完成啦！！！</p>
<h2 id="安装node-js和Hexo"><a href="#安装node-js和Hexo" class="headerlink" title="安装node.js和Hexo"></a>安装node.js和Hexo</h2><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p><a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/" target="_blank">nodejs下载官网</a></p>
<p>安装完成后，用cmd检验是否安装完成。用 <code>node -v</code> 和 <code>npm -v</code> 命令检查版本。</p>
<p><strong>设置npm在安装全局模块时的路径和环境变量</strong></p>
<ol>
<li>在 nodejs 文件夹中新建两个空文件夹 node_cache、node_global</li>
<li>打开cmd，输入如下两个命令：</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>设置环境变量：<strong>win10系统 –&gt; 打开控制面板 –&gt; 系统 –&gt;高级系统设置 –&gt; 环境变量 ，</strong>然后在系统变量中新建一个变量名为“NODE_PATH”，连到新建的node_global\node_modules</p>
</li>
<li><p>然后编辑用户变量里的Path，将相应npm的路径改为：新建的node_global</p>
</li>
<li><p>在 cmd 命令下执行 <code>npm install webpack -g </code> webpack 这个模块已经在我们设置默认的文件夹中即成功</p>
</li>
</ol>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>Hexo就是我们的个人博客网站的框架，在安装之前，我们要先在GitHub上创立一个仓库：<strong>仓库名为：用户名.github.io</strong>，一定要是用户名！！！</p>
<p>建立一个文件夹 Blog，点开 Blog 文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo:<code>npm install -g hexo-cli</code></p>
<p>安装完成后，输入 <code>hexo init</code> 命令初始化博客：</p>
<p>然后输入 <code>hexo g</code> 静态部署</p>
<p>这时网页已经部署完成，输入<code>hexo s</code>命令可以查看，此时输入浏览器输入 <a href="https://link.zhihu.com/?target=http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86">http://localhost:4000</a> 就可以打开新部署的网页，ctrl +c 停止运行服务器。</p>
<h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><p>现在回到我们的 Blog 文件夹，用笔记本打开 _config.yml 文件，修改：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: fangminXuhttps://github.com/fangminXu/fangminXu.github.io.git  #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后分别输入以下三条命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>完成以后，打开浏览器，输入 <a href="https://link.zhihu.com/?target=https://fengye97.github.io/">https://xxx.github.io</a> 就可以打开你的网页了</p>
<h2 id="域名购买与解析"><a href="#域名购买与解析" class="headerlink" title="域名购买与解析"></a>域名购买与解析</h2><p>主要点：</p>
<p>IPV4地址可以通过ping得到，具体方法是：打开cmd输入下面命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping fengye97.github.io    #ping + 你的GitHub的网址</span><br></pre></td></tr></table></figure>

<p>打开 Blog 文件夹里的 source 文件夹，添加CNAME文件，可以先创建一个CNAME.txt文件，打开后写上你的域名，不要加www否则每次访问都必须加www，但如果不带有www，以后访问的时候带不带www都可以访问，保存后记得要重命名，将.txt删除。</p>
<p>打开GitHub，看看CNAME文件是否已经在你的项目中，点击 settings ，查看你的网址是否已保存。（Custom domain）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kiro-xu"
      src="/images/avater.jpg">
  <p class="site-author-name" itemprop="name">kiro-xu</p>
  <div class="site-description" itemprop="description">Be who you want to be</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-2 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kiro-xu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
